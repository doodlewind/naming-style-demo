/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 2);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/*!\n * Vue.js v2.4.1\n * (c) 2014-2017 Evan You\n * Released under the MIT License.\n */\n(function (global, factory) {\n  ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : global.Vue = factory();\n})(this, function () {\n  'use strict';\n\n  /*  */\n\n  // these helpers produces better vm code in JS engines due to their\n  // explicitness and function inlining\n\n  function isUndef(v) {\n    return v === undefined || v === null;\n  }\n\n  function isDef(v) {\n    return v !== undefined && v !== null;\n  }\n\n  function isTrue(v) {\n    return v === true;\n  }\n\n  function isFalse(v) {\n    return v === false;\n  }\n\n  /**\n   * Check if value is primitive\n   */\n  function isPrimitive(value) {\n    return typeof value === 'string' || typeof value === 'number';\n  }\n\n  /**\n   * Quick object check - this is primarily used to tell\n   * Objects from primitive values when we know the value\n   * is a JSON-compliant type.\n   */\n  function isObject(obj) {\n    return obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';\n  }\n\n  var _toString = Object.prototype.toString;\n\n  /**\n   * Strict object type check. Only returns true\n   * for plain JavaScript objects.\n   */\n  function isPlainObject(obj) {\n    return _toString.call(obj) === '[object Object]';\n  }\n\n  function isRegExp(v) {\n    return _toString.call(v) === '[object RegExp]';\n  }\n\n  /**\n   * Check if val is a valid array index.\n   */\n  function isValidArrayIndex(val) {\n    var n = parseFloat(val);\n    return n >= 0 && Math.floor(n) === n && isFinite(val);\n  }\n\n  /**\n   * Convert a value to a string that is actually rendered.\n   */\n  function toString(val) {\n    return val == null ? '' : (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' ? JSON.stringify(val, null, 2) : String(val);\n  }\n\n  /**\n   * Convert a input value to a number for persistence.\n   * If the conversion fails, return original string.\n   */\n  function toNumber(val) {\n    var n = parseFloat(val);\n    return isNaN(n) ? val : n;\n  }\n\n  /**\n   * Make a map and return a function for checking if a key\n   * is in that map.\n   */\n  function makeMap(str, expectsLowerCase) {\n    var map = Object.create(null);\n    var list = str.split(',');\n    for (var i = 0; i < list.length; i++) {\n      map[list[i]] = true;\n    }\n    return expectsLowerCase ? function (val) {\n      return map[val.toLowerCase()];\n    } : function (val) {\n      return map[val];\n    };\n  }\n\n  /**\n   * Check if a tag is a built-in tag.\n   */\n  var isBuiltInTag = makeMap('slot,component', true);\n\n  /**\n   * Check if a attribute is a reserved attribute.\n   */\n  var isReservedAttribute = makeMap('key,ref,slot,is');\n\n  /**\n   * Remove an item from an array\n   */\n  function remove(arr, item) {\n    if (arr.length) {\n      var index = arr.indexOf(item);\n      if (index > -1) {\n        return arr.splice(index, 1);\n      }\n    }\n  }\n\n  /**\n   * Check whether the object has the property.\n   */\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n  function hasOwn(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  }\n\n  /**\n   * Create a cached version of a pure function.\n   */\n  function cached(fn) {\n    var cache = Object.create(null);\n    return function cachedFn(str) {\n      var hit = cache[str];\n      return hit || (cache[str] = fn(str));\n    };\n  }\n\n  /**\n   * Camelize a hyphen-delimited string.\n   */\n  var camelizeRE = /-(\\w)/g;\n  var camelize = cached(function (str) {\n    return str.replace(camelizeRE, function (_, c) {\n      return c ? c.toUpperCase() : '';\n    });\n  });\n\n  /**\n   * Capitalize a string.\n   */\n  var capitalize = cached(function (str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n  });\n\n  /**\n   * Hyphenate a camelCase string.\n   */\n  var hyphenateRE = /([^-])([A-Z])/g;\n  var hyphenate = cached(function (str) {\n    return str.replace(hyphenateRE, '$1-$2').replace(hyphenateRE, '$1-$2').toLowerCase();\n  });\n\n  /**\n   * Simple bind, faster than native\n   */\n  function bind(fn, ctx) {\n    function boundFn(a) {\n      var l = arguments.length;\n      return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);\n    }\n    // record original fn length\n    boundFn._length = fn.length;\n    return boundFn;\n  }\n\n  /**\n   * Convert an Array-like object to a real Array.\n   */\n  function toArray(list, start) {\n    start = start || 0;\n    var i = list.length - start;\n    var ret = new Array(i);\n    while (i--) {\n      ret[i] = list[i + start];\n    }\n    return ret;\n  }\n\n  /**\n   * Mix properties into target object.\n   */\n  function extend(to, _from) {\n    for (var key in _from) {\n      to[key] = _from[key];\n    }\n    return to;\n  }\n\n  /**\n   * Merge an Array of Objects into a single Object.\n   */\n  function toObject(arr) {\n    var res = {};\n    for (var i = 0; i < arr.length; i++) {\n      if (arr[i]) {\n        extend(res, arr[i]);\n      }\n    }\n    return res;\n  }\n\n  /**\n   * Perform no operation.\n   * Stubbing args to make Flow happy without leaving useless transpiled code\n   * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)\n   */\n  function noop(a, b, c) {}\n\n  /**\n   * Always return false.\n   */\n  var no = function no(a, b, c) {\n    return false;\n  };\n\n  /**\n   * Return same value\n   */\n  var identity = function identity(_) {\n    return _;\n  };\n\n  /**\n   * Generate a static keys string from compiler modules.\n   */\n  function genStaticKeys(modules) {\n    return modules.reduce(function (keys, m) {\n      return keys.concat(m.staticKeys || []);\n    }, []).join(',');\n  }\n\n  /**\n   * Check if two values are loosely equal - that is,\n   * if they are plain objects, do they have the same shape?\n   */\n  function looseEqual(a, b) {\n    var isObjectA = isObject(a);\n    var isObjectB = isObject(b);\n    if (isObjectA && isObjectB) {\n      try {\n        return JSON.stringify(a) === JSON.stringify(b);\n      } catch (e) {\n        // possible circular reference\n        return a === b;\n      }\n    } else if (!isObjectA && !isObjectB) {\n      return String(a) === String(b);\n    } else {\n      return false;\n    }\n  }\n\n  function looseIndexOf(arr, val) {\n    for (var i = 0; i < arr.length; i++) {\n      if (looseEqual(arr[i], val)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Ensure a function is called only once.\n   */\n  function once(fn) {\n    var called = false;\n    return function () {\n      if (!called) {\n        called = true;\n        fn.apply(this, arguments);\n      }\n    };\n  }\n\n  var SSR_ATTR = 'data-server-rendered';\n\n  var ASSET_TYPES = ['component', 'directive', 'filter'];\n\n  var LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated'];\n\n  /*  */\n\n  var config = {\n    /**\n     * Option merge strategies (used in core/util/options)\n     */\n    optionMergeStrategies: Object.create(null),\n\n    /**\n     * Whether to suppress warnings.\n     */\n    silent: false,\n\n    /**\n     * Show production mode tip message on boot?\n     */\n    productionTip: \"development\" !== 'production',\n\n    /**\n     * Whether to enable devtools\n     */\n    devtools: \"development\" !== 'production',\n\n    /**\n     * Whether to record perf\n     */\n    performance: false,\n\n    /**\n     * Error handler for watcher errors\n     */\n    errorHandler: null,\n\n    /**\n     * Warn handler for watcher warns\n     */\n    warnHandler: null,\n\n    /**\n     * Ignore certain custom elements\n     */\n    ignoredElements: [],\n\n    /**\n     * Custom user key aliases for v-on\n     */\n    keyCodes: Object.create(null),\n\n    /**\n     * Check if a tag is reserved so that it cannot be registered as a\n     * component. This is platform-dependent and may be overwritten.\n     */\n    isReservedTag: no,\n\n    /**\n     * Check if an attribute is reserved so that it cannot be used as a component\n     * prop. This is platform-dependent and may be overwritten.\n     */\n    isReservedAttr: no,\n\n    /**\n     * Check if a tag is an unknown element.\n     * Platform-dependent.\n     */\n    isUnknownElement: no,\n\n    /**\n     * Get the namespace of an element\n     */\n    getTagNamespace: noop,\n\n    /**\n     * Parse the real tag name for the specific platform.\n     */\n    parsePlatformTagName: identity,\n\n    /**\n     * Check if an attribute must be bound using property, e.g. value\n     * Platform-dependent.\n     */\n    mustUseProp: no,\n\n    /**\n     * Exposed for legacy reasons\n     */\n    _lifecycleHooks: LIFECYCLE_HOOKS\n  };\n\n  /*  */\n\n  var emptyObject = Object.freeze({});\n\n  /**\n   * Check if a string starts with $ or _\n   */\n  function isReserved(str) {\n    var c = (str + '').charCodeAt(0);\n    return c === 0x24 || c === 0x5F;\n  }\n\n  /**\n   * Define a property.\n   */\n  function def(obj, key, val, enumerable) {\n    Object.defineProperty(obj, key, {\n      value: val,\n      enumerable: !!enumerable,\n      writable: true,\n      configurable: true\n    });\n  }\n\n  /**\n   * Parse simple path.\n   */\n  var bailRE = /[^\\w.$]/;\n  function parsePath(path) {\n    if (bailRE.test(path)) {\n      return;\n    }\n    var segments = path.split('.');\n    return function (obj) {\n      for (var i = 0; i < segments.length; i++) {\n        if (!obj) {\n          return;\n        }\n        obj = obj[segments[i]];\n      }\n      return obj;\n    };\n  }\n\n  /*  */\n\n  var warn = noop;\n  var tip = noop;\n  var formatComponentName = null; // work around flow check\n\n  {\n    var hasConsole = typeof console !== 'undefined';\n    var classifyRE = /(?:^|[-_])(\\w)/g;\n    var classify = function classify(str) {\n      return str.replace(classifyRE, function (c) {\n        return c.toUpperCase();\n      }).replace(/[-_]/g, '');\n    };\n\n    warn = function warn(msg, vm) {\n      var trace = vm ? generateComponentTrace(vm) : '';\n\n      if (config.warnHandler) {\n        config.warnHandler.call(null, msg, vm, trace);\n      } else if (hasConsole && !config.silent) {\n        console.error(\"[Vue warn]: \" + msg + trace);\n      }\n    };\n\n    tip = function tip(msg, vm) {\n      if (hasConsole && !config.silent) {\n        console.warn(\"[Vue tip]: \" + msg + (vm ? generateComponentTrace(vm) : ''));\n      }\n    };\n\n    formatComponentName = function formatComponentName(vm, includeFile) {\n      if (vm.$root === vm) {\n        return '<Root>';\n      }\n      var name = typeof vm === 'string' ? vm : typeof vm === 'function' && vm.options ? vm.options.name : vm._isVue ? vm.$options.name || vm.$options._componentTag : vm.name;\n\n      var file = vm._isVue && vm.$options.__file;\n      if (!name && file) {\n        var match = file.match(/([^/\\\\]+)\\.vue$/);\n        name = match && match[1];\n      }\n\n      return (name ? \"<\" + classify(name) + \">\" : \"<Anonymous>\") + (file && includeFile !== false ? \" at \" + file : '');\n    };\n\n    var repeat = function repeat(str, n) {\n      var res = '';\n      while (n) {\n        if (n % 2 === 1) {\n          res += str;\n        }\n        if (n > 1) {\n          str += str;\n        }\n        n >>= 1;\n      }\n      return res;\n    };\n\n    var generateComponentTrace = function generateComponentTrace(vm) {\n      if (vm._isVue && vm.$parent) {\n        var tree = [];\n        var currentRecursiveSequence = 0;\n        while (vm) {\n          if (tree.length > 0) {\n            var last = tree[tree.length - 1];\n            if (last.constructor === vm.constructor) {\n              currentRecursiveSequence++;\n              vm = vm.$parent;\n              continue;\n            } else if (currentRecursiveSequence > 0) {\n              tree[tree.length - 1] = [last, currentRecursiveSequence];\n              currentRecursiveSequence = 0;\n            }\n          }\n          tree.push(vm);\n          vm = vm.$parent;\n        }\n        return '\\n\\nfound in\\n\\n' + tree.map(function (vm, i) {\n          return \"\" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + \"... (\" + vm[1] + \" recursive calls)\" : formatComponentName(vm));\n        }).join('\\n');\n      } else {\n        return \"\\n\\n(found in \" + formatComponentName(vm) + \")\";\n      }\n    };\n  }\n\n  /*  */\n\n  function handleError(err, vm, info) {\n    if (config.errorHandler) {\n      config.errorHandler.call(null, err, vm, info);\n    } else {\n      {\n        warn(\"Error in \" + info + \": \\\"\" + err.toString() + \"\\\"\", vm);\n      }\n      /* istanbul ignore else */\n      if (inBrowser && typeof console !== 'undefined') {\n        console.error(err);\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  /*  */\n  /* globals MutationObserver */\n\n  // can we use __proto__?\n  var hasProto = '__proto__' in {};\n\n  // Browser environment sniffing\n  var inBrowser = typeof window !== 'undefined';\n  var UA = inBrowser && window.navigator.userAgent.toLowerCase();\n  var isIE = UA && /msie|trident/.test(UA);\n  var isIE9 = UA && UA.indexOf('msie 9.0') > 0;\n  var isEdge = UA && UA.indexOf('edge/') > 0;\n  var isAndroid = UA && UA.indexOf('android') > 0;\n  var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);\n  var isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\n\n  // Firefix has a \"watch\" function on Object.prototype...\n  var nativeWatch = {}.watch;\n\n  var supportsPassive = false;\n  if (inBrowser) {\n    try {\n      var opts = {};\n      Object.defineProperty(opts, 'passive', {\n        get: function get() {\n          /* istanbul ignore next */\n          supportsPassive = true;\n        }\n      }); // https://github.com/facebook/flow/issues/285\n      window.addEventListener('test-passive', null, opts);\n    } catch (e) {}\n  }\n\n  // this needs to be lazy-evaled because vue may be required before\n  // vue-server-renderer can set VUE_ENV\n  var _isServer;\n  var isServerRendering = function isServerRendering() {\n    if (_isServer === undefined) {\n      /* istanbul ignore if */\n      if (!inBrowser && typeof global !== 'undefined') {\n        // detect presence of vue-server-renderer and avoid\n        // Webpack shimming the process\n        _isServer = global['process'].env.VUE_ENV === 'server';\n      } else {\n        _isServer = false;\n      }\n    }\n    return _isServer;\n  };\n\n  // detect devtools\n  var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n  /* istanbul ignore next */\n  function isNative(Ctor) {\n    return typeof Ctor === 'function' && /native code/.test(Ctor.toString());\n  }\n\n  var hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\n  /**\n   * Defer a task to execute it asynchronously.\n   */\n  var nextTick = function () {\n    var callbacks = [];\n    var pending = false;\n    var timerFunc;\n\n    function nextTickHandler() {\n      pending = false;\n      var copies = callbacks.slice(0);\n      callbacks.length = 0;\n      for (var i = 0; i < copies.length; i++) {\n        copies[i]();\n      }\n    }\n\n    // the nextTick behavior leverages the microtask queue, which can be accessed\n    // via either native Promise.then or MutationObserver.\n    // MutationObserver has wider support, however it is seriously bugged in\n    // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n    // completely stops working after triggering a few times... so, if native\n    // Promise is available, we will use it:\n    /* istanbul ignore if */\n    if (typeof Promise !== 'undefined' && isNative(Promise)) {\n      var p = Promise.resolve();\n      var logError = function logError(err) {\n        console.error(err);\n      };\n      timerFunc = function timerFunc() {\n        p.then(nextTickHandler).catch(logError);\n        // in problematic UIWebViews, Promise.then doesn't completely break, but\n        // it can get stuck in a weird state where callbacks are pushed into the\n        // microtask queue but the queue isn't being flushed, until the browser\n        // needs to do some other work, e.g. handle a timer. Therefore we can\n        // \"force\" the microtask queue to be flushed by adding an empty timer.\n        if (isIOS) {\n          setTimeout(noop);\n        }\n      };\n    } else if (typeof MutationObserver !== 'undefined' && (isNative(MutationObserver) ||\n    // PhantomJS and iOS 7.x\n    MutationObserver.toString() === '[object MutationObserverConstructor]')) {\n      // use MutationObserver where native Promise is not available,\n      // e.g. PhantomJS IE11, iOS7, Android 4.4\n      var counter = 1;\n      var observer = new MutationObserver(nextTickHandler);\n      var textNode = document.createTextNode(String(counter));\n      observer.observe(textNode, {\n        characterData: true\n      });\n      timerFunc = function timerFunc() {\n        counter = (counter + 1) % 2;\n        textNode.data = String(counter);\n      };\n    } else {\n      // fallback to setTimeout\n      /* istanbul ignore next */\n      timerFunc = function timerFunc() {\n        setTimeout(nextTickHandler, 0);\n      };\n    }\n\n    return function queueNextTick(cb, ctx) {\n      var _resolve;\n      callbacks.push(function () {\n        if (cb) {\n          try {\n            cb.call(ctx);\n          } catch (e) {\n            handleError(e, ctx, 'nextTick');\n          }\n        } else if (_resolve) {\n          _resolve(ctx);\n        }\n      });\n      if (!pending) {\n        pending = true;\n        timerFunc();\n      }\n      if (!cb && typeof Promise !== 'undefined') {\n        return new Promise(function (resolve, reject) {\n          _resolve = resolve;\n        });\n      }\n    };\n  }();\n\n  var _Set;\n  /* istanbul ignore if */\n  if (typeof Set !== 'undefined' && isNative(Set)) {\n    // use native Set when available.\n    _Set = Set;\n  } else {\n    // a non-standard Set polyfill that only works with primitive keys.\n    _Set = function () {\n      function Set() {\n        this.set = Object.create(null);\n      }\n      Set.prototype.has = function has(key) {\n        return this.set[key] === true;\n      };\n      Set.prototype.add = function add(key) {\n        this.set[key] = true;\n      };\n      Set.prototype.clear = function clear() {\n        this.set = Object.create(null);\n      };\n\n      return Set;\n    }();\n  }\n\n  /*  */\n\n  var uid = 0;\n\n  /**\n   * A dep is an observable that can have multiple\n   * directives subscribing to it.\n   */\n  var Dep = function Dep() {\n    this.id = uid++;\n    this.subs = [];\n  };\n\n  Dep.prototype.addSub = function addSub(sub) {\n    this.subs.push(sub);\n  };\n\n  Dep.prototype.removeSub = function removeSub(sub) {\n    remove(this.subs, sub);\n  };\n\n  Dep.prototype.depend = function depend() {\n    if (Dep.target) {\n      Dep.target.addDep(this);\n    }\n  };\n\n  Dep.prototype.notify = function notify() {\n    // stabilize the subscriber list first\n    var subs = this.subs.slice();\n    for (var i = 0, l = subs.length; i < l; i++) {\n      subs[i].update();\n    }\n  };\n\n  // the current target watcher being evaluated.\n  // this is globally unique because there could be only one\n  // watcher being evaluated at any time.\n  Dep.target = null;\n  var targetStack = [];\n\n  function pushTarget(_target) {\n    if (Dep.target) {\n      targetStack.push(Dep.target);\n    }\n    Dep.target = _target;\n  }\n\n  function popTarget() {\n    Dep.target = targetStack.pop();\n  }\n\n  /*\n   * not type checking this file because flow doesn't play well with\n   * dynamically accessing methods on Array prototype\n   */\n\n  var arrayProto = Array.prototype;\n  var arrayMethods = Object.create(arrayProto);['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {\n    // cache original method\n    var original = arrayProto[method];\n    def(arrayMethods, method, function mutator() {\n      var args = [],\n          len = arguments.length;\n      while (len--) {\n        args[len] = arguments[len];\n      }var result = original.apply(this, args);\n      var ob = this.__ob__;\n      var inserted;\n      switch (method) {\n        case 'push':\n        case 'unshift':\n          inserted = args;\n          break;\n        case 'splice':\n          inserted = args.slice(2);\n          break;\n      }\n      if (inserted) {\n        ob.observeArray(inserted);\n      }\n      // notify change\n      ob.dep.notify();\n      return result;\n    });\n  });\n\n  /*  */\n\n  var arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n  /**\n   * By default, when a reactive property is set, the new value is\n   * also converted to become reactive. However when passing down props,\n   * we don't want to force conversion because the value may be a nested value\n   * under a frozen data structure. Converting it would defeat the optimization.\n   */\n  var observerState = {\n    shouldConvert: true\n  };\n\n  /**\n   * Observer class that are attached to each observed\n   * object. Once attached, the observer converts target\n   * object's property keys into getter/setters that\n   * collect dependencies and dispatches updates.\n   */\n  var Observer = function Observer(value) {\n    this.value = value;\n    this.dep = new Dep();\n    this.vmCount = 0;\n    def(value, '__ob__', this);\n    if (Array.isArray(value)) {\n      var augment = hasProto ? protoAugment : copyAugment;\n      augment(value, arrayMethods, arrayKeys);\n      this.observeArray(value);\n    } else {\n      this.walk(value);\n    }\n  };\n\n  /**\n   * Walk through each property and convert them into\n   * getter/setters. This method should only be called when\n   * value type is Object.\n   */\n  Observer.prototype.walk = function walk(obj) {\n    var keys = Object.keys(obj);\n    for (var i = 0; i < keys.length; i++) {\n      defineReactive$$1(obj, keys[i], obj[keys[i]]);\n    }\n  };\n\n  /**\n   * Observe a list of Array items.\n   */\n  Observer.prototype.observeArray = function observeArray(items) {\n    for (var i = 0, l = items.length; i < l; i++) {\n      observe(items[i]);\n    }\n  };\n\n  // helpers\n\n  /**\n   * Augment an target Object or Array by intercepting\n   * the prototype chain using __proto__\n   */\n  function protoAugment(target, src, keys) {\n    /* eslint-disable no-proto */\n    target.__proto__ = src;\n    /* eslint-enable no-proto */\n  }\n\n  /**\n   * Augment an target Object or Array by defining\n   * hidden properties.\n   */\n  /* istanbul ignore next */\n  function copyAugment(target, src, keys) {\n    for (var i = 0, l = keys.length; i < l; i++) {\n      var key = keys[i];\n      def(target, key, src[key]);\n    }\n  }\n\n  /**\n   * Attempt to create an observer instance for a value,\n   * returns the new observer if successfully observed,\n   * or the existing observer if the value already has one.\n   */\n  function observe(value, asRootData) {\n    if (!isObject(value)) {\n      return;\n    }\n    var ob;\n    if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n      ob = value.__ob__;\n    } else if (observerState.shouldConvert && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {\n      ob = new Observer(value);\n    }\n    if (asRootData && ob) {\n      ob.vmCount++;\n    }\n    return ob;\n  }\n\n  /**\n   * Define a reactive property on an Object.\n   */\n  function defineReactive$$1(obj, key, val, customSetter, shallow) {\n    var dep = new Dep();\n\n    var property = Object.getOwnPropertyDescriptor(obj, key);\n    if (property && property.configurable === false) {\n      return;\n    }\n\n    // cater for pre-defined getter/setters\n    var getter = property && property.get;\n    var setter = property && property.set;\n\n    var childOb = !shallow && observe(val);\n    Object.defineProperty(obj, key, {\n      enumerable: true,\n      configurable: true,\n      get: function reactiveGetter() {\n        var value = getter ? getter.call(obj) : val;\n        if (Dep.target) {\n          dep.depend();\n          if (childOb) {\n            childOb.dep.depend();\n          }\n          if (Array.isArray(value)) {\n            dependArray(value);\n          }\n        }\n        return value;\n      },\n      set: function reactiveSetter(newVal) {\n        var value = getter ? getter.call(obj) : val;\n        /* eslint-disable no-self-compare */\n        if (newVal === value || newVal !== newVal && value !== value) {\n          return;\n        }\n        /* eslint-enable no-self-compare */\n        if (\"development\" !== 'production' && customSetter) {\n          customSetter();\n        }\n        if (setter) {\n          setter.call(obj, newVal);\n        } else {\n          val = newVal;\n        }\n        childOb = !shallow && observe(newVal);\n        dep.notify();\n      }\n    });\n  }\n\n  /**\n   * Set a property on an object. Adds the new property and\n   * triggers change notification if the property doesn't\n   * already exist.\n   */\n  function set(target, key, val) {\n    if (Array.isArray(target) && isValidArrayIndex(key)) {\n      target.length = Math.max(target.length, key);\n      target.splice(key, 1, val);\n      return val;\n    }\n    if (hasOwn(target, key)) {\n      target[key] = val;\n      return val;\n    }\n    var ob = target.__ob__;\n    if (target._isVue || ob && ob.vmCount) {\n      \"development\" !== 'production' && warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');\n      return val;\n    }\n    if (!ob) {\n      target[key] = val;\n      return val;\n    }\n    defineReactive$$1(ob.value, key, val);\n    ob.dep.notify();\n    return val;\n  }\n\n  /**\n   * Delete a property and trigger change if necessary.\n   */\n  function del(target, key) {\n    if (Array.isArray(target) && isValidArrayIndex(key)) {\n      target.splice(key, 1);\n      return;\n    }\n    var ob = target.__ob__;\n    if (target._isVue || ob && ob.vmCount) {\n      \"development\" !== 'production' && warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');\n      return;\n    }\n    if (!hasOwn(target, key)) {\n      return;\n    }\n    delete target[key];\n    if (!ob) {\n      return;\n    }\n    ob.dep.notify();\n  }\n\n  /**\n   * Collect dependencies on array elements when the array is touched, since\n   * we cannot intercept array element access like property getters.\n   */\n  function dependArray(value) {\n    for (var e = void 0, i = 0, l = value.length; i < l; i++) {\n      e = value[i];\n      e && e.__ob__ && e.__ob__.dep.depend();\n      if (Array.isArray(e)) {\n        dependArray(e);\n      }\n    }\n  }\n\n  /*  */\n\n  /**\n   * Option overwriting strategies are functions that handle\n   * how to merge a parent option value and a child option\n   * value into the final value.\n   */\n  var strats = config.optionMergeStrategies;\n\n  /**\n   * Options with restrictions\n   */\n  {\n    strats.el = strats.propsData = function (parent, child, vm, key) {\n      if (!vm) {\n        warn(\"option \\\"\" + key + \"\\\" can only be used during instance \" + 'creation with the `new` keyword.');\n      }\n      return defaultStrat(parent, child);\n    };\n  }\n\n  /**\n   * Helper that recursively merges two data objects together.\n   */\n  function mergeData(to, from) {\n    if (!from) {\n      return to;\n    }\n    var key, toVal, fromVal;\n    var keys = Object.keys(from);\n    for (var i = 0; i < keys.length; i++) {\n      key = keys[i];\n      toVal = to[key];\n      fromVal = from[key];\n      if (!hasOwn(to, key)) {\n        set(to, key, fromVal);\n      } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {\n        mergeData(toVal, fromVal);\n      }\n    }\n    return to;\n  }\n\n  /**\n   * Data\n   */\n  function mergeDataOrFn(parentVal, childVal, vm) {\n    if (!vm) {\n      // in a Vue.extend merge, both should be functions\n      if (!childVal) {\n        return parentVal;\n      }\n      if (!parentVal) {\n        return childVal;\n      }\n      // when parentVal & childVal are both present,\n      // we need to return a function that returns the\n      // merged result of both functions... no need to\n      // check if parentVal is a function here because\n      // it has to be a function to pass previous merges.\n      return function mergedDataFn() {\n        return mergeData(typeof childVal === 'function' ? childVal.call(this) : childVal, parentVal.call(this));\n      };\n    } else if (parentVal || childVal) {\n      return function mergedInstanceDataFn() {\n        // instance merge\n        var instanceData = typeof childVal === 'function' ? childVal.call(vm) : childVal;\n        var defaultData = typeof parentVal === 'function' ? parentVal.call(vm) : undefined;\n        if (instanceData) {\n          return mergeData(instanceData, defaultData);\n        } else {\n          return defaultData;\n        }\n      };\n    }\n  }\n\n  strats.data = function (parentVal, childVal, vm) {\n    if (!vm) {\n      if (childVal && typeof childVal !== 'function') {\n        \"development\" !== 'production' && warn('The \"data\" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);\n\n        return parentVal;\n      }\n      return mergeDataOrFn.call(this, parentVal, childVal);\n    }\n\n    return mergeDataOrFn(parentVal, childVal, vm);\n  };\n\n  /**\n   * Hooks and props are merged as arrays.\n   */\n  function mergeHook(parentVal, childVal) {\n    return childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;\n  }\n\n  LIFECYCLE_HOOKS.forEach(function (hook) {\n    strats[hook] = mergeHook;\n  });\n\n  /**\n   * Assets\n   *\n   * When a vm is present (instance creation), we need to do\n   * a three-way merge between constructor options, instance\n   * options and parent options.\n   */\n  function mergeAssets(parentVal, childVal) {\n    var res = Object.create(parentVal || null);\n    return childVal ? extend(res, childVal) : res;\n  }\n\n  ASSET_TYPES.forEach(function (type) {\n    strats[type + 's'] = mergeAssets;\n  });\n\n  /**\n   * Watchers.\n   *\n   * Watchers hashes should not overwrite one\n   * another, so we merge them as arrays.\n   */\n  strats.watch = function (parentVal, childVal) {\n    // work around Firefox's Object.prototype.watch...\n    if (parentVal === nativeWatch) {\n      parentVal = undefined;\n    }\n    if (childVal === nativeWatch) {\n      childVal = undefined;\n    }\n    /* istanbul ignore if */\n    if (!childVal) {\n      return Object.create(parentVal || null);\n    }\n    if (!parentVal) {\n      return childVal;\n    }\n    var ret = {};\n    extend(ret, parentVal);\n    for (var key in childVal) {\n      var parent = ret[key];\n      var child = childVal[key];\n      if (parent && !Array.isArray(parent)) {\n        parent = [parent];\n      }\n      ret[key] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];\n    }\n    return ret;\n  };\n\n  /**\n   * Other object hashes.\n   */\n  strats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal) {\n    if (!childVal) {\n      return Object.create(parentVal || null);\n    }\n    if (!parentVal) {\n      return childVal;\n    }\n    var ret = Object.create(null);\n    extend(ret, parentVal);\n    extend(ret, childVal);\n    return ret;\n  };\n  strats.provide = mergeDataOrFn;\n\n  /**\n   * Default strategy.\n   */\n  var defaultStrat = function defaultStrat(parentVal, childVal) {\n    return childVal === undefined ? parentVal : childVal;\n  };\n\n  /**\n   * Validate component names\n   */\n  function checkComponents(options) {\n    for (var key in options.components) {\n      var lower = key.toLowerCase();\n      if (isBuiltInTag(lower) || config.isReservedTag(lower)) {\n        warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + key);\n      }\n    }\n  }\n\n  /**\n   * Ensure all props option syntax are normalized into the\n   * Object-based format.\n   */\n  function normalizeProps(options) {\n    var props = options.props;\n    if (!props) {\n      return;\n    }\n    var res = {};\n    var i, val, name;\n    if (Array.isArray(props)) {\n      i = props.length;\n      while (i--) {\n        val = props[i];\n        if (typeof val === 'string') {\n          name = camelize(val);\n          res[name] = { type: null };\n        } else {\n          warn('props must be strings when using array syntax.');\n        }\n      }\n    } else if (isPlainObject(props)) {\n      for (var key in props) {\n        val = props[key];\n        name = camelize(key);\n        res[name] = isPlainObject(val) ? val : { type: val };\n      }\n    }\n    options.props = res;\n  }\n\n  /**\n   * Normalize all injections into Object-based format\n   */\n  function normalizeInject(options) {\n    var inject = options.inject;\n    if (Array.isArray(inject)) {\n      var normalized = options.inject = {};\n      for (var i = 0; i < inject.length; i++) {\n        normalized[inject[i]] = inject[i];\n      }\n    }\n  }\n\n  /**\n   * Normalize raw function directives into object format.\n   */\n  function normalizeDirectives(options) {\n    var dirs = options.directives;\n    if (dirs) {\n      for (var key in dirs) {\n        var def = dirs[key];\n        if (typeof def === 'function') {\n          dirs[key] = { bind: def, update: def };\n        }\n      }\n    }\n  }\n\n  /**\n   * Merge two option objects into a new one.\n   * Core utility used in both instantiation and inheritance.\n   */\n  function mergeOptions(parent, child, vm) {\n    {\n      checkComponents(child);\n    }\n\n    if (typeof child === 'function') {\n      child = child.options;\n    }\n\n    normalizeProps(child);\n    normalizeInject(child);\n    normalizeDirectives(child);\n    var extendsFrom = child.extends;\n    if (extendsFrom) {\n      parent = mergeOptions(parent, extendsFrom, vm);\n    }\n    if (child.mixins) {\n      for (var i = 0, l = child.mixins.length; i < l; i++) {\n        parent = mergeOptions(parent, child.mixins[i], vm);\n      }\n    }\n    var options = {};\n    var key;\n    for (key in parent) {\n      mergeField(key);\n    }\n    for (key in child) {\n      if (!hasOwn(parent, key)) {\n        mergeField(key);\n      }\n    }\n    function mergeField(key) {\n      var strat = strats[key] || defaultStrat;\n      options[key] = strat(parent[key], child[key], vm, key);\n    }\n    return options;\n  }\n\n  /**\n   * Resolve an asset.\n   * This function is used because child instances need access\n   * to assets defined in its ancestor chain.\n   */\n  function resolveAsset(options, type, id, warnMissing) {\n    /* istanbul ignore if */\n    if (typeof id !== 'string') {\n      return;\n    }\n    var assets = options[type];\n    // check local registration variations first\n    if (hasOwn(assets, id)) {\n      return assets[id];\n    }\n    var camelizedId = camelize(id);\n    if (hasOwn(assets, camelizedId)) {\n      return assets[camelizedId];\n    }\n    var PascalCaseId = capitalize(camelizedId);\n    if (hasOwn(assets, PascalCaseId)) {\n      return assets[PascalCaseId];\n    }\n    // fallback to prototype chain\n    var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n    if (\"development\" !== 'production' && warnMissing && !res) {\n      warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);\n    }\n    return res;\n  }\n\n  /*  */\n\n  function validateProp(key, propOptions, propsData, vm) {\n    var prop = propOptions[key];\n    var absent = !hasOwn(propsData, key);\n    var value = propsData[key];\n    // handle boolean props\n    if (isType(Boolean, prop.type)) {\n      if (absent && !hasOwn(prop, 'default')) {\n        value = false;\n      } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {\n        value = true;\n      }\n    }\n    // check default value\n    if (value === undefined) {\n      value = getPropDefaultValue(vm, prop, key);\n      // since the default value is a fresh copy,\n      // make sure to observe it.\n      var prevShouldConvert = observerState.shouldConvert;\n      observerState.shouldConvert = true;\n      observe(value);\n      observerState.shouldConvert = prevShouldConvert;\n    }\n    {\n      assertProp(prop, key, value, vm, absent);\n    }\n    return value;\n  }\n\n  /**\n   * Get the default value of a prop.\n   */\n  function getPropDefaultValue(vm, prop, key) {\n    // no default, return undefined\n    if (!hasOwn(prop, 'default')) {\n      return undefined;\n    }\n    var def = prop.default;\n    // warn against non-factory defaults for Object & Array\n    if (\"development\" !== 'production' && isObject(def)) {\n      warn('Invalid default value for prop \"' + key + '\": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);\n    }\n    // the raw prop value was also undefined from previous render,\n    // return previous default value to avoid unnecessary watcher trigger\n    if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {\n      return vm._props[key];\n    }\n    // call factory function for non-Function types\n    // a value is Function if its prototype is function even across different execution context\n    return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;\n  }\n\n  /**\n   * Assert whether a prop is valid.\n   */\n  function assertProp(prop, name, value, vm, absent) {\n    if (prop.required && absent) {\n      warn('Missing required prop: \"' + name + '\"', vm);\n      return;\n    }\n    if (value == null && !prop.required) {\n      return;\n    }\n    var type = prop.type;\n    var valid = !type || type === true;\n    var expectedTypes = [];\n    if (type) {\n      if (!Array.isArray(type)) {\n        type = [type];\n      }\n      for (var i = 0; i < type.length && !valid; i++) {\n        var assertedType = assertType(value, type[i]);\n        expectedTypes.push(assertedType.expectedType || '');\n        valid = assertedType.valid;\n      }\n    }\n    if (!valid) {\n      warn('Invalid prop: type check failed for prop \"' + name + '\".' + ' Expected ' + expectedTypes.map(capitalize).join(', ') + ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.', vm);\n      return;\n    }\n    var validator = prop.validator;\n    if (validator) {\n      if (!validator(value)) {\n        warn('Invalid prop: custom validator check failed for prop \"' + name + '\".', vm);\n      }\n    }\n  }\n\n  var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;\n\n  function assertType(value, type) {\n    var valid;\n    var expectedType = getType(type);\n    if (simpleCheckRE.test(expectedType)) {\n      valid = (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === expectedType.toLowerCase();\n    } else if (expectedType === 'Object') {\n      valid = isPlainObject(value);\n    } else if (expectedType === 'Array') {\n      valid = Array.isArray(value);\n    } else {\n      valid = value instanceof type;\n    }\n    return {\n      valid: valid,\n      expectedType: expectedType\n    };\n  }\n\n  /**\n   * Use function string name to check built-in types,\n   * because a simple equality check will fail when running\n   * across different vms / iframes.\n   */\n  function getType(fn) {\n    var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n    return match ? match[1] : '';\n  }\n\n  function isType(type, fn) {\n    if (!Array.isArray(fn)) {\n      return getType(fn) === getType(type);\n    }\n    for (var i = 0, len = fn.length; i < len; i++) {\n      if (getType(fn[i]) === getType(type)) {\n        return true;\n      }\n    }\n    /* istanbul ignore next */\n    return false;\n  }\n\n  /*  */\n\n  var mark;\n  var measure;\n\n  {\n    var perf = inBrowser && window.performance;\n    /* istanbul ignore if */\n    if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {\n      mark = function mark(tag) {\n        return perf.mark(tag);\n      };\n      measure = function measure(name, startTag, endTag) {\n        perf.measure(name, startTag, endTag);\n        perf.clearMarks(startTag);\n        perf.clearMarks(endTag);\n        perf.clearMeasures(name);\n      };\n    }\n  }\n\n  /* not type checking this file because flow doesn't play well with Proxy */\n\n  var initProxy;\n\n  {\n    var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify\n    );\n\n    var warnNonPresent = function warnNonPresent(target, key) {\n      warn(\"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" + \"referenced during render. Make sure to declare reactive data \" + \"properties in the data option.\", target);\n    };\n\n    var hasProxy = typeof Proxy !== 'undefined' && Proxy.toString().match(/native code/);\n\n    if (hasProxy) {\n      var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');\n      config.keyCodes = new Proxy(config.keyCodes, {\n        set: function set(target, key, value) {\n          if (isBuiltInModifier(key)) {\n            warn(\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key);\n            return false;\n          } else {\n            target[key] = value;\n            return true;\n          }\n        }\n      });\n    }\n\n    var hasHandler = {\n      has: function has(target, key) {\n        var has = key in target;\n        var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';\n        if (!has && !isAllowed) {\n          warnNonPresent(target, key);\n        }\n        return has || !isAllowed;\n      }\n    };\n\n    var getHandler = {\n      get: function get(target, key) {\n        if (typeof key === 'string' && !(key in target)) {\n          warnNonPresent(target, key);\n        }\n        return target[key];\n      }\n    };\n\n    initProxy = function initProxy(vm) {\n      if (hasProxy) {\n        // determine which proxy handler to use\n        var options = vm.$options;\n        var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;\n        vm._renderProxy = new Proxy(vm, handlers);\n      } else {\n        vm._renderProxy = vm;\n      }\n    };\n  }\n\n  /*  */\n\n  var VNode = function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {\n    this.tag = tag;\n    this.data = data;\n    this.children = children;\n    this.text = text;\n    this.elm = elm;\n    this.ns = undefined;\n    this.context = context;\n    this.functionalContext = undefined;\n    this.key = data && data.key;\n    this.componentOptions = componentOptions;\n    this.componentInstance = undefined;\n    this.parent = undefined;\n    this.raw = false;\n    this.isStatic = false;\n    this.isRootInsert = true;\n    this.isComment = false;\n    this.isCloned = false;\n    this.isOnce = false;\n    this.asyncFactory = asyncFactory;\n    this.asyncMeta = undefined;\n    this.isAsyncPlaceholder = false;\n  };\n\n  var prototypeAccessors = { child: {} };\n\n  // DEPRECATED: alias for componentInstance for backwards compat.\n  /* istanbul ignore next */\n  prototypeAccessors.child.get = function () {\n    return this.componentInstance;\n  };\n\n  Object.defineProperties(VNode.prototype, prototypeAccessors);\n\n  var createEmptyVNode = function createEmptyVNode(text) {\n    if (text === void 0) text = '';\n\n    var node = new VNode();\n    node.text = text;\n    node.isComment = true;\n    return node;\n  };\n\n  function createTextVNode(val) {\n    return new VNode(undefined, undefined, undefined, String(val));\n  }\n\n  // optimized shallow clone\n  // used for static nodes and slot nodes because they may be reused across\n  // multiple renders, cloning them avoids errors when DOM manipulations rely\n  // on their elm reference.\n  function cloneVNode(vnode) {\n    var cloned = new VNode(vnode.tag, vnode.data, vnode.children, vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);\n    cloned.ns = vnode.ns;\n    cloned.isStatic = vnode.isStatic;\n    cloned.key = vnode.key;\n    cloned.isComment = vnode.isComment;\n    cloned.isCloned = true;\n    return cloned;\n  }\n\n  function cloneVNodes(vnodes) {\n    var len = vnodes.length;\n    var res = new Array(len);\n    for (var i = 0; i < len; i++) {\n      res[i] = cloneVNode(vnodes[i]);\n    }\n    return res;\n  }\n\n  /*  */\n\n  var normalizeEvent = cached(function (name) {\n    var passive = name.charAt(0) === '&';\n    name = passive ? name.slice(1) : name;\n    var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n    name = once$$1 ? name.slice(1) : name;\n    var capture = name.charAt(0) === '!';\n    name = capture ? name.slice(1) : name;\n    return {\n      name: name,\n      once: once$$1,\n      capture: capture,\n      passive: passive\n    };\n  });\n\n  function createFnInvoker(fns) {\n    function invoker() {\n      var arguments$1 = arguments;\n\n      var fns = invoker.fns;\n      if (Array.isArray(fns)) {\n        var cloned = fns.slice();\n        for (var i = 0; i < cloned.length; i++) {\n          cloned[i].apply(null, arguments$1);\n        }\n      } else {\n        // return handler return value for single handlers\n        return fns.apply(null, arguments);\n      }\n    }\n    invoker.fns = fns;\n    return invoker;\n  }\n\n  function updateListeners(on, oldOn, add, remove$$1, vm) {\n    var name, cur, old, event;\n    for (name in on) {\n      cur = on[name];\n      old = oldOn[name];\n      event = normalizeEvent(name);\n      if (isUndef(cur)) {\n        \"development\" !== 'production' && warn(\"Invalid handler for event \\\"\" + event.name + \"\\\": got \" + String(cur), vm);\n      } else if (isUndef(old)) {\n        if (isUndef(cur.fns)) {\n          cur = on[name] = createFnInvoker(cur);\n        }\n        add(event.name, cur, event.once, event.capture, event.passive);\n      } else if (cur !== old) {\n        old.fns = cur;\n        on[name] = old;\n      }\n    }\n    for (name in oldOn) {\n      if (isUndef(on[name])) {\n        event = normalizeEvent(name);\n        remove$$1(event.name, oldOn[name], event.capture);\n      }\n    }\n  }\n\n  /*  */\n\n  function mergeVNodeHook(def, hookKey, hook) {\n    var invoker;\n    var oldHook = def[hookKey];\n\n    function wrappedHook() {\n      hook.apply(this, arguments);\n      // important: remove merged hook to ensure it's called only once\n      // and prevent memory leak\n      remove(invoker.fns, wrappedHook);\n    }\n\n    if (isUndef(oldHook)) {\n      // no existing hook\n      invoker = createFnInvoker([wrappedHook]);\n    } else {\n      /* istanbul ignore if */\n      if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n        // already a merged invoker\n        invoker = oldHook;\n        invoker.fns.push(wrappedHook);\n      } else {\n        // existing plain hook\n        invoker = createFnInvoker([oldHook, wrappedHook]);\n      }\n    }\n\n    invoker.merged = true;\n    def[hookKey] = invoker;\n  }\n\n  /*  */\n\n  function extractPropsFromVNodeData(data, Ctor, tag) {\n    // we are only extracting raw values here.\n    // validation and default values are handled in the child\n    // component itself.\n    var propOptions = Ctor.options.props;\n    if (isUndef(propOptions)) {\n      return;\n    }\n    var res = {};\n    var attrs = data.attrs;\n    var props = data.props;\n    if (isDef(attrs) || isDef(props)) {\n      for (var key in propOptions) {\n        var altKey = hyphenate(key);\n        {\n          var keyInLowerCase = key.toLowerCase();\n          if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {\n            tip(\"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" + formatComponentName(tag || Ctor) + \", but the declared prop name is\" + \" \\\"\" + key + \"\\\". \" + \"Note that HTML attributes are case-insensitive and camelCased \" + \"props need to use their kebab-case equivalents when using in-DOM \" + \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\");\n          }\n        }\n        checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);\n      }\n    }\n    return res;\n  }\n\n  function checkProp(res, hash, key, altKey, preserve) {\n    if (isDef(hash)) {\n      if (hasOwn(hash, key)) {\n        res[key] = hash[key];\n        if (!preserve) {\n          delete hash[key];\n        }\n        return true;\n      } else if (hasOwn(hash, altKey)) {\n        res[key] = hash[altKey];\n        if (!preserve) {\n          delete hash[altKey];\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /*  */\n\n  // The template compiler attempts to minimize the need for normalization by\n  // statically analyzing the template at compile time.\n  //\n  // For plain HTML markup, normalization can be completely skipped because the\n  // generated render function is guaranteed to return Array<VNode>. There are\n  // two cases where extra normalization is needed:\n\n  // 1. When the children contains components - because a functional component\n  // may return an Array instead of a single root. In this case, just a simple\n  // normalization is needed - if any child is an Array, we flatten the whole\n  // thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n  // because functional components already normalize their own children.\n  function simpleNormalizeChildren(children) {\n    for (var i = 0; i < children.length; i++) {\n      if (Array.isArray(children[i])) {\n        return Array.prototype.concat.apply([], children);\n      }\n    }\n    return children;\n  }\n\n  // 2. When the children contains constructs that always generated nested Arrays,\n  // e.g. <template>, <slot>, v-for, or when the children is provided by user\n  // with hand-written render functions / JSX. In such cases a full normalization\n  // is needed to cater to all possible types of children values.\n  function normalizeChildren(children) {\n    return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;\n  }\n\n  function isTextNode(node) {\n    return isDef(node) && isDef(node.text) && isFalse(node.isComment);\n  }\n\n  function normalizeArrayChildren(children, nestedIndex) {\n    var res = [];\n    var i, c, last;\n    for (i = 0; i < children.length; i++) {\n      c = children[i];\n      if (isUndef(c) || typeof c === 'boolean') {\n        continue;\n      }\n      last = res[res.length - 1];\n      //  nested\n      if (Array.isArray(c)) {\n        res.push.apply(res, normalizeArrayChildren(c, (nestedIndex || '') + \"_\" + i));\n      } else if (isPrimitive(c)) {\n        if (isTextNode(last)) {\n          // merge adjacent text nodes\n          // this is necessary for SSR hydration because text nodes are\n          // essentially merged when rendered to HTML strings\n          last.text += String(c);\n        } else if (c !== '') {\n          // convert primitive to vnode\n          res.push(createTextVNode(c));\n        }\n      } else {\n        if (isTextNode(c) && isTextNode(last)) {\n          // merge adjacent text nodes\n          res[res.length - 1] = createTextVNode(last.text + c.text);\n        } else {\n          // default key for nested array children (likely generated by v-for)\n          if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {\n            c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n          }\n          res.push(c);\n        }\n      }\n    }\n    return res;\n  }\n\n  /*  */\n\n  function ensureCtor(comp, base) {\n    if (comp.__esModule && comp.default) {\n      comp = comp.default;\n    }\n    return isObject(comp) ? base.extend(comp) : comp;\n  }\n\n  function createAsyncPlaceholder(factory, data, context, children, tag) {\n    var node = createEmptyVNode();\n    node.asyncFactory = factory;\n    node.asyncMeta = { data: data, context: context, children: children, tag: tag };\n    return node;\n  }\n\n  function resolveAsyncComponent(factory, baseCtor, context) {\n    if (isTrue(factory.error) && isDef(factory.errorComp)) {\n      return factory.errorComp;\n    }\n\n    if (isDef(factory.resolved)) {\n      return factory.resolved;\n    }\n\n    if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n      return factory.loadingComp;\n    }\n\n    if (isDef(factory.contexts)) {\n      // already pending\n      factory.contexts.push(context);\n    } else {\n      var contexts = factory.contexts = [context];\n      var sync = true;\n\n      var forceRender = function forceRender() {\n        for (var i = 0, l = contexts.length; i < l; i++) {\n          contexts[i].$forceUpdate();\n        }\n      };\n\n      var resolve = once(function (res) {\n        // cache resolved\n        factory.resolved = ensureCtor(res, baseCtor);\n        // invoke callbacks only if this is not a synchronous resolve\n        // (async resolves are shimmed as synchronous during SSR)\n        if (!sync) {\n          forceRender();\n        }\n      });\n\n      var reject = once(function (reason) {\n        \"development\" !== 'production' && warn(\"Failed to resolve async component: \" + String(factory) + (reason ? \"\\nReason: \" + reason : ''));\n        if (isDef(factory.errorComp)) {\n          factory.error = true;\n          forceRender();\n        }\n      });\n\n      var res = factory(resolve, reject);\n\n      if (isObject(res)) {\n        if (typeof res.then === 'function') {\n          // () => Promise\n          if (isUndef(factory.resolved)) {\n            res.then(resolve, reject);\n          }\n        } else if (isDef(res.component) && typeof res.component.then === 'function') {\n          res.component.then(resolve, reject);\n\n          if (isDef(res.error)) {\n            factory.errorComp = ensureCtor(res.error, baseCtor);\n          }\n\n          if (isDef(res.loading)) {\n            factory.loadingComp = ensureCtor(res.loading, baseCtor);\n            if (res.delay === 0) {\n              factory.loading = true;\n            } else {\n              setTimeout(function () {\n                if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                  factory.loading = true;\n                  forceRender();\n                }\n              }, res.delay || 200);\n            }\n          }\n\n          if (isDef(res.timeout)) {\n            setTimeout(function () {\n              if (isUndef(factory.resolved)) {\n                reject(\"timeout (\" + res.timeout + \"ms)\");\n              }\n            }, res.timeout);\n          }\n        }\n      }\n\n      sync = false;\n      // return in case resolved synchronously\n      return factory.loading ? factory.loadingComp : factory.resolved;\n    }\n  }\n\n  /*  */\n\n  function getFirstComponentChild(children) {\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length; i++) {\n        var c = children[i];\n        if (isDef(c) && isDef(c.componentOptions)) {\n          return c;\n        }\n      }\n    }\n  }\n\n  /*  */\n\n  /*  */\n\n  function initEvents(vm) {\n    vm._events = Object.create(null);\n    vm._hasHookEvent = false;\n    // init parent attached events\n    var listeners = vm.$options._parentListeners;\n    if (listeners) {\n      updateComponentListeners(vm, listeners);\n    }\n  }\n\n  var target;\n\n  function add(event, fn, once$$1) {\n    if (once$$1) {\n      target.$once(event, fn);\n    } else {\n      target.$on(event, fn);\n    }\n  }\n\n  function remove$1(event, fn) {\n    target.$off(event, fn);\n  }\n\n  function updateComponentListeners(vm, listeners, oldListeners) {\n    target = vm;\n    updateListeners(listeners, oldListeners || {}, add, remove$1, vm);\n  }\n\n  function eventsMixin(Vue) {\n    var hookRE = /^hook:/;\n    Vue.prototype.$on = function (event, fn) {\n      var this$1 = this;\n\n      var vm = this;\n      if (Array.isArray(event)) {\n        for (var i = 0, l = event.length; i < l; i++) {\n          this$1.$on(event[i], fn);\n        }\n      } else {\n        (vm._events[event] || (vm._events[event] = [])).push(fn);\n        // optimize hook:event cost by using a boolean flag marked at registration\n        // instead of a hash lookup\n        if (hookRE.test(event)) {\n          vm._hasHookEvent = true;\n        }\n      }\n      return vm;\n    };\n\n    Vue.prototype.$once = function (event, fn) {\n      var vm = this;\n      function on() {\n        vm.$off(event, on);\n        fn.apply(vm, arguments);\n      }\n      on.fn = fn;\n      vm.$on(event, on);\n      return vm;\n    };\n\n    Vue.prototype.$off = function (event, fn) {\n      var this$1 = this;\n\n      var vm = this;\n      // all\n      if (!arguments.length) {\n        vm._events = Object.create(null);\n        return vm;\n      }\n      // array of events\n      if (Array.isArray(event)) {\n        for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {\n          this$1.$off(event[i$1], fn);\n        }\n        return vm;\n      }\n      // specific event\n      var cbs = vm._events[event];\n      if (!cbs) {\n        return vm;\n      }\n      if (arguments.length === 1) {\n        vm._events[event] = null;\n        return vm;\n      }\n      // specific handler\n      var cb;\n      var i = cbs.length;\n      while (i--) {\n        cb = cbs[i];\n        if (cb === fn || cb.fn === fn) {\n          cbs.splice(i, 1);\n          break;\n        }\n      }\n      return vm;\n    };\n\n    Vue.prototype.$emit = function (event) {\n      var vm = this;\n      {\n        var lowerCaseEvent = event.toLowerCase();\n        if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n          tip(\"Event \\\"\" + lowerCaseEvent + \"\\\" is emitted in component \" + formatComponentName(vm) + \" but the handler is registered for \\\"\" + event + \"\\\". \" + \"Note that HTML attributes are case-insensitive and you cannot use \" + \"v-on to listen to camelCase events when using in-DOM templates. \" + \"You should probably use \\\"\" + hyphenate(event) + \"\\\" instead of \\\"\" + event + \"\\\".\");\n        }\n      }\n      var cbs = vm._events[event];\n      if (cbs) {\n        cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n        var args = toArray(arguments, 1);\n        for (var i = 0, l = cbs.length; i < l; i++) {\n          try {\n            cbs[i].apply(vm, args);\n          } catch (e) {\n            handleError(e, vm, \"event handler for \\\"\" + event + \"\\\"\");\n          }\n        }\n      }\n      return vm;\n    };\n  }\n\n  /*  */\n\n  /**\n   * Runtime helper for resolving raw children VNodes into a slot object.\n   */\n  function resolveSlots(children, context) {\n    var slots = {};\n    if (!children) {\n      return slots;\n    }\n    var defaultSlot = [];\n    for (var i = 0, l = children.length; i < l; i++) {\n      var child = children[i];\n      // named slots should only be respected if the vnode was rendered in the\n      // same context.\n      if ((child.context === context || child.functionalContext === context) && child.data && child.data.slot != null) {\n        var name = child.data.slot;\n        var slot = slots[name] || (slots[name] = []);\n        if (child.tag === 'template') {\n          slot.push.apply(slot, child.children);\n        } else {\n          slot.push(child);\n        }\n      } else {\n        defaultSlot.push(child);\n      }\n    }\n    // ignore whitespace\n    if (!defaultSlot.every(isWhitespace)) {\n      slots.default = defaultSlot;\n    }\n    return slots;\n  }\n\n  function isWhitespace(node) {\n    return node.isComment || node.text === ' ';\n  }\n\n  function resolveScopedSlots(fns, // see flow/vnode\n  res) {\n    res = res || {};\n    for (var i = 0; i < fns.length; i++) {\n      if (Array.isArray(fns[i])) {\n        resolveScopedSlots(fns[i], res);\n      } else {\n        res[fns[i].key] = fns[i].fn;\n      }\n    }\n    return res;\n  }\n\n  /*  */\n\n  var activeInstance = null;\n  var isUpdatingChildComponent = false;\n\n  function initLifecycle(vm) {\n    var options = vm.$options;\n\n    // locate first non-abstract parent\n    var parent = options.parent;\n    if (parent && !options.abstract) {\n      while (parent.$options.abstract && parent.$parent) {\n        parent = parent.$parent;\n      }\n      parent.$children.push(vm);\n    }\n\n    vm.$parent = parent;\n    vm.$root = parent ? parent.$root : vm;\n\n    vm.$children = [];\n    vm.$refs = {};\n\n    vm._watcher = null;\n    vm._inactive = null;\n    vm._directInactive = false;\n    vm._isMounted = false;\n    vm._isDestroyed = false;\n    vm._isBeingDestroyed = false;\n  }\n\n  function lifecycleMixin(Vue) {\n    Vue.prototype._update = function (vnode, hydrating) {\n      var vm = this;\n      if (vm._isMounted) {\n        callHook(vm, 'beforeUpdate');\n      }\n      var prevEl = vm.$el;\n      var prevVnode = vm._vnode;\n      var prevActiveInstance = activeInstance;\n      activeInstance = vm;\n      vm._vnode = vnode;\n      // Vue.prototype.__patch__ is injected in entry points\n      // based on the rendering backend used.\n      if (!prevVnode) {\n        // initial render\n        vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */\n        , vm.$options._parentElm, vm.$options._refElm);\n        // no need for the ref nodes after initial patch\n        // this prevents keeping a detached DOM tree in memory (#5851)\n        vm.$options._parentElm = vm.$options._refElm = null;\n      } else {\n        // updates\n        vm.$el = vm.__patch__(prevVnode, vnode);\n      }\n      activeInstance = prevActiveInstance;\n      // update __vue__ reference\n      if (prevEl) {\n        prevEl.__vue__ = null;\n      }\n      if (vm.$el) {\n        vm.$el.__vue__ = vm;\n      }\n      // if parent is an HOC, update its $el as well\n      if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n        vm.$parent.$el = vm.$el;\n      }\n      // updated hook is called by the scheduler to ensure that children are\n      // updated in a parent's updated hook.\n    };\n\n    Vue.prototype.$forceUpdate = function () {\n      var vm = this;\n      if (vm._watcher) {\n        vm._watcher.update();\n      }\n    };\n\n    Vue.prototype.$destroy = function () {\n      var vm = this;\n      if (vm._isBeingDestroyed) {\n        return;\n      }\n      callHook(vm, 'beforeDestroy');\n      vm._isBeingDestroyed = true;\n      // remove self from parent\n      var parent = vm.$parent;\n      if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n        remove(parent.$children, vm);\n      }\n      // teardown watchers\n      if (vm._watcher) {\n        vm._watcher.teardown();\n      }\n      var i = vm._watchers.length;\n      while (i--) {\n        vm._watchers[i].teardown();\n      }\n      // remove reference from data ob\n      // frozen object may not have observer.\n      if (vm._data.__ob__) {\n        vm._data.__ob__.vmCount--;\n      }\n      // call the last hook...\n      vm._isDestroyed = true;\n      // invoke destroy hooks on current rendered tree\n      vm.__patch__(vm._vnode, null);\n      // fire destroyed hook\n      callHook(vm, 'destroyed');\n      // turn off all instance listeners.\n      vm.$off();\n      // remove __vue__ reference\n      if (vm.$el) {\n        vm.$el.__vue__ = null;\n      }\n    };\n  }\n\n  function mountComponent(vm, el, hydrating) {\n    vm.$el = el;\n    if (!vm.$options.render) {\n      vm.$options.render = createEmptyVNode;\n      {\n        /* istanbul ignore if */\n        if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {\n          warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);\n        } else {\n          warn('Failed to mount component: template or render function not defined.', vm);\n        }\n      }\n    }\n    callHook(vm, 'beforeMount');\n\n    var updateComponent;\n    /* istanbul ignore if */\n    if (\"development\" !== 'production' && config.performance && mark) {\n      updateComponent = function updateComponent() {\n        var name = vm._name;\n        var id = vm._uid;\n        var startTag = \"vue-perf-start:\" + id;\n        var endTag = \"vue-perf-end:\" + id;\n\n        mark(startTag);\n        var vnode = vm._render();\n        mark(endTag);\n        measure(name + \" render\", startTag, endTag);\n\n        mark(startTag);\n        vm._update(vnode, hydrating);\n        mark(endTag);\n        measure(name + \" patch\", startTag, endTag);\n      };\n    } else {\n      updateComponent = function updateComponent() {\n        vm._update(vm._render(), hydrating);\n      };\n    }\n\n    vm._watcher = new Watcher(vm, updateComponent, noop);\n    hydrating = false;\n\n    // manually mounted instance, call mounted on self\n    // mounted is called for render-created child components in its inserted hook\n    if (vm.$vnode == null) {\n      vm._isMounted = true;\n      callHook(vm, 'mounted');\n    }\n    return vm;\n  }\n\n  function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {\n    {\n      isUpdatingChildComponent = true;\n    }\n\n    // determine whether component has slot children\n    // we need to do this before overwriting $options._renderChildren\n    var hasChildren = !!(renderChildren || // has new static slots\n    vm.$options._renderChildren || // has old static slots\n    parentVnode.data.scopedSlots || // has new scoped slots\n    vm.$scopedSlots !== emptyObject // has old scoped slots\n    );\n\n    vm.$options._parentVnode = parentVnode;\n    vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n\n    if (vm._vnode) {\n      // update child tree's parent\n      vm._vnode.parent = parentVnode;\n    }\n    vm.$options._renderChildren = renderChildren;\n\n    // update $attrs and $listensers hash\n    // these are also reactive so they may trigger child update if the child\n    // used them during render\n    vm.$attrs = parentVnode.data && parentVnode.data.attrs;\n    vm.$listeners = listeners;\n\n    // update props\n    if (propsData && vm.$options.props) {\n      observerState.shouldConvert = false;\n      var props = vm._props;\n      var propKeys = vm.$options._propKeys || [];\n      for (var i = 0; i < propKeys.length; i++) {\n        var key = propKeys[i];\n        props[key] = validateProp(key, vm.$options.props, propsData, vm);\n      }\n      observerState.shouldConvert = true;\n      // keep a copy of raw propsData\n      vm.$options.propsData = propsData;\n    }\n\n    // update listeners\n    if (listeners) {\n      var oldListeners = vm.$options._parentListeners;\n      vm.$options._parentListeners = listeners;\n      updateComponentListeners(vm, listeners, oldListeners);\n    }\n    // resolve slots + force update if has children\n    if (hasChildren) {\n      vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n      vm.$forceUpdate();\n    }\n\n    {\n      isUpdatingChildComponent = false;\n    }\n  }\n\n  function isInInactiveTree(vm) {\n    while (vm && (vm = vm.$parent)) {\n      if (vm._inactive) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function activateChildComponent(vm, direct) {\n    if (direct) {\n      vm._directInactive = false;\n      if (isInInactiveTree(vm)) {\n        return;\n      }\n    } else if (vm._directInactive) {\n      return;\n    }\n    if (vm._inactive || vm._inactive === null) {\n      vm._inactive = false;\n      for (var i = 0; i < vm.$children.length; i++) {\n        activateChildComponent(vm.$children[i]);\n      }\n      callHook(vm, 'activated');\n    }\n  }\n\n  function deactivateChildComponent(vm, direct) {\n    if (direct) {\n      vm._directInactive = true;\n      if (isInInactiveTree(vm)) {\n        return;\n      }\n    }\n    if (!vm._inactive) {\n      vm._inactive = true;\n      for (var i = 0; i < vm.$children.length; i++) {\n        deactivateChildComponent(vm.$children[i]);\n      }\n      callHook(vm, 'deactivated');\n    }\n  }\n\n  function callHook(vm, hook) {\n    var handlers = vm.$options[hook];\n    if (handlers) {\n      for (var i = 0, j = handlers.length; i < j; i++) {\n        try {\n          handlers[i].call(vm);\n        } catch (e) {\n          handleError(e, vm, hook + \" hook\");\n        }\n      }\n    }\n    if (vm._hasHookEvent) {\n      vm.$emit('hook:' + hook);\n    }\n  }\n\n  /*  */\n\n  var MAX_UPDATE_COUNT = 100;\n\n  var queue = [];\n  var activatedChildren = [];\n  var has = {};\n  var circular = {};\n  var waiting = false;\n  var flushing = false;\n  var index = 0;\n\n  /**\n   * Reset the scheduler's state.\n   */\n  function resetSchedulerState() {\n    index = queue.length = activatedChildren.length = 0;\n    has = {};\n    {\n      circular = {};\n    }\n    waiting = flushing = false;\n  }\n\n  /**\n   * Flush both queues and run the watchers.\n   */\n  function flushSchedulerQueue() {\n    flushing = true;\n    var watcher, id;\n\n    // Sort queue before flush.\n    // This ensures that:\n    // 1. Components are updated from parent to child. (because parent is always\n    //    created before the child)\n    // 2. A component's user watchers are run before its render watcher (because\n    //    user watchers are created before the render watcher)\n    // 3. If a component is destroyed during a parent component's watcher run,\n    //    its watchers can be skipped.\n    queue.sort(function (a, b) {\n      return a.id - b.id;\n    });\n\n    // do not cache length because more watchers might be pushed\n    // as we run existing watchers\n    for (index = 0; index < queue.length; index++) {\n      watcher = queue[index];\n      id = watcher.id;\n      has[id] = null;\n      watcher.run();\n      // in dev build, check and stop circular updates.\n      if (\"development\" !== 'production' && has[id] != null) {\n        circular[id] = (circular[id] || 0) + 1;\n        if (circular[id] > MAX_UPDATE_COUNT) {\n          warn('You may have an infinite update loop ' + (watcher.user ? \"in watcher with expression \\\"\" + watcher.expression + \"\\\"\" : \"in a component render function.\"), watcher.vm);\n          break;\n        }\n      }\n    }\n\n    // keep copies of post queues before resetting state\n    var activatedQueue = activatedChildren.slice();\n    var updatedQueue = queue.slice();\n\n    resetSchedulerState();\n\n    // call component updated and activated hooks\n    callActivatedHooks(activatedQueue);\n    callUpdatedHooks(updatedQueue);\n\n    // devtool hook\n    /* istanbul ignore if */\n    if (devtools && config.devtools) {\n      devtools.emit('flush');\n    }\n  }\n\n  function callUpdatedHooks(queue) {\n    var i = queue.length;\n    while (i--) {\n      var watcher = queue[i];\n      var vm = watcher.vm;\n      if (vm._watcher === watcher && vm._isMounted) {\n        callHook(vm, 'updated');\n      }\n    }\n  }\n\n  /**\n   * Queue a kept-alive component that was activated during patch.\n   * The queue will be processed after the entire tree has been patched.\n   */\n  function queueActivatedComponent(vm) {\n    // setting _inactive to false here so that a render function can\n    // rely on checking whether it's in an inactive tree (e.g. router-view)\n    vm._inactive = false;\n    activatedChildren.push(vm);\n  }\n\n  function callActivatedHooks(queue) {\n    for (var i = 0; i < queue.length; i++) {\n      queue[i]._inactive = true;\n      activateChildComponent(queue[i], true /* true */);\n    }\n  }\n\n  /**\n   * Push a watcher into the watcher queue.\n   * Jobs with duplicate IDs will be skipped unless it's\n   * pushed when the queue is being flushed.\n   */\n  function queueWatcher(watcher) {\n    var id = watcher.id;\n    if (has[id] == null) {\n      has[id] = true;\n      if (!flushing) {\n        queue.push(watcher);\n      } else {\n        // if already flushing, splice the watcher based on its id\n        // if already past its id, it will be run next immediately.\n        var i = queue.length - 1;\n        while (i > index && queue[i].id > watcher.id) {\n          i--;\n        }\n        queue.splice(i + 1, 0, watcher);\n      }\n      // queue the flush\n      if (!waiting) {\n        waiting = true;\n        nextTick(flushSchedulerQueue);\n      }\n    }\n  }\n\n  /*  */\n\n  var uid$2 = 0;\n\n  /**\n   * A watcher parses an expression, collects dependencies,\n   * and fires callback when the expression value changes.\n   * This is used for both the $watch() api and directives.\n   */\n  var Watcher = function Watcher(vm, expOrFn, cb, options) {\n    this.vm = vm;\n    vm._watchers.push(this);\n    // options\n    if (options) {\n      this.deep = !!options.deep;\n      this.user = !!options.user;\n      this.lazy = !!options.lazy;\n      this.sync = !!options.sync;\n    } else {\n      this.deep = this.user = this.lazy = this.sync = false;\n    }\n    this.cb = cb;\n    this.id = ++uid$2; // uid for batching\n    this.active = true;\n    this.dirty = this.lazy; // for lazy watchers\n    this.deps = [];\n    this.newDeps = [];\n    this.depIds = new _Set();\n    this.newDepIds = new _Set();\n    this.expression = expOrFn.toString();\n    // parse expression for getter\n    if (typeof expOrFn === 'function') {\n      this.getter = expOrFn;\n    } else {\n      this.getter = parsePath(expOrFn);\n      if (!this.getter) {\n        this.getter = function () {};\n        \"development\" !== 'production' && warn(\"Failed watching path: \\\"\" + expOrFn + \"\\\" \" + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);\n      }\n    }\n    this.value = this.lazy ? undefined : this.get();\n  };\n\n  /**\n   * Evaluate the getter, and re-collect dependencies.\n   */\n  Watcher.prototype.get = function get() {\n    pushTarget(this);\n    var value;\n    var vm = this.vm;\n    try {\n      value = this.getter.call(vm, vm);\n    } catch (e) {\n      if (this.user) {\n        handleError(e, vm, \"getter for watcher \\\"\" + this.expression + \"\\\"\");\n      } else {\n        throw e;\n      }\n    } finally {\n      // \"touch\" every property so they are all tracked as\n      // dependencies for deep watching\n      if (this.deep) {\n        traverse(value);\n      }\n      popTarget();\n      this.cleanupDeps();\n    }\n    return value;\n  };\n\n  /**\n   * Add a dependency to this directive.\n   */\n  Watcher.prototype.addDep = function addDep(dep) {\n    var id = dep.id;\n    if (!this.newDepIds.has(id)) {\n      this.newDepIds.add(id);\n      this.newDeps.push(dep);\n      if (!this.depIds.has(id)) {\n        dep.addSub(this);\n      }\n    }\n  };\n\n  /**\n   * Clean up for dependency collection.\n   */\n  Watcher.prototype.cleanupDeps = function cleanupDeps() {\n    var this$1 = this;\n\n    var i = this.deps.length;\n    while (i--) {\n      var dep = this$1.deps[i];\n      if (!this$1.newDepIds.has(dep.id)) {\n        dep.removeSub(this$1);\n      }\n    }\n    var tmp = this.depIds;\n    this.depIds = this.newDepIds;\n    this.newDepIds = tmp;\n    this.newDepIds.clear();\n    tmp = this.deps;\n    this.deps = this.newDeps;\n    this.newDeps = tmp;\n    this.newDeps.length = 0;\n  };\n\n  /**\n   * Subscriber interface.\n   * Will be called when a dependency changes.\n   */\n  Watcher.prototype.update = function update() {\n    /* istanbul ignore else */\n    if (this.lazy) {\n      this.dirty = true;\n    } else if (this.sync) {\n      this.run();\n    } else {\n      queueWatcher(this);\n    }\n  };\n\n  /**\n   * Scheduler job interface.\n   * Will be called by the scheduler.\n   */\n  Watcher.prototype.run = function run() {\n    if (this.active) {\n      var value = this.get();\n      if (value !== this.value ||\n      // Deep watchers and watchers on Object/Arrays should fire even\n      // when the value is the same, because the value may\n      // have mutated.\n      isObject(value) || this.deep) {\n        // set new value\n        var oldValue = this.value;\n        this.value = value;\n        if (this.user) {\n          try {\n            this.cb.call(this.vm, value, oldValue);\n          } catch (e) {\n            handleError(e, this.vm, \"callback for watcher \\\"\" + this.expression + \"\\\"\");\n          }\n        } else {\n          this.cb.call(this.vm, value, oldValue);\n        }\n      }\n    }\n  };\n\n  /**\n   * Evaluate the value of the watcher.\n   * This only gets called for lazy watchers.\n   */\n  Watcher.prototype.evaluate = function evaluate() {\n    this.value = this.get();\n    this.dirty = false;\n  };\n\n  /**\n   * Depend on all deps collected by this watcher.\n   */\n  Watcher.prototype.depend = function depend() {\n    var this$1 = this;\n\n    var i = this.deps.length;\n    while (i--) {\n      this$1.deps[i].depend();\n    }\n  };\n\n  /**\n   * Remove self from all dependencies' subscriber list.\n   */\n  Watcher.prototype.teardown = function teardown() {\n    var this$1 = this;\n\n    if (this.active) {\n      // remove self from vm's watcher list\n      // this is a somewhat expensive operation so we skip it\n      // if the vm is being destroyed.\n      if (!this.vm._isBeingDestroyed) {\n        remove(this.vm._watchers, this);\n      }\n      var i = this.deps.length;\n      while (i--) {\n        this$1.deps[i].removeSub(this$1);\n      }\n      this.active = false;\n    }\n  };\n\n  /**\n   * Recursively traverse an object to evoke all converted\n   * getters, so that every nested property inside the object\n   * is collected as a \"deep\" dependency.\n   */\n  var seenObjects = new _Set();\n  function traverse(val) {\n    seenObjects.clear();\n    _traverse(val, seenObjects);\n  }\n\n  function _traverse(val, seen) {\n    var i, keys;\n    var isA = Array.isArray(val);\n    if (!isA && !isObject(val) || !Object.isExtensible(val)) {\n      return;\n    }\n    if (val.__ob__) {\n      var depId = val.__ob__.dep.id;\n      if (seen.has(depId)) {\n        return;\n      }\n      seen.add(depId);\n    }\n    if (isA) {\n      i = val.length;\n      while (i--) {\n        _traverse(val[i], seen);\n      }\n    } else {\n      keys = Object.keys(val);\n      i = keys.length;\n      while (i--) {\n        _traverse(val[keys[i]], seen);\n      }\n    }\n  }\n\n  /*  */\n\n  var sharedPropertyDefinition = {\n    enumerable: true,\n    configurable: true,\n    get: noop,\n    set: noop\n  };\n\n  function proxy(target, sourceKey, key) {\n    sharedPropertyDefinition.get = function proxyGetter() {\n      return this[sourceKey][key];\n    };\n    sharedPropertyDefinition.set = function proxySetter(val) {\n      this[sourceKey][key] = val;\n    };\n    Object.defineProperty(target, key, sharedPropertyDefinition);\n  }\n\n  function initState(vm) {\n    vm._watchers = [];\n    var opts = vm.$options;\n    if (opts.props) {\n      initProps(vm, opts.props);\n    }\n    if (opts.methods) {\n      initMethods(vm, opts.methods);\n    }\n    if (opts.data) {\n      initData(vm);\n    } else {\n      observe(vm._data = {}, true /* asRootData */);\n    }\n    if (opts.computed) {\n      initComputed(vm, opts.computed);\n    }\n    if (opts.watch && opts.watch !== nativeWatch) {\n      initWatch(vm, opts.watch);\n    }\n  }\n\n  function checkOptionType(vm, name) {\n    var option = vm.$options[name];\n    if (!isPlainObject(option)) {\n      warn(\"component option \\\"\" + name + \"\\\" should be an object.\", vm);\n    }\n  }\n\n  function initProps(vm, propsOptions) {\n    var propsData = vm.$options.propsData || {};\n    var props = vm._props = {};\n    // cache prop keys so that future props updates can iterate using Array\n    // instead of dynamic object key enumeration.\n    var keys = vm.$options._propKeys = [];\n    var isRoot = !vm.$parent;\n    // root instance props should be converted\n    observerState.shouldConvert = isRoot;\n    var loop = function loop(key) {\n      keys.push(key);\n      var value = validateProp(key, propsOptions, propsData, vm);\n      /* istanbul ignore else */\n      {\n        if (isReservedAttribute(key) || config.isReservedAttr(key)) {\n          warn(\"\\\"\" + key + \"\\\" is a reserved attribute and cannot be used as component prop.\", vm);\n        }\n        defineReactive$$1(props, key, value, function () {\n          if (vm.$parent && !isUpdatingChildComponent) {\n            warn(\"Avoid mutating a prop directly since the value will be \" + \"overwritten whenever the parent component re-renders. \" + \"Instead, use a data or computed property based on the prop's \" + \"value. Prop being mutated: \\\"\" + key + \"\\\"\", vm);\n          }\n        });\n      }\n      // static props are already proxied on the component's prototype\n      // during Vue.extend(). We only need to proxy props defined at\n      // instantiation here.\n      if (!(key in vm)) {\n        proxy(vm, \"_props\", key);\n      }\n    };\n\n    for (var key in propsOptions) {\n      loop(key);\n    }observerState.shouldConvert = true;\n  }\n\n  function initData(vm) {\n    var data = vm.$options.data;\n    data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};\n    if (!isPlainObject(data)) {\n      data = {};\n      \"development\" !== 'production' && warn('data functions should return an object:\\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);\n    }\n    // proxy data on instance\n    var keys = Object.keys(data);\n    var props = vm.$options.props;\n    var methods = vm.$options.methods;\n    var i = keys.length;\n    while (i--) {\n      var key = keys[i];\n      {\n        if (methods && hasOwn(methods, key)) {\n          warn(\"method \\\"\" + key + \"\\\" has already been defined as a data property.\", vm);\n        }\n      }\n      if (props && hasOwn(props, key)) {\n        \"development\" !== 'production' && warn(\"The data property \\\"\" + key + \"\\\" is already declared as a prop. \" + \"Use prop default value instead.\", vm);\n      } else if (!isReserved(key)) {\n        proxy(vm, \"_data\", key);\n      }\n    }\n    // observe data\n    observe(data, true /* asRootData */);\n  }\n\n  function getData(data, vm) {\n    try {\n      return data.call(vm);\n    } catch (e) {\n      handleError(e, vm, \"data()\");\n      return {};\n    }\n  }\n\n  var computedWatcherOptions = { lazy: true };\n\n  function initComputed(vm, computed) {\n    \"development\" !== 'production' && checkOptionType(vm, 'computed');\n    var watchers = vm._computedWatchers = Object.create(null);\n\n    for (var key in computed) {\n      var userDef = computed[key];\n      var getter = typeof userDef === 'function' ? userDef : userDef.get;\n      {\n        if (getter === undefined) {\n          warn(\"No getter function has been defined for computed property \\\"\" + key + \"\\\".\", vm);\n          getter = noop;\n        }\n      }\n      // create internal watcher for the computed property.\n      watchers[key] = new Watcher(vm, getter, noop, computedWatcherOptions);\n\n      // component-defined computed properties are already defined on the\n      // component prototype. We only need to define computed properties defined\n      // at instantiation here.\n      if (!(key in vm)) {\n        defineComputed(vm, key, userDef);\n      } else {\n        if (key in vm.$data) {\n          warn(\"The computed property \\\"\" + key + \"\\\" is already defined in data.\", vm);\n        } else if (vm.$options.props && key in vm.$options.props) {\n          warn(\"The computed property \\\"\" + key + \"\\\" is already defined as a prop.\", vm);\n        }\n      }\n    }\n  }\n\n  function defineComputed(target, key, userDef) {\n    if (typeof userDef === 'function') {\n      sharedPropertyDefinition.get = createComputedGetter(key);\n      sharedPropertyDefinition.set = noop;\n    } else {\n      sharedPropertyDefinition.get = userDef.get ? userDef.cache !== false ? createComputedGetter(key) : userDef.get : noop;\n      sharedPropertyDefinition.set = userDef.set ? userDef.set : noop;\n    }\n    Object.defineProperty(target, key, sharedPropertyDefinition);\n  }\n\n  function createComputedGetter(key) {\n    return function computedGetter() {\n      var watcher = this._computedWatchers && this._computedWatchers[key];\n      if (watcher) {\n        if (watcher.dirty) {\n          watcher.evaluate();\n        }\n        if (Dep.target) {\n          watcher.depend();\n        }\n        return watcher.value;\n      }\n    };\n  }\n\n  function initMethods(vm, methods) {\n    \"development\" !== 'production' && checkOptionType(vm, 'methods');\n    var props = vm.$options.props;\n    for (var key in methods) {\n      vm[key] = methods[key] == null ? noop : bind(methods[key], vm);\n      {\n        if (methods[key] == null) {\n          warn(\"method \\\"\" + key + \"\\\" has an undefined value in the component definition. \" + \"Did you reference the function correctly?\", vm);\n        }\n        if (props && hasOwn(props, key)) {\n          warn(\"method \\\"\" + key + \"\\\" has already been defined as a prop.\", vm);\n        }\n      }\n    }\n  }\n\n  function initWatch(vm, watch) {\n    \"development\" !== 'production' && checkOptionType(vm, 'watch');\n    for (var key in watch) {\n      var handler = watch[key];\n      if (Array.isArray(handler)) {\n        for (var i = 0; i < handler.length; i++) {\n          createWatcher(vm, key, handler[i]);\n        }\n      } else {\n        createWatcher(vm, key, handler);\n      }\n    }\n  }\n\n  function createWatcher(vm, keyOrFn, handler, options) {\n    if (isPlainObject(handler)) {\n      options = handler;\n      handler = handler.handler;\n    }\n    if (typeof handler === 'string') {\n      handler = vm[handler];\n    }\n    return vm.$watch(keyOrFn, handler, options);\n  }\n\n  function stateMixin(Vue) {\n    // flow somehow has problems with directly declared definition object\n    // when using Object.defineProperty, so we have to procedurally build up\n    // the object here.\n    var dataDef = {};\n    dataDef.get = function () {\n      return this._data;\n    };\n    var propsDef = {};\n    propsDef.get = function () {\n      return this._props;\n    };\n    {\n      dataDef.set = function (newData) {\n        warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);\n      };\n      propsDef.set = function () {\n        warn(\"$props is readonly.\", this);\n      };\n    }\n    Object.defineProperty(Vue.prototype, '$data', dataDef);\n    Object.defineProperty(Vue.prototype, '$props', propsDef);\n\n    Vue.prototype.$set = set;\n    Vue.prototype.$delete = del;\n\n    Vue.prototype.$watch = function (expOrFn, cb, options) {\n      var vm = this;\n      if (isPlainObject(cb)) {\n        return createWatcher(vm, expOrFn, cb, options);\n      }\n      options = options || {};\n      options.user = true;\n      var watcher = new Watcher(vm, expOrFn, cb, options);\n      if (options.immediate) {\n        cb.call(vm, watcher.value);\n      }\n      return function unwatchFn() {\n        watcher.teardown();\n      };\n    };\n  }\n\n  /*  */\n\n  function initProvide(vm) {\n    var provide = vm.$options.provide;\n    if (provide) {\n      vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;\n    }\n  }\n\n  function initInjections(vm) {\n    var result = resolveInject(vm.$options.inject, vm);\n    if (result) {\n      observerState.shouldConvert = false;\n      Object.keys(result).forEach(function (key) {\n        /* istanbul ignore else */\n        {\n          defineReactive$$1(vm, key, result[key], function () {\n            warn(\"Avoid mutating an injected value directly since the changes will be \" + \"overwritten whenever the provided component re-renders. \" + \"injection being mutated: \\\"\" + key + \"\\\"\", vm);\n          });\n        }\n      });\n      observerState.shouldConvert = true;\n    }\n  }\n\n  function resolveInject(inject, vm) {\n    if (inject) {\n      // inject is :any because flow is not smart enough to figure out cached\n      var result = Object.create(null);\n      var keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);\n\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        var provideKey = inject[key];\n        var source = vm;\n        while (source) {\n          if (source._provided && provideKey in source._provided) {\n            result[key] = source._provided[provideKey];\n            break;\n          }\n          source = source.$parent;\n        }\n        if (\"development\" !== 'production' && !hasOwn(result, key)) {\n          warn(\"Injection \\\"\" + key + \"\\\" not found\", vm);\n        }\n      }\n      return result;\n    }\n  }\n\n  /*  */\n\n  function createFunctionalComponent(Ctor, propsData, data, context, children) {\n    var props = {};\n    var propOptions = Ctor.options.props;\n    if (isDef(propOptions)) {\n      for (var key in propOptions) {\n        props[key] = validateProp(key, propOptions, propsData || {});\n      }\n    } else {\n      if (isDef(data.attrs)) {\n        mergeProps(props, data.attrs);\n      }\n      if (isDef(data.props)) {\n        mergeProps(props, data.props);\n      }\n    }\n    // ensure the createElement function in functional components\n    // gets a unique context - this is necessary for correct named slot check\n    var _context = Object.create(context);\n    var h = function h(a, b, c, d) {\n      return createElement(_context, a, b, c, d, true);\n    };\n    var vnode = Ctor.options.render.call(null, h, {\n      data: data,\n      props: props,\n      children: children,\n      parent: context,\n      listeners: data.on || {},\n      injections: resolveInject(Ctor.options.inject, context),\n      slots: function slots() {\n        return resolveSlots(children, context);\n      }\n    });\n    if (vnode instanceof VNode) {\n      vnode.functionalContext = context;\n      vnode.functionalOptions = Ctor.options;\n      if (data.slot) {\n        (vnode.data || (vnode.data = {})).slot = data.slot;\n      }\n    }\n    return vnode;\n  }\n\n  function mergeProps(to, from) {\n    for (var key in from) {\n      to[camelize(key)] = from[key];\n    }\n  }\n\n  /*  */\n\n  // hooks to be invoked on component VNodes during patch\n  var componentVNodeHooks = {\n    init: function init(vnode, hydrating, parentElm, refElm) {\n      if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {\n        var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance, parentElm, refElm);\n        child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n      } else if (vnode.data.keepAlive) {\n        // kept-alive components, treat as a patch\n        var mountedNode = vnode; // work around flow\n        componentVNodeHooks.prepatch(mountedNode, mountedNode);\n      }\n    },\n\n    prepatch: function prepatch(oldVnode, vnode) {\n      var options = vnode.componentOptions;\n      var child = vnode.componentInstance = oldVnode.componentInstance;\n      updateChildComponent(child, options.propsData, // updated props\n      options.listeners, // updated listeners\n      vnode, // new parent vnode\n      options.children // new children\n      );\n    },\n\n    insert: function insert(vnode) {\n      var context = vnode.context;\n      var componentInstance = vnode.componentInstance;\n      if (!componentInstance._isMounted) {\n        componentInstance._isMounted = true;\n        callHook(componentInstance, 'mounted');\n      }\n      if (vnode.data.keepAlive) {\n        if (context._isMounted) {\n          // vue-router#1212\n          // During updates, a kept-alive component's child components may\n          // change, so directly walking the tree here may call activated hooks\n          // on incorrect children. Instead we push them into a queue which will\n          // be processed after the whole patch process ended.\n          queueActivatedComponent(componentInstance);\n        } else {\n          activateChildComponent(componentInstance, true /* direct */);\n        }\n      }\n    },\n\n    destroy: function destroy(vnode) {\n      var componentInstance = vnode.componentInstance;\n      if (!componentInstance._isDestroyed) {\n        if (!vnode.data.keepAlive) {\n          componentInstance.$destroy();\n        } else {\n          deactivateChildComponent(componentInstance, true /* direct */);\n        }\n      }\n    }\n  };\n\n  var hooksToMerge = Object.keys(componentVNodeHooks);\n\n  function createComponent(Ctor, data, context, children, tag) {\n    if (isUndef(Ctor)) {\n      return;\n    }\n\n    var baseCtor = context.$options._base;\n\n    // plain options object: turn it into a constructor\n    if (isObject(Ctor)) {\n      Ctor = baseCtor.extend(Ctor);\n    }\n\n    // if at this stage it's not a constructor or an async component factory,\n    // reject.\n    if (typeof Ctor !== 'function') {\n      {\n        warn(\"Invalid Component definition: \" + String(Ctor), context);\n      }\n      return;\n    }\n\n    // async component\n    var asyncFactory;\n    if (isUndef(Ctor.cid)) {\n      asyncFactory = Ctor;\n      Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context);\n      if (Ctor === undefined) {\n        // return a placeholder node for async component, which is rendered\n        // as a comment node but preserves all the raw information for the node.\n        // the information will be used for async server-rendering and hydration.\n        return createAsyncPlaceholder(asyncFactory, data, context, children, tag);\n      }\n    }\n\n    data = data || {};\n\n    // resolve constructor options in case global mixins are applied after\n    // component constructor creation\n    resolveConstructorOptions(Ctor);\n\n    // transform component v-model data into props & events\n    if (isDef(data.model)) {\n      transformModel(Ctor.options, data);\n    }\n\n    // extract props\n    var propsData = extractPropsFromVNodeData(data, Ctor, tag);\n\n    // functional component\n    if (isTrue(Ctor.options.functional)) {\n      return createFunctionalComponent(Ctor, propsData, data, context, children);\n    }\n\n    // keep listeners\n    var listeners = data.on;\n\n    if (isTrue(Ctor.options.abstract)) {\n      // abstract components do not keep anything\n      // other than props & listeners & slot\n\n      // work around flow\n      var slot = data.slot;\n      data = {};\n      if (slot) {\n        data.slot = slot;\n      }\n    }\n\n    // merge component management hooks onto the placeholder node\n    mergeHooks(data);\n\n    // return a placeholder vnode\n    var name = Ctor.options.name || tag;\n    var vnode = new VNode(\"vue-component-\" + Ctor.cid + (name ? \"-\" + name : ''), data, undefined, undefined, undefined, context, { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }, asyncFactory);\n    return vnode;\n  }\n\n  function createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't\n  parent, // activeInstance in lifecycle state\n  parentElm, refElm) {\n    var vnodeComponentOptions = vnode.componentOptions;\n    var options = {\n      _isComponent: true,\n      parent: parent,\n      propsData: vnodeComponentOptions.propsData,\n      _componentTag: vnodeComponentOptions.tag,\n      _parentVnode: vnode,\n      _parentListeners: vnodeComponentOptions.listeners,\n      _renderChildren: vnodeComponentOptions.children,\n      _parentElm: parentElm || null,\n      _refElm: refElm || null\n    };\n    // check inline-template render functions\n    var inlineTemplate = vnode.data.inlineTemplate;\n    if (isDef(inlineTemplate)) {\n      options.render = inlineTemplate.render;\n      options.staticRenderFns = inlineTemplate.staticRenderFns;\n    }\n    return new vnodeComponentOptions.Ctor(options);\n  }\n\n  function mergeHooks(data) {\n    if (!data.hook) {\n      data.hook = {};\n    }\n    for (var i = 0; i < hooksToMerge.length; i++) {\n      var key = hooksToMerge[i];\n      var fromParent = data.hook[key];\n      var ours = componentVNodeHooks[key];\n      data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;\n    }\n  }\n\n  function mergeHook$1(one, two) {\n    return function (a, b, c, d) {\n      one(a, b, c, d);\n      two(a, b, c, d);\n    };\n  }\n\n  // transform component v-model info (value and callback) into\n  // prop and event handler respectively.\n  function transformModel(options, data) {\n    var prop = options.model && options.model.prop || 'value';\n    var event = options.model && options.model.event || 'input';(data.props || (data.props = {}))[prop] = data.model.value;\n    var on = data.on || (data.on = {});\n    if (isDef(on[event])) {\n      on[event] = [data.model.callback].concat(on[event]);\n    } else {\n      on[event] = data.model.callback;\n    }\n  }\n\n  /*  */\n\n  var SIMPLE_NORMALIZE = 1;\n  var ALWAYS_NORMALIZE = 2;\n\n  // wrapper function for providing a more flexible interface\n  // without getting yelled at by flow\n  function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {\n    if (Array.isArray(data) || isPrimitive(data)) {\n      normalizationType = children;\n      children = data;\n      data = undefined;\n    }\n    if (isTrue(alwaysNormalize)) {\n      normalizationType = ALWAYS_NORMALIZE;\n    }\n    return _createElement(context, tag, data, children, normalizationType);\n  }\n\n  function _createElement(context, tag, data, children, normalizationType) {\n    if (isDef(data) && isDef(data.__ob__)) {\n      \"development\" !== 'production' && warn(\"Avoid using observed data object as vnode data: \" + JSON.stringify(data) + \"\\n\" + 'Always create fresh vnode data objects in each render!', context);\n      return createEmptyVNode();\n    }\n    // object syntax in v-bind\n    if (isDef(data) && isDef(data.is)) {\n      tag = data.is;\n    }\n    if (!tag) {\n      // in case of component :is set to falsy value\n      return createEmptyVNode();\n    }\n    // warn against non-primitive key\n    if (\"development\" !== 'production' && isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {\n      warn('Avoid using non-primitive value as key, ' + 'use string/number value instead.', context);\n    }\n    // support single function children as default scoped slot\n    if (Array.isArray(children) && typeof children[0] === 'function') {\n      data = data || {};\n      data.scopedSlots = { default: children[0] };\n      children.length = 0;\n    }\n    if (normalizationType === ALWAYS_NORMALIZE) {\n      children = normalizeChildren(children);\n    } else if (normalizationType === SIMPLE_NORMALIZE) {\n      children = simpleNormalizeChildren(children);\n    }\n    var vnode, ns;\n    if (typeof tag === 'string') {\n      var Ctor;\n      ns = config.getTagNamespace(tag);\n      if (config.isReservedTag(tag)) {\n        // platform built-in elements\n        vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);\n      } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n        // component\n        vnode = createComponent(Ctor, data, context, children, tag);\n      } else {\n        // unknown or unlisted namespaced elements\n        // check at runtime because it may get assigned a namespace when its\n        // parent normalizes children\n        vnode = new VNode(tag, data, children, undefined, undefined, context);\n      }\n    } else {\n      // direct component options / constructor\n      vnode = createComponent(tag, data, context, children);\n    }\n    if (isDef(vnode)) {\n      if (ns) {\n        applyNS(vnode, ns);\n      }\n      return vnode;\n    } else {\n      return createEmptyVNode();\n    }\n  }\n\n  function applyNS(vnode, ns) {\n    vnode.ns = ns;\n    if (vnode.tag === 'foreignObject') {\n      // use default namespace inside foreignObject\n      return;\n    }\n    if (isDef(vnode.children)) {\n      for (var i = 0, l = vnode.children.length; i < l; i++) {\n        var child = vnode.children[i];\n        if (isDef(child.tag) && isUndef(child.ns)) {\n          applyNS(child, ns);\n        }\n      }\n    }\n  }\n\n  /*  */\n\n  /**\n   * Runtime helper for rendering v-for lists.\n   */\n  function renderList(val, render) {\n    var ret, i, l, keys, key;\n    if (Array.isArray(val) || typeof val === 'string') {\n      ret = new Array(val.length);\n      for (i = 0, l = val.length; i < l; i++) {\n        ret[i] = render(val[i], i);\n      }\n    } else if (typeof val === 'number') {\n      ret = new Array(val);\n      for (i = 0; i < val; i++) {\n        ret[i] = render(i + 1, i);\n      }\n    } else if (isObject(val)) {\n      keys = Object.keys(val);\n      ret = new Array(keys.length);\n      for (i = 0, l = keys.length; i < l; i++) {\n        key = keys[i];\n        ret[i] = render(val[key], key, i);\n      }\n    }\n    if (isDef(ret)) {\n      ret._isVList = true;\n    }\n    return ret;\n  }\n\n  /*  */\n\n  /**\n   * Runtime helper for rendering <slot>\n   */\n  function renderSlot(name, fallback, props, bindObject) {\n    var scopedSlotFn = this.$scopedSlots[name];\n    if (scopedSlotFn) {\n      // scoped slot\n      props = props || {};\n      if (bindObject) {\n        props = extend(extend({}, bindObject), props);\n      }\n      return scopedSlotFn(props) || fallback;\n    } else {\n      var slotNodes = this.$slots[name];\n      // warn duplicate slot usage\n      if (slotNodes && \"development\" !== 'production') {\n        slotNodes._rendered && warn(\"Duplicate presence of slot \\\"\" + name + \"\\\" found in the same render tree \" + \"- this will likely cause render errors.\", this);\n        slotNodes._rendered = true;\n      }\n      return slotNodes || fallback;\n    }\n  }\n\n  /*  */\n\n  /**\n   * Runtime helper for resolving filters\n   */\n  function resolveFilter(id) {\n    return resolveAsset(this.$options, 'filters', id, true) || identity;\n  }\n\n  /*  */\n\n  /**\n   * Runtime helper for checking keyCodes from config.\n   */\n  function checkKeyCodes(eventKeyCode, key, builtInAlias) {\n    var keyCodes = config.keyCodes[key] || builtInAlias;\n    if (Array.isArray(keyCodes)) {\n      return keyCodes.indexOf(eventKeyCode) === -1;\n    } else {\n      return keyCodes !== eventKeyCode;\n    }\n  }\n\n  /*  */\n\n  /**\n   * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n   */\n  function bindObjectProps(data, tag, value, asProp, isSync) {\n    if (value) {\n      if (!isObject(value)) {\n        \"development\" !== 'production' && warn('v-bind without argument expects an Object or Array value', this);\n      } else {\n        if (Array.isArray(value)) {\n          value = toObject(value);\n        }\n        var hash;\n        var loop = function loop(key) {\n          if (key === 'class' || key === 'style' || isReservedAttribute(key)) {\n            hash = data;\n          } else {\n            var type = data.attrs && data.attrs.type;\n            hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});\n          }\n          if (!(key in hash)) {\n            hash[key] = value[key];\n\n            if (isSync) {\n              var on = data.on || (data.on = {});\n              on[\"update:\" + key] = function ($event) {\n                value[key] = $event;\n              };\n            }\n          }\n        };\n\n        for (var key in value) {\n          loop(key);\n        }\n      }\n    }\n    return data;\n  }\n\n  /*  */\n\n  /**\n   * Runtime helper for rendering static trees.\n   */\n  function renderStatic(index, isInFor) {\n    var tree = this._staticTrees[index];\n    // if has already-rendered static tree and not inside v-for,\n    // we can reuse the same tree by doing a shallow clone.\n    if (tree && !isInFor) {\n      return Array.isArray(tree) ? cloneVNodes(tree) : cloneVNode(tree);\n    }\n    // otherwise, render a fresh tree.\n    tree = this._staticTrees[index] = this.$options.staticRenderFns[index].call(this._renderProxy);\n    markStatic(tree, \"__static__\" + index, false);\n    return tree;\n  }\n\n  /**\n   * Runtime helper for v-once.\n   * Effectively it means marking the node as static with a unique key.\n   */\n  function markOnce(tree, index, key) {\n    markStatic(tree, \"__once__\" + index + (key ? \"_\" + key : \"\"), true);\n    return tree;\n  }\n\n  function markStatic(tree, key, isOnce) {\n    if (Array.isArray(tree)) {\n      for (var i = 0; i < tree.length; i++) {\n        if (tree[i] && typeof tree[i] !== 'string') {\n          markStaticNode(tree[i], key + \"_\" + i, isOnce);\n        }\n      }\n    } else {\n      markStaticNode(tree, key, isOnce);\n    }\n  }\n\n  function markStaticNode(node, key, isOnce) {\n    node.isStatic = true;\n    node.key = key;\n    node.isOnce = isOnce;\n  }\n\n  /*  */\n\n  function bindObjectListeners(data, value) {\n    if (value) {\n      if (!isPlainObject(value)) {\n        \"development\" !== 'production' && warn('v-on without argument expects an Object value', this);\n      } else {\n        var on = data.on = data.on ? extend({}, data.on) : {};\n        for (var key in value) {\n          var existing = on[key];\n          var ours = value[key];\n          on[key] = existing ? [].concat(ours, existing) : ours;\n        }\n      }\n    }\n    return data;\n  }\n\n  /*  */\n\n  function initRender(vm) {\n    vm._vnode = null; // the root of the child tree\n    vm._staticTrees = null;\n    var parentVnode = vm.$vnode = vm.$options._parentVnode; // the placeholder node in parent tree\n    var renderContext = parentVnode && parentVnode.context;\n    vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);\n    vm.$scopedSlots = emptyObject;\n    // bind the createElement fn to this instance\n    // so that we get proper render context inside it.\n    // args order: tag, data, children, normalizationType, alwaysNormalize\n    // internal version is used by render functions compiled from templates\n    vm._c = function (a, b, c, d) {\n      return createElement(vm, a, b, c, d, false);\n    };\n    // normalization is always applied for the public version, used in\n    // user-written render functions.\n    vm.$createElement = function (a, b, c, d) {\n      return createElement(vm, a, b, c, d, true);\n    };\n\n    // $attrs & $listeners are exposed for easier HOC creation.\n    // they need to be reactive so that HOCs using them are always updated\n    var parentData = parentVnode && parentVnode.data;\n    /* istanbul ignore else */\n    {\n      defineReactive$$1(vm, '$attrs', parentData && parentData.attrs, function () {\n        !isUpdatingChildComponent && warn(\"$attrs is readonly.\", vm);\n      }, true);\n      defineReactive$$1(vm, '$listeners', parentData && parentData.on, function () {\n        !isUpdatingChildComponent && warn(\"$listeners is readonly.\", vm);\n      }, true);\n    }\n  }\n\n  function renderMixin(Vue) {\n    Vue.prototype.$nextTick = function (fn) {\n      return nextTick(fn, this);\n    };\n\n    Vue.prototype._render = function () {\n      var vm = this;\n      var ref = vm.$options;\n      var render = ref.render;\n      var staticRenderFns = ref.staticRenderFns;\n      var _parentVnode = ref._parentVnode;\n\n      if (vm._isMounted) {\n        // clone slot nodes on re-renders\n        for (var key in vm.$slots) {\n          vm.$slots[key] = cloneVNodes(vm.$slots[key]);\n        }\n      }\n\n      vm.$scopedSlots = _parentVnode && _parentVnode.data.scopedSlots || emptyObject;\n\n      if (staticRenderFns && !vm._staticTrees) {\n        vm._staticTrees = [];\n      }\n      // set parent vnode. this allows render functions to have access\n      // to the data on the placeholder node.\n      vm.$vnode = _parentVnode;\n      // render self\n      var vnode;\n      try {\n        vnode = render.call(vm._renderProxy, vm.$createElement);\n      } catch (e) {\n        handleError(e, vm, \"render function\");\n        // return error render result,\n        // or previous vnode to prevent render error causing blank component\n        /* istanbul ignore else */\n        {\n          vnode = vm.$options.renderError ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e) : vm._vnode;\n        }\n      }\n      // return empty vnode in case the render function errored out\n      if (!(vnode instanceof VNode)) {\n        if (\"development\" !== 'production' && Array.isArray(vnode)) {\n          warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);\n        }\n        vnode = createEmptyVNode();\n      }\n      // set parent\n      vnode.parent = _parentVnode;\n      return vnode;\n    };\n\n    // internal render helpers.\n    // these are exposed on the instance prototype to reduce generated render\n    // code size.\n    Vue.prototype._o = markOnce;\n    Vue.prototype._n = toNumber;\n    Vue.prototype._s = toString;\n    Vue.prototype._l = renderList;\n    Vue.prototype._t = renderSlot;\n    Vue.prototype._q = looseEqual;\n    Vue.prototype._i = looseIndexOf;\n    Vue.prototype._m = renderStatic;\n    Vue.prototype._f = resolveFilter;\n    Vue.prototype._k = checkKeyCodes;\n    Vue.prototype._b = bindObjectProps;\n    Vue.prototype._v = createTextVNode;\n    Vue.prototype._e = createEmptyVNode;\n    Vue.prototype._u = resolveScopedSlots;\n    Vue.prototype._g = bindObjectListeners;\n  }\n\n  /*  */\n\n  var uid$1 = 0;\n\n  function initMixin(Vue) {\n    Vue.prototype._init = function (options) {\n      var vm = this;\n      // a uid\n      vm._uid = uid$1++;\n\n      var startTag, endTag;\n      /* istanbul ignore if */\n      if (\"development\" !== 'production' && config.performance && mark) {\n        startTag = \"vue-perf-init:\" + vm._uid;\n        endTag = \"vue-perf-end:\" + vm._uid;\n        mark(startTag);\n      }\n\n      // a flag to avoid this being observed\n      vm._isVue = true;\n      // merge options\n      if (options && options._isComponent) {\n        // optimize internal component instantiation\n        // since dynamic options merging is pretty slow, and none of the\n        // internal component options needs special treatment.\n        initInternalComponent(vm, options);\n      } else {\n        vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);\n      }\n      /* istanbul ignore else */\n      {\n        initProxy(vm);\n      }\n      // expose real self\n      vm._self = vm;\n      initLifecycle(vm);\n      initEvents(vm);\n      initRender(vm);\n      callHook(vm, 'beforeCreate');\n      initInjections(vm); // resolve injections before data/props\n      initState(vm);\n      initProvide(vm); // resolve provide after data/props\n      callHook(vm, 'created');\n\n      /* istanbul ignore if */\n      if (\"development\" !== 'production' && config.performance && mark) {\n        vm._name = formatComponentName(vm, false);\n        mark(endTag);\n        measure(vm._name + \" init\", startTag, endTag);\n      }\n\n      if (vm.$options.el) {\n        vm.$mount(vm.$options.el);\n      }\n    };\n  }\n\n  function initInternalComponent(vm, options) {\n    var opts = vm.$options = Object.create(vm.constructor.options);\n    // doing this because it's faster than dynamic enumeration.\n    opts.parent = options.parent;\n    opts.propsData = options.propsData;\n    opts._parentVnode = options._parentVnode;\n    opts._parentListeners = options._parentListeners;\n    opts._renderChildren = options._renderChildren;\n    opts._componentTag = options._componentTag;\n    opts._parentElm = options._parentElm;\n    opts._refElm = options._refElm;\n    if (options.render) {\n      opts.render = options.render;\n      opts.staticRenderFns = options.staticRenderFns;\n    }\n  }\n\n  function resolveConstructorOptions(Ctor) {\n    var options = Ctor.options;\n    if (Ctor.super) {\n      var superOptions = resolveConstructorOptions(Ctor.super);\n      var cachedSuperOptions = Ctor.superOptions;\n      if (superOptions !== cachedSuperOptions) {\n        // super option changed,\n        // need to resolve new options.\n        Ctor.superOptions = superOptions;\n        // check if there are any late-modified/attached options (#4976)\n        var modifiedOptions = resolveModifiedOptions(Ctor);\n        // update base extend options\n        if (modifiedOptions) {\n          extend(Ctor.extendOptions, modifiedOptions);\n        }\n        options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n        if (options.name) {\n          options.components[options.name] = Ctor;\n        }\n      }\n    }\n    return options;\n  }\n\n  function resolveModifiedOptions(Ctor) {\n    var modified;\n    var latest = Ctor.options;\n    var extended = Ctor.extendOptions;\n    var sealed = Ctor.sealedOptions;\n    for (var key in latest) {\n      if (latest[key] !== sealed[key]) {\n        if (!modified) {\n          modified = {};\n        }\n        modified[key] = dedupe(latest[key], extended[key], sealed[key]);\n      }\n    }\n    return modified;\n  }\n\n  function dedupe(latest, extended, sealed) {\n    // compare latest and sealed to ensure lifecycle hooks won't be duplicated\n    // between merges\n    if (Array.isArray(latest)) {\n      var res = [];\n      sealed = Array.isArray(sealed) ? sealed : [sealed];\n      extended = Array.isArray(extended) ? extended : [extended];\n      for (var i = 0; i < latest.length; i++) {\n        // push original options and not sealed options to exclude duplicated options\n        if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {\n          res.push(latest[i]);\n        }\n      }\n      return res;\n    } else {\n      return latest;\n    }\n  }\n\n  function Vue$3(options) {\n    if (\"development\" !== 'production' && !(this instanceof Vue$3)) {\n      warn('Vue is a constructor and should be called with the `new` keyword');\n    }\n    this._init(options);\n  }\n\n  initMixin(Vue$3);\n  stateMixin(Vue$3);\n  eventsMixin(Vue$3);\n  lifecycleMixin(Vue$3);\n  renderMixin(Vue$3);\n\n  /*  */\n\n  function initUse(Vue) {\n    Vue.use = function (plugin) {\n      var installedPlugins = this._installedPlugins || (this._installedPlugins = []);\n      if (installedPlugins.indexOf(plugin) > -1) {\n        return this;\n      }\n\n      // additional parameters\n      var args = toArray(arguments, 1);\n      args.unshift(this);\n      if (typeof plugin.install === 'function') {\n        plugin.install.apply(plugin, args);\n      } else if (typeof plugin === 'function') {\n        plugin.apply(null, args);\n      }\n      installedPlugins.push(plugin);\n      return this;\n    };\n  }\n\n  /*  */\n\n  function initMixin$1(Vue) {\n    Vue.mixin = function (mixin) {\n      this.options = mergeOptions(this.options, mixin);\n      return this;\n    };\n  }\n\n  /*  */\n\n  function initExtend(Vue) {\n    /**\n     * Each instance constructor, including Vue, has a unique\n     * cid. This enables us to create wrapped \"child\n     * constructors\" for prototypal inheritance and cache them.\n     */\n    Vue.cid = 0;\n    var cid = 1;\n\n    /**\n     * Class inheritance\n     */\n    Vue.extend = function (extendOptions) {\n      extendOptions = extendOptions || {};\n      var Super = this;\n      var SuperId = Super.cid;\n      var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n      if (cachedCtors[SuperId]) {\n        return cachedCtors[SuperId];\n      }\n\n      var name = extendOptions.name || Super.options.name;\n      {\n        if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\n          warn('Invalid component name: \"' + name + '\". Component names ' + 'can only contain alphanumeric characters and the hyphen, ' + 'and must start with a letter.');\n        }\n      }\n\n      var Sub = function VueComponent(options) {\n        this._init(options);\n      };\n      Sub.prototype = Object.create(Super.prototype);\n      Sub.prototype.constructor = Sub;\n      Sub.cid = cid++;\n      Sub.options = mergeOptions(Super.options, extendOptions);\n      Sub['super'] = Super;\n\n      // For props and computed properties, we define the proxy getters on\n      // the Vue instances at extension time, on the extended prototype. This\n      // avoids Object.defineProperty calls for each instance created.\n      if (Sub.options.props) {\n        initProps$1(Sub);\n      }\n      if (Sub.options.computed) {\n        initComputed$1(Sub);\n      }\n\n      // allow further extension/mixin/plugin usage\n      Sub.extend = Super.extend;\n      Sub.mixin = Super.mixin;\n      Sub.use = Super.use;\n\n      // create asset registers, so extended classes\n      // can have their private assets too.\n      ASSET_TYPES.forEach(function (type) {\n        Sub[type] = Super[type];\n      });\n      // enable recursive self-lookup\n      if (name) {\n        Sub.options.components[name] = Sub;\n      }\n\n      // keep a reference to the super options at extension time.\n      // later at instantiation we can check if Super's options have\n      // been updated.\n      Sub.superOptions = Super.options;\n      Sub.extendOptions = extendOptions;\n      Sub.sealedOptions = extend({}, Sub.options);\n\n      // cache constructor\n      cachedCtors[SuperId] = Sub;\n      return Sub;\n    };\n  }\n\n  function initProps$1(Comp) {\n    var props = Comp.options.props;\n    for (var key in props) {\n      proxy(Comp.prototype, \"_props\", key);\n    }\n  }\n\n  function initComputed$1(Comp) {\n    var computed = Comp.options.computed;\n    for (var key in computed) {\n      defineComputed(Comp.prototype, key, computed[key]);\n    }\n  }\n\n  /*  */\n\n  function initAssetRegisters(Vue) {\n    /**\n     * Create asset registration methods.\n     */\n    ASSET_TYPES.forEach(function (type) {\n      Vue[type] = function (id, definition) {\n        if (!definition) {\n          return this.options[type + 's'][id];\n        } else {\n          /* istanbul ignore if */\n          {\n            if (type === 'component' && config.isReservedTag(id)) {\n              warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + id);\n            }\n          }\n          if (type === 'component' && isPlainObject(definition)) {\n            definition.name = definition.name || id;\n            definition = this.options._base.extend(definition);\n          }\n          if (type === 'directive' && typeof definition === 'function') {\n            definition = { bind: definition, update: definition };\n          }\n          this.options[type + 's'][id] = definition;\n          return definition;\n        }\n      };\n    });\n  }\n\n  /*  */\n\n  var patternTypes = [String, RegExp, Array];\n\n  function getComponentName(opts) {\n    return opts && (opts.Ctor.options.name || opts.tag);\n  }\n\n  function matches(pattern, name) {\n    if (Array.isArray(pattern)) {\n      return pattern.indexOf(name) > -1;\n    } else if (typeof pattern === 'string') {\n      return pattern.split(',').indexOf(name) > -1;\n    } else if (isRegExp(pattern)) {\n      return pattern.test(name);\n    }\n    /* istanbul ignore next */\n    return false;\n  }\n\n  function pruneCache(cache, current, filter) {\n    for (var key in cache) {\n      var cachedNode = cache[key];\n      if (cachedNode) {\n        var name = getComponentName(cachedNode.componentOptions);\n        if (name && !filter(name)) {\n          if (cachedNode !== current) {\n            pruneCacheEntry(cachedNode);\n          }\n          cache[key] = null;\n        }\n      }\n    }\n  }\n\n  function pruneCacheEntry(vnode) {\n    if (vnode) {\n      vnode.componentInstance.$destroy();\n    }\n  }\n\n  var KeepAlive = {\n    name: 'keep-alive',\n    abstract: true,\n\n    props: {\n      include: patternTypes,\n      exclude: patternTypes\n    },\n\n    created: function created() {\n      this.cache = Object.create(null);\n    },\n\n    destroyed: function destroyed() {\n      var this$1 = this;\n\n      for (var key in this$1.cache) {\n        pruneCacheEntry(this$1.cache[key]);\n      }\n    },\n\n    watch: {\n      include: function include(val) {\n        pruneCache(this.cache, this._vnode, function (name) {\n          return matches(val, name);\n        });\n      },\n      exclude: function exclude(val) {\n        pruneCache(this.cache, this._vnode, function (name) {\n          return !matches(val, name);\n        });\n      }\n    },\n\n    render: function render() {\n      var vnode = getFirstComponentChild(this.$slots.default);\n      var componentOptions = vnode && vnode.componentOptions;\n      if (componentOptions) {\n        // check pattern\n        var name = getComponentName(componentOptions);\n        if (name && (this.include && !matches(this.include, name) || this.exclude && matches(this.exclude, name))) {\n          return vnode;\n        }\n        var key = vnode.key == null\n        // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? \"::\" + componentOptions.tag : '') : vnode.key;\n        if (this.cache[key]) {\n          vnode.componentInstance = this.cache[key].componentInstance;\n        } else {\n          this.cache[key] = vnode;\n        }\n        vnode.data.keepAlive = true;\n      }\n      return vnode;\n    }\n  };\n\n  var builtInComponents = {\n    KeepAlive: KeepAlive\n  };\n\n  /*  */\n\n  function initGlobalAPI(Vue) {\n    // config\n    var configDef = {};\n    configDef.get = function () {\n      return config;\n    };\n    {\n      configDef.set = function () {\n        warn('Do not replace the Vue.config object, set individual fields instead.');\n      };\n    }\n    Object.defineProperty(Vue, 'config', configDef);\n\n    // exposed util methods.\n    // NOTE: these are not considered part of the public API - avoid relying on\n    // them unless you are aware of the risk.\n    Vue.util = {\n      warn: warn,\n      extend: extend,\n      mergeOptions: mergeOptions,\n      defineReactive: defineReactive$$1\n    };\n\n    Vue.set = set;\n    Vue.delete = del;\n    Vue.nextTick = nextTick;\n\n    Vue.options = Object.create(null);\n    ASSET_TYPES.forEach(function (type) {\n      Vue.options[type + 's'] = Object.create(null);\n    });\n\n    // this is used to identify the \"base\" constructor to extend all plain-object\n    // components with in Weex's multi-instance scenarios.\n    Vue.options._base = Vue;\n\n    extend(Vue.options.components, builtInComponents);\n\n    initUse(Vue);\n    initMixin$1(Vue);\n    initExtend(Vue);\n    initAssetRegisters(Vue);\n  }\n\n  initGlobalAPI(Vue$3);\n\n  Object.defineProperty(Vue$3.prototype, '$isServer', {\n    get: isServerRendering\n  });\n\n  Object.defineProperty(Vue$3.prototype, '$ssrContext', {\n    get: function get() {\n      /* istanbul ignore next */\n      return this.$vnode && this.$vnode.ssrContext;\n    }\n  });\n\n  Vue$3.version = '2.4.1';\n\n  /*  */\n\n  // these are reserved for web because they are directly compiled away\n  // during template compilation\n  var isReservedAttr = makeMap('style,class');\n\n  // attributes that should be using props for binding\n  var acceptValue = makeMap('input,textarea,option,select');\n  var mustUseProp = function mustUseProp(tag, type, attr) {\n    return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';\n  };\n\n  var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\n  var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');\n\n  var xlinkNS = 'http://www.w3.org/1999/xlink';\n\n  var isXlink = function isXlink(name) {\n    return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';\n  };\n\n  var getXlinkProp = function getXlinkProp(name) {\n    return isXlink(name) ? name.slice(6, name.length) : '';\n  };\n\n  var isFalsyAttrValue = function isFalsyAttrValue(val) {\n    return val == null || val === false;\n  };\n\n  /*  */\n\n  function genClassForVnode(vnode) {\n    var data = vnode.data;\n    var parentNode = vnode;\n    var childNode = vnode;\n    while (isDef(childNode.componentInstance)) {\n      childNode = childNode.componentInstance._vnode;\n      if (childNode.data) {\n        data = mergeClassData(childNode.data, data);\n      }\n    }\n    while (isDef(parentNode = parentNode.parent)) {\n      if (parentNode.data) {\n        data = mergeClassData(data, parentNode.data);\n      }\n    }\n    return renderClass(data.staticClass, data.class);\n  }\n\n  function mergeClassData(child, parent) {\n    return {\n      staticClass: concat(child.staticClass, parent.staticClass),\n      class: isDef(child.class) ? [child.class, parent.class] : parent.class\n    };\n  }\n\n  function renderClass(staticClass, dynamicClass) {\n    if (isDef(staticClass) || isDef(dynamicClass)) {\n      return concat(staticClass, stringifyClass(dynamicClass));\n    }\n    /* istanbul ignore next */\n    return '';\n  }\n\n  function concat(a, b) {\n    return a ? b ? a + ' ' + b : a : b || '';\n  }\n\n  function stringifyClass(value) {\n    if (Array.isArray(value)) {\n      return stringifyArray(value);\n    }\n    if (isObject(value)) {\n      return stringifyObject(value);\n    }\n    if (typeof value === 'string') {\n      return value;\n    }\n    /* istanbul ignore next */\n    return '';\n  }\n\n  function stringifyArray(value) {\n    var res = '';\n    var stringified;\n    for (var i = 0, l = value.length; i < l; i++) {\n      if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\n        if (res) {\n          res += ' ';\n        }\n        res += stringified;\n      }\n    }\n    return res;\n  }\n\n  function stringifyObject(value) {\n    var res = '';\n    for (var key in value) {\n      if (value[key]) {\n        if (res) {\n          res += ' ';\n        }\n        res += key;\n      }\n    }\n    return res;\n  }\n\n  /*  */\n\n  var namespaceMap = {\n    svg: 'http://www.w3.org/2000/svg',\n    math: 'http://www.w3.org/1998/Math/MathML'\n  };\n\n  var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot');\n\n  // this map is intentionally selective, only covering SVG elements that may\n  // contain child elements.\n  var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);\n\n  var isPreTag = function isPreTag(tag) {\n    return tag === 'pre';\n  };\n\n  var isReservedTag = function isReservedTag(tag) {\n    return isHTMLTag(tag) || isSVG(tag);\n  };\n\n  function getTagNamespace(tag) {\n    if (isSVG(tag)) {\n      return 'svg';\n    }\n    // basic support for MathML\n    // note it doesn't support other MathML elements being component roots\n    if (tag === 'math') {\n      return 'math';\n    }\n  }\n\n  var unknownElementCache = Object.create(null);\n  function isUnknownElement(tag) {\n    /* istanbul ignore if */\n    if (!inBrowser) {\n      return true;\n    }\n    if (isReservedTag(tag)) {\n      return false;\n    }\n    tag = tag.toLowerCase();\n    /* istanbul ignore if */\n    if (unknownElementCache[tag] != null) {\n      return unknownElementCache[tag];\n    }\n    var el = document.createElement(tag);\n    if (tag.indexOf('-') > -1) {\n      // http://stackoverflow.com/a/28210364/1070244\n      return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;\n    } else {\n      return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());\n    }\n  }\n\n  /*  */\n\n  /**\n   * Query an element selector if it's not an element already.\n   */\n  function query(el) {\n    if (typeof el === 'string') {\n      var selected = document.querySelector(el);\n      if (!selected) {\n        \"development\" !== 'production' && warn('Cannot find element: ' + el);\n        return document.createElement('div');\n      }\n      return selected;\n    } else {\n      return el;\n    }\n  }\n\n  /*  */\n\n  function createElement$1(tagName, vnode) {\n    var elm = document.createElement(tagName);\n    if (tagName !== 'select') {\n      return elm;\n    }\n    // false or null will remove the attribute but undefined will not\n    if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n      elm.setAttribute('multiple', 'multiple');\n    }\n    return elm;\n  }\n\n  function createElementNS(namespace, tagName) {\n    return document.createElementNS(namespaceMap[namespace], tagName);\n  }\n\n  function createTextNode(text) {\n    return document.createTextNode(text);\n  }\n\n  function createComment(text) {\n    return document.createComment(text);\n  }\n\n  function insertBefore(parentNode, newNode, referenceNode) {\n    parentNode.insertBefore(newNode, referenceNode);\n  }\n\n  function removeChild(node, child) {\n    node.removeChild(child);\n  }\n\n  function appendChild(node, child) {\n    node.appendChild(child);\n  }\n\n  function parentNode(node) {\n    return node.parentNode;\n  }\n\n  function nextSibling(node) {\n    return node.nextSibling;\n  }\n\n  function tagName(node) {\n    return node.tagName;\n  }\n\n  function setTextContent(node, text) {\n    node.textContent = text;\n  }\n\n  function setAttribute(node, key, val) {\n    node.setAttribute(key, val);\n  }\n\n  var nodeOps = Object.freeze({\n    createElement: createElement$1,\n    createElementNS: createElementNS,\n    createTextNode: createTextNode,\n    createComment: createComment,\n    insertBefore: insertBefore,\n    removeChild: removeChild,\n    appendChild: appendChild,\n    parentNode: parentNode,\n    nextSibling: nextSibling,\n    tagName: tagName,\n    setTextContent: setTextContent,\n    setAttribute: setAttribute\n  });\n\n  /*  */\n\n  var ref = {\n    create: function create(_, vnode) {\n      registerRef(vnode);\n    },\n    update: function update(oldVnode, vnode) {\n      if (oldVnode.data.ref !== vnode.data.ref) {\n        registerRef(oldVnode, true);\n        registerRef(vnode);\n      }\n    },\n    destroy: function destroy(vnode) {\n      registerRef(vnode, true);\n    }\n  };\n\n  function registerRef(vnode, isRemoval) {\n    var key = vnode.data.ref;\n    if (!key) {\n      return;\n    }\n\n    var vm = vnode.context;\n    var ref = vnode.componentInstance || vnode.elm;\n    var refs = vm.$refs;\n    if (isRemoval) {\n      if (Array.isArray(refs[key])) {\n        remove(refs[key], ref);\n      } else if (refs[key] === ref) {\n        refs[key] = undefined;\n      }\n    } else {\n      if (vnode.data.refInFor) {\n        if (!Array.isArray(refs[key])) {\n          refs[key] = [ref];\n        } else if (refs[key].indexOf(ref) < 0) {\n          // $flow-disable-line\n          refs[key].push(ref);\n        }\n      } else {\n        refs[key] = ref;\n      }\n    }\n  }\n\n  /**\n   * Virtual DOM patching algorithm based on Snabbdom by\n   * Simon Friis Vindum (@paldepind)\n   * Licensed under the MIT License\n   * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n   *\n   * modified by Evan You (@yyx990803)\n   *\n  \n  /*\n   * Not type-checking this because this file is perf-critical and the cost\n   * of making flow understand it is not worth it.\n   */\n\n  var emptyNode = new VNode('', {}, []);\n\n  var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\n  function sameVnode(a, b) {\n    return a.key === b.key && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && a.asyncFactory === b.asyncFactory && isUndef(b.asyncFactory.error));\n  }\n\n  // Some browsers do not support dynamically changing type for <input>\n  // so they need to be treated as different nodes\n  function sameInputType(a, b) {\n    if (a.tag !== 'input') {\n      return true;\n    }\n    var i;\n    var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n    var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n    return typeA === typeB;\n  }\n\n  function createKeyToOldIdx(children, beginIdx, endIdx) {\n    var i, key;\n    var map = {};\n    for (i = beginIdx; i <= endIdx; ++i) {\n      key = children[i].key;\n      if (isDef(key)) {\n        map[key] = i;\n      }\n    }\n    return map;\n  }\n\n  function createPatchFunction(backend) {\n    var i, j;\n    var cbs = {};\n\n    var modules = backend.modules;\n    var nodeOps = backend.nodeOps;\n\n    for (i = 0; i < hooks.length; ++i) {\n      cbs[hooks[i]] = [];\n      for (j = 0; j < modules.length; ++j) {\n        if (isDef(modules[j][hooks[i]])) {\n          cbs[hooks[i]].push(modules[j][hooks[i]]);\n        }\n      }\n    }\n\n    function emptyNodeAt(elm) {\n      return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);\n    }\n\n    function createRmCb(childElm, listeners) {\n      function remove$$1() {\n        if (--remove$$1.listeners === 0) {\n          removeNode(childElm);\n        }\n      }\n      remove$$1.listeners = listeners;\n      return remove$$1;\n    }\n\n    function removeNode(el) {\n      var parent = nodeOps.parentNode(el);\n      // element may have already been removed due to v-html / v-text\n      if (isDef(parent)) {\n        nodeOps.removeChild(parent, el);\n      }\n    }\n\n    var inPre = 0;\n    function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested) {\n      vnode.isRootInsert = !nested; // for transition enter check\n      if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n        return;\n      }\n\n      var data = vnode.data;\n      var children = vnode.children;\n      var tag = vnode.tag;\n      if (isDef(tag)) {\n        {\n          if (data && data.pre) {\n            inPre++;\n          }\n          if (!inPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) && config.isUnknownElement(tag)) {\n            warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the \"name\" option.', vnode.context);\n          }\n        }\n        vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);\n        setScope(vnode);\n\n        /* istanbul ignore if */\n        {\n          createChildren(vnode, children, insertedVnodeQueue);\n          if (isDef(data)) {\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n          }\n          insert(parentElm, vnode.elm, refElm);\n        }\n\n        if (\"development\" !== 'production' && data && data.pre) {\n          inPre--;\n        }\n      } else if (isTrue(vnode.isComment)) {\n        vnode.elm = nodeOps.createComment(vnode.text);\n        insert(parentElm, vnode.elm, refElm);\n      } else {\n        vnode.elm = nodeOps.createTextNode(vnode.text);\n        insert(parentElm, vnode.elm, refElm);\n      }\n    }\n\n    function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\n      var i = vnode.data;\n      if (isDef(i)) {\n        var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n        if (isDef(i = i.hook) && isDef(i = i.init)) {\n          i(vnode, false /* hydrating */, parentElm, refElm);\n        }\n        // after calling the init hook, if the vnode is a child component\n        // it should've created a child instance and mounted it. the child\n        // component also has set the placeholder vnode's elm.\n        // in that case we can just return the element and be done.\n        if (isDef(vnode.componentInstance)) {\n          initComponent(vnode, insertedVnodeQueue);\n          if (isTrue(isReactivated)) {\n            reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n          }\n          return true;\n        }\n      }\n    }\n\n    function initComponent(vnode, insertedVnodeQueue) {\n      if (isDef(vnode.data.pendingInsert)) {\n        insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n        vnode.data.pendingInsert = null;\n      }\n      vnode.elm = vnode.componentInstance.$el;\n      if (isPatchable(vnode)) {\n        invokeCreateHooks(vnode, insertedVnodeQueue);\n        setScope(vnode);\n      } else {\n        // empty component root.\n        // skip all element-related modules except for ref (#3455)\n        registerRef(vnode);\n        // make sure to invoke the insert hook\n        insertedVnodeQueue.push(vnode);\n      }\n    }\n\n    function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\n      var i;\n      // hack for #4339: a reactivated component with inner transition\n      // does not trigger because the inner node's created hooks are not called\n      // again. It's not ideal to involve module-specific logic in here but\n      // there doesn't seem to be a better way to do it.\n      var innerNode = vnode;\n      while (innerNode.componentInstance) {\n        innerNode = innerNode.componentInstance._vnode;\n        if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n          for (i = 0; i < cbs.activate.length; ++i) {\n            cbs.activate[i](emptyNode, innerNode);\n          }\n          insertedVnodeQueue.push(innerNode);\n          break;\n        }\n      }\n      // unlike a newly created component,\n      // a reactivated keep-alive component doesn't insert itself\n      insert(parentElm, vnode.elm, refElm);\n    }\n\n    function insert(parent, elm, ref$$1) {\n      if (isDef(parent)) {\n        if (isDef(ref$$1)) {\n          if (ref$$1.parentNode === parent) {\n            nodeOps.insertBefore(parent, elm, ref$$1);\n          }\n        } else {\n          nodeOps.appendChild(parent, elm);\n        }\n      }\n    }\n\n    function createChildren(vnode, children, insertedVnodeQueue) {\n      if (Array.isArray(children)) {\n        for (var i = 0; i < children.length; ++i) {\n          createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);\n        }\n      } else if (isPrimitive(vnode.text)) {\n        nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));\n      }\n    }\n\n    function isPatchable(vnode) {\n      while (vnode.componentInstance) {\n        vnode = vnode.componentInstance._vnode;\n      }\n      return isDef(vnode.tag);\n    }\n\n    function invokeCreateHooks(vnode, insertedVnodeQueue) {\n      for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n        cbs.create[i$1](emptyNode, vnode);\n      }\n      i = vnode.data.hook; // Reuse variable\n      if (isDef(i)) {\n        if (isDef(i.create)) {\n          i.create(emptyNode, vnode);\n        }\n        if (isDef(i.insert)) {\n          insertedVnodeQueue.push(vnode);\n        }\n      }\n    }\n\n    // set scope id attribute for scoped CSS.\n    // this is implemented as a special case to avoid the overhead\n    // of going through the normal attribute patching process.\n    function setScope(vnode) {\n      var i;\n      var ancestor = vnode;\n      while (ancestor) {\n        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n          nodeOps.setAttribute(vnode.elm, i, '');\n        }\n        ancestor = ancestor.parent;\n      }\n      // for slot content they should also get the scopeId from the host instance.\n      if (isDef(i = activeInstance) && i !== vnode.context && isDef(i = i.$options._scopeId)) {\n        nodeOps.setAttribute(vnode.elm, i, '');\n      }\n    }\n\n    function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n      for (; startIdx <= endIdx; ++startIdx) {\n        createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);\n      }\n    }\n\n    function invokeDestroyHook(vnode) {\n      var i, j;\n      var data = vnode.data;\n      if (isDef(data)) {\n        if (isDef(i = data.hook) && isDef(i = i.destroy)) {\n          i(vnode);\n        }\n        for (i = 0; i < cbs.destroy.length; ++i) {\n          cbs.destroy[i](vnode);\n        }\n      }\n      if (isDef(i = vnode.children)) {\n        for (j = 0; j < vnode.children.length; ++j) {\n          invokeDestroyHook(vnode.children[j]);\n        }\n      }\n    }\n\n    function removeVnodes(parentElm, vnodes, startIdx, endIdx) {\n      for (; startIdx <= endIdx; ++startIdx) {\n        var ch = vnodes[startIdx];\n        if (isDef(ch)) {\n          if (isDef(ch.tag)) {\n            removeAndInvokeRemoveHook(ch);\n            invokeDestroyHook(ch);\n          } else {\n            // Text node\n            removeNode(ch.elm);\n          }\n        }\n      }\n    }\n\n    function removeAndInvokeRemoveHook(vnode, rm) {\n      if (isDef(rm) || isDef(vnode.data)) {\n        var i;\n        var listeners = cbs.remove.length + 1;\n        if (isDef(rm)) {\n          // we have a recursively passed down rm callback\n          // increase the listeners count\n          rm.listeners += listeners;\n        } else {\n          // directly removing\n          rm = createRmCb(vnode.elm, listeners);\n        }\n        // recursively invoke hooks on child component root node\n        if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n          removeAndInvokeRemoveHook(i, rm);\n        }\n        for (i = 0; i < cbs.remove.length; ++i) {\n          cbs.remove[i](vnode, rm);\n        }\n        if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n          i(vnode, rm);\n        } else {\n          rm();\n        }\n      } else {\n        removeNode(vnode.elm);\n      }\n    }\n\n    function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n      var oldStartIdx = 0;\n      var newStartIdx = 0;\n      var oldEndIdx = oldCh.length - 1;\n      var oldStartVnode = oldCh[0];\n      var oldEndVnode = oldCh[oldEndIdx];\n      var newEndIdx = newCh.length - 1;\n      var newStartVnode = newCh[0];\n      var newEndVnode = newCh[newEndIdx];\n      var oldKeyToIdx, idxInOld, elmToMove, refElm;\n\n      // removeOnly is a special flag used only by <transition-group>\n      // to ensure removed elements stay in correct relative positions\n      // during leaving transitions\n      var canMove = !removeOnly;\n\n      while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n        if (isUndef(oldStartVnode)) {\n          oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n        } else if (isUndef(oldEndVnode)) {\n          oldEndVnode = oldCh[--oldEndIdx];\n        } else if (sameVnode(oldStartVnode, newStartVnode)) {\n          patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n          oldStartVnode = oldCh[++oldStartIdx];\n          newStartVnode = newCh[++newStartIdx];\n        } else if (sameVnode(oldEndVnode, newEndVnode)) {\n          patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n          oldEndVnode = oldCh[--oldEndIdx];\n          newEndVnode = newCh[--newEndIdx];\n        } else if (sameVnode(oldStartVnode, newEndVnode)) {\n          // Vnode moved right\n          patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n          canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n          oldStartVnode = oldCh[++oldStartIdx];\n          newEndVnode = newCh[--newEndIdx];\n        } else if (sameVnode(oldEndVnode, newStartVnode)) {\n          // Vnode moved left\n          patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n          canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n          oldEndVnode = oldCh[--oldEndIdx];\n          newStartVnode = newCh[++newStartIdx];\n        } else {\n          if (isUndef(oldKeyToIdx)) {\n            oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n          }\n          idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;\n          if (isUndef(idxInOld)) {\n            // New element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          } else {\n            elmToMove = oldCh[idxInOld];\n            /* istanbul ignore if */\n            if (\"development\" !== 'production' && !elmToMove) {\n              warn('It seems there are duplicate keys that is causing an update error. ' + 'Make sure each v-for item has a unique key.');\n            }\n            if (sameVnode(elmToMove, newStartVnode)) {\n              patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n              oldCh[idxInOld] = undefined;\n              canMove && nodeOps.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);\n              newStartVnode = newCh[++newStartIdx];\n            } else {\n              // same key but different element. treat as new element\n              createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n              newStartVnode = newCh[++newStartIdx];\n            }\n          }\n        }\n      }\n      if (oldStartIdx > oldEndIdx) {\n        refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n        addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n      } else if (newStartIdx > newEndIdx) {\n        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n      }\n    }\n\n    function patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n      if (oldVnode === vnode) {\n        return;\n      }\n\n      var elm = vnode.elm = oldVnode.elm;\n\n      if (isTrue(oldVnode.isAsyncPlaceholder)) {\n        if (isDef(vnode.asyncFactory.resolved)) {\n          hydrate(oldVnode.elm, vnode, insertedVnodeQueue);\n        } else {\n          vnode.isAsyncPlaceholder = true;\n        }\n        return;\n      }\n\n      // reuse element for static trees.\n      // note we only do this if the vnode is cloned -\n      // if the new node is not cloned it means the render functions have been\n      // reset by the hot-reload-api and we need to do a proper re-render.\n      if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {\n        vnode.componentInstance = oldVnode.componentInstance;\n        return;\n      }\n\n      var i;\n      var data = vnode.data;\n      if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n        i(oldVnode, vnode);\n      }\n\n      var oldCh = oldVnode.children;\n      var ch = vnode.children;\n      if (isDef(data) && isPatchable(vnode)) {\n        for (i = 0; i < cbs.update.length; ++i) {\n          cbs.update[i](oldVnode, vnode);\n        }\n        if (isDef(i = data.hook) && isDef(i = i.update)) {\n          i(oldVnode, vnode);\n        }\n      }\n      if (isUndef(vnode.text)) {\n        if (isDef(oldCh) && isDef(ch)) {\n          if (oldCh !== ch) {\n            updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);\n          }\n        } else if (isDef(ch)) {\n          if (isDef(oldVnode.text)) {\n            nodeOps.setTextContent(elm, '');\n          }\n          addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n        } else if (isDef(oldCh)) {\n          removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n        } else if (isDef(oldVnode.text)) {\n          nodeOps.setTextContent(elm, '');\n        }\n      } else if (oldVnode.text !== vnode.text) {\n        nodeOps.setTextContent(elm, vnode.text);\n      }\n      if (isDef(data)) {\n        if (isDef(i = data.hook) && isDef(i = i.postpatch)) {\n          i(oldVnode, vnode);\n        }\n      }\n    }\n\n    function invokeInsertHook(vnode, queue, initial) {\n      // delay insert hooks for component root nodes, invoke them after the\n      // element is really inserted\n      if (isTrue(initial) && isDef(vnode.parent)) {\n        vnode.parent.data.pendingInsert = queue;\n      } else {\n        for (var i = 0; i < queue.length; ++i) {\n          queue[i].data.hook.insert(queue[i]);\n        }\n      }\n    }\n\n    var bailed = false;\n    // list of modules that can skip create hook during hydration because they\n    // are already rendered on the client or has no need for initialization\n    var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');\n\n    // Note: this is a browser-only function so we can assume elms are DOM nodes.\n    function hydrate(elm, vnode, insertedVnodeQueue) {\n      if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {\n        vnode.elm = elm;\n        vnode.isAsyncPlaceholder = true;\n        return true;\n      }\n      {\n        if (!assertNodeMatch(elm, vnode)) {\n          return false;\n        }\n      }\n      vnode.elm = elm;\n      var tag = vnode.tag;\n      var data = vnode.data;\n      var children = vnode.children;\n      if (isDef(data)) {\n        if (isDef(i = data.hook) && isDef(i = i.init)) {\n          i(vnode, true /* hydrating */);\n        }\n        if (isDef(i = vnode.componentInstance)) {\n          // child component. it should have hydrated its own tree.\n          initComponent(vnode, insertedVnodeQueue);\n          return true;\n        }\n      }\n      if (isDef(tag)) {\n        if (isDef(children)) {\n          // empty element, allow client to pick up and populate children\n          if (!elm.hasChildNodes()) {\n            createChildren(vnode, children, insertedVnodeQueue);\n          } else {\n            var childrenMatch = true;\n            var childNode = elm.firstChild;\n            for (var i$1 = 0; i$1 < children.length; i$1++) {\n              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {\n                childrenMatch = false;\n                break;\n              }\n              childNode = childNode.nextSibling;\n            }\n            // if childNode is not null, it means the actual childNodes list is\n            // longer than the virtual children list.\n            if (!childrenMatch || childNode) {\n              if (\"development\" !== 'production' && typeof console !== 'undefined' && !bailed) {\n                bailed = true;\n                console.warn('Parent: ', elm);\n                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n              }\n              return false;\n            }\n          }\n        }\n        if (isDef(data)) {\n          for (var key in data) {\n            if (!isRenderedModule(key)) {\n              invokeCreateHooks(vnode, insertedVnodeQueue);\n              break;\n            }\n          }\n        }\n      } else if (elm.data !== vnode.text) {\n        elm.data = vnode.text;\n      }\n      return true;\n    }\n\n    function assertNodeMatch(node, vnode) {\n      if (isDef(vnode.tag)) {\n        return vnode.tag.indexOf('vue-component') === 0 || vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());\n      } else {\n        return node.nodeType === (vnode.isComment ? 8 : 3);\n      }\n    }\n\n    return function patch(oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {\n      if (isUndef(vnode)) {\n        if (isDef(oldVnode)) {\n          invokeDestroyHook(oldVnode);\n        }\n        return;\n      }\n\n      var isInitialPatch = false;\n      var insertedVnodeQueue = [];\n\n      if (isUndef(oldVnode)) {\n        // empty mount (likely as component), create new root element\n        isInitialPatch = true;\n        createElm(vnode, insertedVnodeQueue, parentElm, refElm);\n      } else {\n        var isRealElement = isDef(oldVnode.nodeType);\n        if (!isRealElement && sameVnode(oldVnode, vnode)) {\n          // patch existing root node\n          patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);\n        } else {\n          if (isRealElement) {\n            // mounting to a real element\n            // check if this is server-rendered content and if we can perform\n            // a successful hydration.\n            if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n              oldVnode.removeAttribute(SSR_ATTR);\n              hydrating = true;\n            }\n            if (isTrue(hydrating)) {\n              if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n                invokeInsertHook(vnode, insertedVnodeQueue, true);\n                return oldVnode;\n              } else {\n                warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');\n              }\n            }\n            // either not server-rendered, or hydration failed.\n            // create an empty node and replace it\n            oldVnode = emptyNodeAt(oldVnode);\n          }\n          // replacing existing element\n          var oldElm = oldVnode.elm;\n          var parentElm$1 = nodeOps.parentNode(oldElm);\n          createElm(vnode, insertedVnodeQueue,\n          // extremely rare edge case: do not insert if old element is in a\n          // leaving transition. Only happens when combining transition +\n          // keep-alive + HOCs. (#4590)\n          oldElm._leaveCb ? null : parentElm$1, nodeOps.nextSibling(oldElm));\n\n          if (isDef(vnode.parent)) {\n            // component root element replaced.\n            // update parent placeholder node element, recursively\n            var ancestor = vnode.parent;\n            while (ancestor) {\n              ancestor.elm = vnode.elm;\n              ancestor = ancestor.parent;\n            }\n            if (isPatchable(vnode)) {\n              for (var i = 0; i < cbs.create.length; ++i) {\n                cbs.create[i](emptyNode, vnode.parent);\n              }\n            }\n          }\n\n          if (isDef(parentElm$1)) {\n            removeVnodes(parentElm$1, [oldVnode], 0, 0);\n          } else if (isDef(oldVnode.tag)) {\n            invokeDestroyHook(oldVnode);\n          }\n        }\n      }\n\n      invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n      return vnode.elm;\n    };\n  }\n\n  /*  */\n\n  var directives = {\n    create: updateDirectives,\n    update: updateDirectives,\n    destroy: function unbindDirectives(vnode) {\n      updateDirectives(vnode, emptyNode);\n    }\n  };\n\n  function updateDirectives(oldVnode, vnode) {\n    if (oldVnode.data.directives || vnode.data.directives) {\n      _update(oldVnode, vnode);\n    }\n  }\n\n  function _update(oldVnode, vnode) {\n    var isCreate = oldVnode === emptyNode;\n    var isDestroy = vnode === emptyNode;\n    var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n    var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n    var dirsWithInsert = [];\n    var dirsWithPostpatch = [];\n\n    var key, oldDir, dir;\n    for (key in newDirs) {\n      oldDir = oldDirs[key];\n      dir = newDirs[key];\n      if (!oldDir) {\n        // new directive, bind\n        callHook$1(dir, 'bind', vnode, oldVnode);\n        if (dir.def && dir.def.inserted) {\n          dirsWithInsert.push(dir);\n        }\n      } else {\n        // existing directive, update\n        dir.oldValue = oldDir.value;\n        callHook$1(dir, 'update', vnode, oldVnode);\n        if (dir.def && dir.def.componentUpdated) {\n          dirsWithPostpatch.push(dir);\n        }\n      }\n    }\n\n    if (dirsWithInsert.length) {\n      var callInsert = function callInsert() {\n        for (var i = 0; i < dirsWithInsert.length; i++) {\n          callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n        }\n      };\n      if (isCreate) {\n        mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert);\n      } else {\n        callInsert();\n      }\n    }\n\n    if (dirsWithPostpatch.length) {\n      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {\n        for (var i = 0; i < dirsWithPostpatch.length; i++) {\n          callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n        }\n      });\n    }\n\n    if (!isCreate) {\n      for (key in oldDirs) {\n        if (!newDirs[key]) {\n          // no longer present, unbind\n          callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n        }\n      }\n    }\n  }\n\n  var emptyModifiers = Object.create(null);\n\n  function normalizeDirectives$1(dirs, vm) {\n    var res = Object.create(null);\n    if (!dirs) {\n      return res;\n    }\n    var i, dir;\n    for (i = 0; i < dirs.length; i++) {\n      dir = dirs[i];\n      if (!dir.modifiers) {\n        dir.modifiers = emptyModifiers;\n      }\n      res[getRawDirName(dir)] = dir;\n      dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n    }\n    return res;\n  }\n\n  function getRawDirName(dir) {\n    return dir.rawName || dir.name + \".\" + Object.keys(dir.modifiers || {}).join('.');\n  }\n\n  function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {\n    var fn = dir.def && dir.def[hook];\n    if (fn) {\n      try {\n        fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n      } catch (e) {\n        handleError(e, vnode.context, \"directive \" + dir.name + \" \" + hook + \" hook\");\n      }\n    }\n  }\n\n  var baseModules = [ref, directives];\n\n  /*  */\n\n  function updateAttrs(oldVnode, vnode) {\n    var opts = vnode.componentOptions;\n    if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {\n      return;\n    }\n    if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n      return;\n    }\n    var key, cur, old;\n    var elm = vnode.elm;\n    var oldAttrs = oldVnode.data.attrs || {};\n    var attrs = vnode.data.attrs || {};\n    // clone observed objects, as the user probably wants to mutate it\n    if (isDef(attrs.__ob__)) {\n      attrs = vnode.data.attrs = extend({}, attrs);\n    }\n\n    for (key in attrs) {\n      cur = attrs[key];\n      old = oldAttrs[key];\n      if (old !== cur) {\n        setAttr(elm, key, cur);\n      }\n    }\n    // #4391: in IE9, setting type can reset value for input[type=radio]\n    /* istanbul ignore if */\n    if (isIE9 && attrs.value !== oldAttrs.value) {\n      setAttr(elm, 'value', attrs.value);\n    }\n    for (key in oldAttrs) {\n      if (isUndef(attrs[key])) {\n        if (isXlink(key)) {\n          elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n        } else if (!isEnumeratedAttr(key)) {\n          elm.removeAttribute(key);\n        }\n      }\n    }\n  }\n\n  function setAttr(el, key, value) {\n    if (isBooleanAttr(key)) {\n      // set attribute for blank value\n      // e.g. <option disabled>Select one</option>\n      if (isFalsyAttrValue(value)) {\n        el.removeAttribute(key);\n      } else {\n        el.setAttribute(key, key);\n      }\n    } else if (isEnumeratedAttr(key)) {\n      el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');\n    } else if (isXlink(key)) {\n      if (isFalsyAttrValue(value)) {\n        el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else {\n        el.setAttributeNS(xlinkNS, key, value);\n      }\n    } else {\n      if (isFalsyAttrValue(value)) {\n        el.removeAttribute(key);\n      } else {\n        el.setAttribute(key, value);\n      }\n    }\n  }\n\n  var attrs = {\n    create: updateAttrs,\n    update: updateAttrs\n  };\n\n  /*  */\n\n  function updateClass(oldVnode, vnode) {\n    var el = vnode.elm;\n    var data = vnode.data;\n    var oldData = oldVnode.data;\n    if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {\n      return;\n    }\n\n    var cls = genClassForVnode(vnode);\n\n    // handle transition classes\n    var transitionClass = el._transitionClasses;\n    if (isDef(transitionClass)) {\n      cls = concat(cls, stringifyClass(transitionClass));\n    }\n\n    // set the class\n    if (cls !== el._prevClass) {\n      el.setAttribute('class', cls);\n      el._prevClass = cls;\n    }\n  }\n\n  var klass = {\n    create: updateClass,\n    update: updateClass\n  };\n\n  /*  */\n\n  var validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\n  function parseFilters(exp) {\n    var inSingle = false;\n    var inDouble = false;\n    var inTemplateString = false;\n    var inRegex = false;\n    var curly = 0;\n    var square = 0;\n    var paren = 0;\n    var lastFilterIndex = 0;\n    var c, prev, i, expression, filters;\n\n    for (i = 0; i < exp.length; i++) {\n      prev = c;\n      c = exp.charCodeAt(i);\n      if (inSingle) {\n        if (c === 0x27 && prev !== 0x5C) {\n          inSingle = false;\n        }\n      } else if (inDouble) {\n        if (c === 0x22 && prev !== 0x5C) {\n          inDouble = false;\n        }\n      } else if (inTemplateString) {\n        if (c === 0x60 && prev !== 0x5C) {\n          inTemplateString = false;\n        }\n      } else if (inRegex) {\n        if (c === 0x2f && prev !== 0x5C) {\n          inRegex = false;\n        }\n      } else if (c === 0x7C && // pipe\n      exp.charCodeAt(i + 1) !== 0x7C && exp.charCodeAt(i - 1) !== 0x7C && !curly && !square && !paren) {\n        if (expression === undefined) {\n          // first filter, end of expression\n          lastFilterIndex = i + 1;\n          expression = exp.slice(0, i).trim();\n        } else {\n          pushFilter();\n        }\n      } else {\n        switch (c) {\n          case 0x22:\n            inDouble = true;break; // \"\n          case 0x27:\n            inSingle = true;break; // '\n          case 0x60:\n            inTemplateString = true;break; // `\n          case 0x28:\n            paren++;break; // (\n          case 0x29:\n            paren--;break; // )\n          case 0x5B:\n            square++;break; // [\n          case 0x5D:\n            square--;break; // ]\n          case 0x7B:\n            curly++;break; // {\n          case 0x7D:\n            curly--;break; // }\n        }\n        if (c === 0x2f) {\n          // /\n          var j = i - 1;\n          var p = void 0;\n          // find first non-whitespace prev char\n          for (; j >= 0; j--) {\n            p = exp.charAt(j);\n            if (p !== ' ') {\n              break;\n            }\n          }\n          if (!p || !validDivisionCharRE.test(p)) {\n            inRegex = true;\n          }\n        }\n      }\n    }\n\n    if (expression === undefined) {\n      expression = exp.slice(0, i).trim();\n    } else if (lastFilterIndex !== 0) {\n      pushFilter();\n    }\n\n    function pushFilter() {\n      (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n      lastFilterIndex = i + 1;\n    }\n\n    if (filters) {\n      for (i = 0; i < filters.length; i++) {\n        expression = wrapFilter(expression, filters[i]);\n      }\n    }\n\n    return expression;\n  }\n\n  function wrapFilter(exp, filter) {\n    var i = filter.indexOf('(');\n    if (i < 0) {\n      // _f: resolveFilter\n      return \"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\";\n    } else {\n      var name = filter.slice(0, i);\n      var args = filter.slice(i + 1);\n      return \"_f(\\\"\" + name + \"\\\")(\" + exp + \",\" + args;\n    }\n  }\n\n  /*  */\n\n  function baseWarn(msg) {\n    console.error(\"[Vue compiler]: \" + msg);\n  }\n\n  function pluckModuleFunction(modules, key) {\n    return modules ? modules.map(function (m) {\n      return m[key];\n    }).filter(function (_) {\n      return _;\n    }) : [];\n  }\n\n  function addProp(el, name, value) {\n    (el.props || (el.props = [])).push({ name: name, value: value });\n  }\n\n  function addAttr(el, name, value) {\n    (el.attrs || (el.attrs = [])).push({ name: name, value: value });\n  }\n\n  function addDirective(el, name, rawName, value, arg, modifiers) {\n    (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });\n  }\n\n  function addHandler(el, name, value, modifiers, important, warn) {\n    // warn prevent and passive modifier\n    /* istanbul ignore if */\n    if (\"development\" !== 'production' && warn && modifiers && modifiers.prevent && modifiers.passive) {\n      warn('passive and prevent can\\'t be used together. ' + 'Passive handler can\\'t prevent default event.');\n    }\n    // check capture modifier\n    if (modifiers && modifiers.capture) {\n      delete modifiers.capture;\n      name = '!' + name; // mark the event as captured\n    }\n    if (modifiers && modifiers.once) {\n      delete modifiers.once;\n      name = '~' + name; // mark the event as once\n    }\n    /* istanbul ignore if */\n    if (modifiers && modifiers.passive) {\n      delete modifiers.passive;\n      name = '&' + name; // mark the event as passive\n    }\n    var events;\n    if (modifiers && modifiers.native) {\n      delete modifiers.native;\n      events = el.nativeEvents || (el.nativeEvents = {});\n    } else {\n      events = el.events || (el.events = {});\n    }\n    var newHandler = { value: value, modifiers: modifiers };\n    var handlers = events[name];\n    /* istanbul ignore if */\n    if (Array.isArray(handlers)) {\n      important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n    } else if (handlers) {\n      events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n    } else {\n      events[name] = newHandler;\n    }\n  }\n\n  function getBindingAttr(el, name, getStatic) {\n    var dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);\n    if (dynamicValue != null) {\n      return parseFilters(dynamicValue);\n    } else if (getStatic !== false) {\n      var staticValue = getAndRemoveAttr(el, name);\n      if (staticValue != null) {\n        return JSON.stringify(staticValue);\n      }\n    }\n  }\n\n  function getAndRemoveAttr(el, name) {\n    var val;\n    if ((val = el.attrsMap[name]) != null) {\n      var list = el.attrsList;\n      for (var i = 0, l = list.length; i < l; i++) {\n        if (list[i].name === name) {\n          list.splice(i, 1);\n          break;\n        }\n      }\n    }\n    return val;\n  }\n\n  /*  */\n\n  /**\n   * Cross-platform code generation for component v-model\n   */\n  function genComponentModel(el, value, modifiers) {\n    var ref = modifiers || {};\n    var number = ref.number;\n    var trim = ref.trim;\n\n    var baseValueExpression = '$$v';\n    var valueExpression = baseValueExpression;\n    if (trim) {\n      valueExpression = \"(typeof \" + baseValueExpression + \" === 'string'\" + \"? \" + baseValueExpression + \".trim()\" + \": \" + baseValueExpression + \")\";\n    }\n    if (number) {\n      valueExpression = \"_n(\" + valueExpression + \")\";\n    }\n    var assignment = genAssignmentCode(value, valueExpression);\n\n    el.model = {\n      value: \"(\" + value + \")\",\n      expression: \"\\\"\" + value + \"\\\"\",\n      callback: \"function (\" + baseValueExpression + \") {\" + assignment + \"}\"\n    };\n  }\n\n  /**\n   * Cross-platform codegen helper for generating v-model value assignment code.\n   */\n  function genAssignmentCode(value, assignment) {\n    var modelRs = parseModel(value);\n    if (modelRs.idx === null) {\n      return value + \"=\" + assignment;\n    } else {\n      return \"$set(\" + modelRs.exp + \", \" + modelRs.idx + \", \" + assignment + \")\";\n    }\n  }\n\n  /**\n   * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)\n   *\n   * for loop possible cases:\n   *\n   * - test\n   * - test[idx]\n   * - test[test1[idx]]\n   * - test[\"a\"][idx]\n   * - xxx.test[a[a].test1[idx]]\n   * - test.xxx.a[\"asa\"][test1[idx]]\n   *\n   */\n\n  var len;\n  var str;\n  var chr;\n  var index$1;\n  var expressionPos;\n  var expressionEndPos;\n\n  function parseModel(val) {\n    str = val;\n    len = str.length;\n    index$1 = expressionPos = expressionEndPos = 0;\n\n    if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n      return {\n        exp: val,\n        idx: null\n      };\n    }\n\n    while (!eof()) {\n      chr = next();\n      /* istanbul ignore if */\n      if (isStringStart(chr)) {\n        parseString(chr);\n      } else if (chr === 0x5B) {\n        parseBracket(chr);\n      }\n    }\n\n    return {\n      exp: val.substring(0, expressionPos),\n      idx: val.substring(expressionPos + 1, expressionEndPos)\n    };\n  }\n\n  function next() {\n    return str.charCodeAt(++index$1);\n  }\n\n  function eof() {\n    return index$1 >= len;\n  }\n\n  function isStringStart(chr) {\n    return chr === 0x22 || chr === 0x27;\n  }\n\n  function parseBracket(chr) {\n    var inBracket = 1;\n    expressionPos = index$1;\n    while (!eof()) {\n      chr = next();\n      if (isStringStart(chr)) {\n        parseString(chr);\n        continue;\n      }\n      if (chr === 0x5B) {\n        inBracket++;\n      }\n      if (chr === 0x5D) {\n        inBracket--;\n      }\n      if (inBracket === 0) {\n        expressionEndPos = index$1;\n        break;\n      }\n    }\n  }\n\n  function parseString(chr) {\n    var stringQuote = chr;\n    while (!eof()) {\n      chr = next();\n      if (chr === stringQuote) {\n        break;\n      }\n    }\n  }\n\n  /*  */\n\n  var warn$1;\n\n  // in some cases, the event used has to be determined at runtime\n  // so we used some reserved tokens during compile.\n  var RANGE_TOKEN = '__r';\n  var CHECKBOX_RADIO_TOKEN = '__c';\n\n  function model(el, dir, _warn) {\n    warn$1 = _warn;\n    var value = dir.value;\n    var modifiers = dir.modifiers;\n    var tag = el.tag;\n    var type = el.attrsMap.type;\n\n    {\n      var dynamicType = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n      if (tag === 'input' && dynamicType) {\n        warn$1(\"<input :type=\\\"\" + dynamicType + \"\\\" v-model=\\\"\" + value + \"\\\">:\\n\" + \"v-model does not support dynamic input types. Use v-if branches instead.\");\n      }\n      // inputs with type=\"file\" are read only and setting the input's\n      // value will throw an error.\n      if (tag === 'input' && type === 'file') {\n        warn$1(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" + \"File inputs are read only. Use a v-on:change listener instead.\");\n      }\n    }\n\n    if (el.component) {\n      genComponentModel(el, value, modifiers);\n      // component v-model doesn't need extra runtime\n      return false;\n    } else if (tag === 'select') {\n      genSelect(el, value, modifiers);\n    } else if (tag === 'input' && type === 'checkbox') {\n      genCheckboxModel(el, value, modifiers);\n    } else if (tag === 'input' && type === 'radio') {\n      genRadioModel(el, value, modifiers);\n    } else if (tag === 'input' || tag === 'textarea') {\n      genDefaultModel(el, value, modifiers);\n    } else if (!config.isReservedTag(tag)) {\n      genComponentModel(el, value, modifiers);\n      // component v-model doesn't need extra runtime\n      return false;\n    } else {\n      warn$1(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\">: \" + \"v-model is not supported on this element type. \" + 'If you are working with contenteditable, it\\'s recommended to ' + 'wrap a library dedicated for that purpose inside a custom component.');\n    }\n\n    // ensure runtime directive metadata\n    return true;\n  }\n\n  function genCheckboxModel(el, value, modifiers) {\n    var number = modifiers && modifiers.number;\n    var valueBinding = getBindingAttr(el, 'value') || 'null';\n    var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n    var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n    addProp(el, 'checked', \"Array.isArray(\" + value + \")\" + \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (trueValueBinding === 'true' ? \":(\" + value + \")\" : \":_q(\" + value + \",\" + trueValueBinding + \")\"));\n    addHandler(el, CHECKBOX_RADIO_TOKEN, \"var $$a=\" + value + \",\" + '$$el=$event.target,' + \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" + 'if(Array.isArray($$a)){' + \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" + '$$i=_i($$a,$$v);' + \"if($$c){$$i<0&&(\" + value + \"=$$a.concat($$v))}\" + \"else{$$i>-1&&(\" + value + \"=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}\" + \"}else{\" + genAssignmentCode(value, '$$c') + \"}\", null, true);\n  }\n\n  function genRadioModel(el, value, modifiers) {\n    var number = modifiers && modifiers.number;\n    var valueBinding = getBindingAttr(el, 'value') || 'null';\n    valueBinding = number ? \"_n(\" + valueBinding + \")\" : valueBinding;\n    addProp(el, 'checked', \"_q(\" + value + \",\" + valueBinding + \")\");\n    addHandler(el, CHECKBOX_RADIO_TOKEN, genAssignmentCode(value, valueBinding), null, true);\n  }\n\n  function genSelect(el, value, modifiers) {\n    var number = modifiers && modifiers.number;\n    var selectedVal = \"Array.prototype.filter\" + \".call($event.target.options,function(o){return o.selected})\" + \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" + \"return \" + (number ? '_n(val)' : 'val') + \"})\";\n\n    var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\n    var code = \"var $$selectedVal = \" + selectedVal + \";\";\n    code = code + \" \" + genAssignmentCode(value, assignment);\n    addHandler(el, 'change', code, null, true);\n  }\n\n  function genDefaultModel(el, value, modifiers) {\n    var type = el.attrsMap.type;\n    var ref = modifiers || {};\n    var lazy = ref.lazy;\n    var number = ref.number;\n    var trim = ref.trim;\n    var needCompositionGuard = !lazy && type !== 'range';\n    var event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';\n\n    var valueExpression = '$event.target.value';\n    if (trim) {\n      valueExpression = \"$event.target.value.trim()\";\n    }\n    if (number) {\n      valueExpression = \"_n(\" + valueExpression + \")\";\n    }\n\n    var code = genAssignmentCode(value, valueExpression);\n    if (needCompositionGuard) {\n      code = \"if($event.target.composing)return;\" + code;\n    }\n\n    addProp(el, 'value', \"(\" + value + \")\");\n    addHandler(el, event, code, null, true);\n    if (trim || number) {\n      addHandler(el, 'blur', '$forceUpdate()');\n    }\n  }\n\n  /*  */\n\n  // normalize v-model event tokens that can only be determined at runtime.\n  // it's important to place the event as the first in the array because\n  // the whole point is ensuring the v-model callback gets called before\n  // user-attached handlers.\n  function normalizeEvents(on) {\n    var event;\n    /* istanbul ignore if */\n    if (isDef(on[RANGE_TOKEN])) {\n      // IE input[type=range] only supports `change` event\n      event = isIE ? 'change' : 'input';\n      on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n      delete on[RANGE_TOKEN];\n    }\n    if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n      // Chrome fires microtasks in between click/change, leads to #4521\n      event = isChrome ? 'click' : 'change';\n      on[event] = [].concat(on[CHECKBOX_RADIO_TOKEN], on[event] || []);\n      delete on[CHECKBOX_RADIO_TOKEN];\n    }\n  }\n\n  var target$1;\n\n  function add$1(event, _handler, once$$1, capture, passive) {\n    if (once$$1) {\n      var oldHandler = _handler;\n      var _target = target$1; // save current target element in closure\n      _handler = function handler(ev) {\n        var res = arguments.length === 1 ? oldHandler(ev) : oldHandler.apply(null, arguments);\n        if (res !== null) {\n          remove$2(event, _handler, capture, _target);\n        }\n      };\n    }\n    target$1.addEventListener(event, _handler, supportsPassive ? { capture: capture, passive: passive } : capture);\n  }\n\n  function remove$2(event, handler, capture, _target) {\n    (_target || target$1).removeEventListener(event, handler, capture);\n  }\n\n  function updateDOMListeners(oldVnode, vnode) {\n    var isComponentRoot = isDef(vnode.componentOptions);\n    var oldOn = isComponentRoot ? oldVnode.data.nativeOn : oldVnode.data.on;\n    var on = isComponentRoot ? vnode.data.nativeOn : vnode.data.on;\n    if (isUndef(oldOn) && isUndef(on)) {\n      return;\n    }\n    on = on || {};\n    oldOn = oldOn || {};\n    target$1 = vnode.elm;\n    normalizeEvents(on);\n    updateListeners(on, oldOn, add$1, remove$2, vnode.context);\n  }\n\n  var events = {\n    create: updateDOMListeners,\n    update: updateDOMListeners\n  };\n\n  /*  */\n\n  function updateDOMProps(oldVnode, vnode) {\n    if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n      return;\n    }\n    var key, cur;\n    var elm = vnode.elm;\n    var oldProps = oldVnode.data.domProps || {};\n    var props = vnode.data.domProps || {};\n    // clone observed objects, as the user probably wants to mutate it\n    if (isDef(props.__ob__)) {\n      props = vnode.data.domProps = extend({}, props);\n    }\n\n    for (key in oldProps) {\n      if (isUndef(props[key])) {\n        elm[key] = '';\n      }\n    }\n    for (key in props) {\n      cur = props[key];\n      // ignore children if the node has textContent or innerHTML,\n      // as these will throw away existing DOM nodes and cause removal errors\n      // on subsequent patches (#3360)\n      if (key === 'textContent' || key === 'innerHTML') {\n        if (vnode.children) {\n          vnode.children.length = 0;\n        }\n        if (cur === oldProps[key]) {\n          continue;\n        }\n      }\n\n      if (key === 'value') {\n        // store value as _value as well since\n        // non-string values will be stringified\n        elm._value = cur;\n        // avoid resetting cursor position when value is the same\n        var strCur = isUndef(cur) ? '' : String(cur);\n        if (shouldUpdateValue(elm, vnode, strCur)) {\n          elm.value = strCur;\n        }\n      } else {\n        elm[key] = cur;\n      }\n    }\n  }\n\n  // check platforms/web/util/attrs.js acceptValue\n\n\n  function shouldUpdateValue(elm, vnode, checkVal) {\n    return !elm.composing && (vnode.tag === 'option' || isDirty(elm, checkVal) || isInputChanged(elm, checkVal));\n  }\n\n  function isDirty(elm, checkVal) {\n    // return true when textbox (.number and .trim) loses focus and its value is\n    // not equal to the updated value\n    return document.activeElement !== elm && elm.value !== checkVal;\n  }\n\n  function isInputChanged(elm, newVal) {\n    var value = elm.value;\n    var modifiers = elm._vModifiers; // injected by v-model runtime\n    if (isDef(modifiers) && modifiers.number) {\n      return toNumber(value) !== toNumber(newVal);\n    }\n    if (isDef(modifiers) && modifiers.trim) {\n      return value.trim() !== newVal.trim();\n    }\n    return value !== newVal;\n  }\n\n  var domProps = {\n    create: updateDOMProps,\n    update: updateDOMProps\n  };\n\n  /*  */\n\n  var parseStyleText = cached(function (cssText) {\n    var res = {};\n    var listDelimiter = /;(?![^(]*\\))/g;\n    var propertyDelimiter = /:(.+)/;\n    cssText.split(listDelimiter).forEach(function (item) {\n      if (item) {\n        var tmp = item.split(propertyDelimiter);\n        tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n      }\n    });\n    return res;\n  });\n\n  // merge static and dynamic style data on the same vnode\n  function normalizeStyleData(data) {\n    var style = normalizeStyleBinding(data.style);\n    // static style is pre-processed into an object during compilation\n    // and is always a fresh object, so it's safe to merge into it\n    return data.staticStyle ? extend(data.staticStyle, style) : style;\n  }\n\n  // normalize possible array / string values into Object\n  function normalizeStyleBinding(bindingStyle) {\n    if (Array.isArray(bindingStyle)) {\n      return toObject(bindingStyle);\n    }\n    if (typeof bindingStyle === 'string') {\n      return parseStyleText(bindingStyle);\n    }\n    return bindingStyle;\n  }\n\n  /**\n   * parent component style should be after child's\n   * so that parent component's style could override it\n   */\n  function getStyle(vnode, checkChild) {\n    var res = {};\n    var styleData;\n\n    if (checkChild) {\n      var childNode = vnode;\n      while (childNode.componentInstance) {\n        childNode = childNode.componentInstance._vnode;\n        if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {\n          extend(res, styleData);\n        }\n      }\n    }\n\n    if (styleData = normalizeStyleData(vnode.data)) {\n      extend(res, styleData);\n    }\n\n    var parentNode = vnode;\n    while (parentNode = parentNode.parent) {\n      if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n        extend(res, styleData);\n      }\n    }\n    return res;\n  }\n\n  /*  */\n\n  var cssVarRE = /^--/;\n  var importantRE = /\\s*!important$/;\n  var setProp = function setProp(el, name, val) {\n    /* istanbul ignore if */\n    if (cssVarRE.test(name)) {\n      el.style.setProperty(name, val);\n    } else if (importantRE.test(val)) {\n      el.style.setProperty(name, val.replace(importantRE, ''), 'important');\n    } else {\n      var normalizedName = normalize(name);\n      if (Array.isArray(val)) {\n        // Support values array created by autoprefixer, e.g.\n        // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n        // Set them one by one, and the browser will only set those it can recognize\n        for (var i = 0, len = val.length; i < len; i++) {\n          el.style[normalizedName] = val[i];\n        }\n      } else {\n        el.style[normalizedName] = val;\n      }\n    }\n  };\n\n  var vendorNames = ['Webkit', 'Moz', 'ms'];\n\n  var emptyStyle;\n  var normalize = cached(function (prop) {\n    emptyStyle = emptyStyle || document.createElement('div').style;\n    prop = camelize(prop);\n    if (prop !== 'filter' && prop in emptyStyle) {\n      return prop;\n    }\n    var capName = prop.charAt(0).toUpperCase() + prop.slice(1);\n    for (var i = 0; i < vendorNames.length; i++) {\n      var name = vendorNames[i] + capName;\n      if (name in emptyStyle) {\n        return name;\n      }\n    }\n  });\n\n  function updateStyle(oldVnode, vnode) {\n    var data = vnode.data;\n    var oldData = oldVnode.data;\n\n    if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {\n      return;\n    }\n\n    var cur, name;\n    var el = vnode.elm;\n    var oldStaticStyle = oldData.staticStyle;\n    var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};\n\n    // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n    var oldStyle = oldStaticStyle || oldStyleBinding;\n\n    var style = normalizeStyleBinding(vnode.data.style) || {};\n\n    // store normalized style under a different key for next diff\n    // make sure to clone it if it's reactive, since the user likley wants\n    // to mutate it.\n    vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;\n\n    var newStyle = getStyle(vnode, true);\n\n    for (name in oldStyle) {\n      if (isUndef(newStyle[name])) {\n        setProp(el, name, '');\n      }\n    }\n    for (name in newStyle) {\n      cur = newStyle[name];\n      if (cur !== oldStyle[name]) {\n        // ie9 setting to null has no effect, must use empty string\n        setProp(el, name, cur == null ? '' : cur);\n      }\n    }\n  }\n\n  var style = {\n    create: updateStyle,\n    update: updateStyle\n  };\n\n  /*  */\n\n  /**\n   * Add class with compatibility for SVG since classList is not supported on\n   * SVG elements in IE\n   */\n  function addClass(el, cls) {\n    /* istanbul ignore if */\n    if (!cls || !(cls = cls.trim())) {\n      return;\n    }\n\n    /* istanbul ignore else */\n    if (el.classList) {\n      if (cls.indexOf(' ') > -1) {\n        cls.split(/\\s+/).forEach(function (c) {\n          return el.classList.add(c);\n        });\n      } else {\n        el.classList.add(cls);\n      }\n    } else {\n      var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n      if (cur.indexOf(' ' + cls + ' ') < 0) {\n        el.setAttribute('class', (cur + cls).trim());\n      }\n    }\n  }\n\n  /**\n   * Remove class with compatibility for SVG since classList is not supported on\n   * SVG elements in IE\n   */\n  function removeClass(el, cls) {\n    /* istanbul ignore if */\n    if (!cls || !(cls = cls.trim())) {\n      return;\n    }\n\n    /* istanbul ignore else */\n    if (el.classList) {\n      if (cls.indexOf(' ') > -1) {\n        cls.split(/\\s+/).forEach(function (c) {\n          return el.classList.remove(c);\n        });\n      } else {\n        el.classList.remove(cls);\n      }\n      if (!el.classList.length) {\n        el.removeAttribute('class');\n      }\n    } else {\n      var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n      var tar = ' ' + cls + ' ';\n      while (cur.indexOf(tar) >= 0) {\n        cur = cur.replace(tar, ' ');\n      }\n      cur = cur.trim();\n      if (cur) {\n        el.setAttribute('class', cur);\n      } else {\n        el.removeAttribute('class');\n      }\n    }\n  }\n\n  /*  */\n\n  function resolveTransition(def$$1) {\n    if (!def$$1) {\n      return;\n    }\n    /* istanbul ignore else */\n    if ((typeof def$$1 === 'undefined' ? 'undefined' : _typeof(def$$1)) === 'object') {\n      var res = {};\n      if (def$$1.css !== false) {\n        extend(res, autoCssTransition(def$$1.name || 'v'));\n      }\n      extend(res, def$$1);\n      return res;\n    } else if (typeof def$$1 === 'string') {\n      return autoCssTransition(def$$1);\n    }\n  }\n\n  var autoCssTransition = cached(function (name) {\n    return {\n      enterClass: name + \"-enter\",\n      enterToClass: name + \"-enter-to\",\n      enterActiveClass: name + \"-enter-active\",\n      leaveClass: name + \"-leave\",\n      leaveToClass: name + \"-leave-to\",\n      leaveActiveClass: name + \"-leave-active\"\n    };\n  });\n\n  var hasTransition = inBrowser && !isIE9;\n  var TRANSITION = 'transition';\n  var ANIMATION = 'animation';\n\n  // Transition property/event sniffing\n  var transitionProp = 'transition';\n  var transitionEndEvent = 'transitionend';\n  var animationProp = 'animation';\n  var animationEndEvent = 'animationend';\n  if (hasTransition) {\n    /* istanbul ignore if */\n    if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {\n      transitionProp = 'WebkitTransition';\n      transitionEndEvent = 'webkitTransitionEnd';\n    }\n    if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {\n      animationProp = 'WebkitAnimation';\n      animationEndEvent = 'webkitAnimationEnd';\n    }\n  }\n\n  // binding to window is necessary to make hot reload work in IE in strict mode\n  var raf = inBrowser && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout;\n\n  function nextFrame(fn) {\n    raf(function () {\n      raf(fn);\n    });\n  }\n\n  function addTransitionClass(el, cls) {\n    var transitionClasses = el._transitionClasses || (el._transitionClasses = []);\n    if (transitionClasses.indexOf(cls) < 0) {\n      transitionClasses.push(cls);\n      addClass(el, cls);\n    }\n  }\n\n  function removeTransitionClass(el, cls) {\n    if (el._transitionClasses) {\n      remove(el._transitionClasses, cls);\n    }\n    removeClass(el, cls);\n  }\n\n  function whenTransitionEnds(el, expectedType, cb) {\n    var ref = getTransitionInfo(el, expectedType);\n    var type = ref.type;\n    var timeout = ref.timeout;\n    var propCount = ref.propCount;\n    if (!type) {\n      return cb();\n    }\n    var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n    var ended = 0;\n    var end = function end() {\n      el.removeEventListener(event, onEnd);\n      cb();\n    };\n    var onEnd = function onEnd(e) {\n      if (e.target === el) {\n        if (++ended >= propCount) {\n          end();\n        }\n      }\n    };\n    setTimeout(function () {\n      if (ended < propCount) {\n        end();\n      }\n    }, timeout + 1);\n    el.addEventListener(event, onEnd);\n  }\n\n  var transformRE = /\\b(transform|all)(,|$)/;\n\n  function getTransitionInfo(el, expectedType) {\n    var styles = window.getComputedStyle(el);\n    var transitionDelays = styles[transitionProp + 'Delay'].split(', ');\n    var transitionDurations = styles[transitionProp + 'Duration'].split(', ');\n    var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n    var animationDelays = styles[animationProp + 'Delay'].split(', ');\n    var animationDurations = styles[animationProp + 'Duration'].split(', ');\n    var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n    var type;\n    var timeout = 0;\n    var propCount = 0;\n    /* istanbul ignore if */\n    if (expectedType === TRANSITION) {\n      if (transitionTimeout > 0) {\n        type = TRANSITION;\n        timeout = transitionTimeout;\n        propCount = transitionDurations.length;\n      }\n    } else if (expectedType === ANIMATION) {\n      if (animationTimeout > 0) {\n        type = ANIMATION;\n        timeout = animationTimeout;\n        propCount = animationDurations.length;\n      }\n    } else {\n      timeout = Math.max(transitionTimeout, animationTimeout);\n      type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;\n      propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;\n    }\n    var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);\n    return {\n      type: type,\n      timeout: timeout,\n      propCount: propCount,\n      hasTransform: hasTransform\n    };\n  }\n\n  function getTimeout(delays, durations) {\n    /* istanbul ignore next */\n    while (delays.length < durations.length) {\n      delays = delays.concat(delays);\n    }\n\n    return Math.max.apply(null, durations.map(function (d, i) {\n      return toMs(d) + toMs(delays[i]);\n    }));\n  }\n\n  function toMs(s) {\n    return Number(s.slice(0, -1)) * 1000;\n  }\n\n  /*  */\n\n  function enter(vnode, toggleDisplay) {\n    var el = vnode.elm;\n\n    // call leave callback now\n    if (isDef(el._leaveCb)) {\n      el._leaveCb.cancelled = true;\n      el._leaveCb();\n    }\n\n    var data = resolveTransition(vnode.data.transition);\n    if (isUndef(data)) {\n      return;\n    }\n\n    /* istanbul ignore if */\n    if (isDef(el._enterCb) || el.nodeType !== 1) {\n      return;\n    }\n\n    var css = data.css;\n    var type = data.type;\n    var enterClass = data.enterClass;\n    var enterToClass = data.enterToClass;\n    var enterActiveClass = data.enterActiveClass;\n    var appearClass = data.appearClass;\n    var appearToClass = data.appearToClass;\n    var appearActiveClass = data.appearActiveClass;\n    var beforeEnter = data.beforeEnter;\n    var enter = data.enter;\n    var afterEnter = data.afterEnter;\n    var enterCancelled = data.enterCancelled;\n    var beforeAppear = data.beforeAppear;\n    var appear = data.appear;\n    var afterAppear = data.afterAppear;\n    var appearCancelled = data.appearCancelled;\n    var duration = data.duration;\n\n    // activeInstance will always be the <transition> component managing this\n    // transition. One edge case to check is when the <transition> is placed\n    // as the root node of a child component. In that case we need to check\n    // <transition>'s parent for appear check.\n    var context = activeInstance;\n    var transitionNode = activeInstance.$vnode;\n    while (transitionNode && transitionNode.parent) {\n      transitionNode = transitionNode.parent;\n      context = transitionNode.context;\n    }\n\n    var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n    if (isAppear && !appear && appear !== '') {\n      return;\n    }\n\n    var startClass = isAppear && appearClass ? appearClass : enterClass;\n    var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;\n    var toClass = isAppear && appearToClass ? appearToClass : enterToClass;\n\n    var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;\n    var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;\n    var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;\n    var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;\n\n    var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);\n\n    if (\"development\" !== 'production' && explicitEnterDuration != null) {\n      checkDuration(explicitEnterDuration, 'enter', vnode);\n    }\n\n    var expectsCSS = css !== false && !isIE9;\n    var userWantsControl = getHookArgumentsLength(enterHook);\n\n    var cb = el._enterCb = once(function () {\n      if (expectsCSS) {\n        removeTransitionClass(el, toClass);\n        removeTransitionClass(el, activeClass);\n      }\n      if (cb.cancelled) {\n        if (expectsCSS) {\n          removeTransitionClass(el, startClass);\n        }\n        enterCancelledHook && enterCancelledHook(el);\n      } else {\n        afterEnterHook && afterEnterHook(el);\n      }\n      el._enterCb = null;\n    });\n\n    if (!vnode.data.show) {\n      // remove pending leave element on enter by injecting an insert hook\n      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {\n        var parent = el.parentNode;\n        var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n        if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {\n          pendingNode.elm._leaveCb();\n        }\n        enterHook && enterHook(el, cb);\n      });\n    }\n\n    // start enter transition\n    beforeEnterHook && beforeEnterHook(el);\n    if (expectsCSS) {\n      addTransitionClass(el, startClass);\n      addTransitionClass(el, activeClass);\n      nextFrame(function () {\n        addTransitionClass(el, toClass);\n        removeTransitionClass(el, startClass);\n        if (!cb.cancelled && !userWantsControl) {\n          if (isValidDuration(explicitEnterDuration)) {\n            setTimeout(cb, explicitEnterDuration);\n          } else {\n            whenTransitionEnds(el, type, cb);\n          }\n        }\n      });\n    }\n\n    if (vnode.data.show) {\n      toggleDisplay && toggleDisplay();\n      enterHook && enterHook(el, cb);\n    }\n\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n\n  function leave(vnode, rm) {\n    var el = vnode.elm;\n\n    // call enter callback now\n    if (isDef(el._enterCb)) {\n      el._enterCb.cancelled = true;\n      el._enterCb();\n    }\n\n    var data = resolveTransition(vnode.data.transition);\n    if (isUndef(data)) {\n      return rm();\n    }\n\n    /* istanbul ignore if */\n    if (isDef(el._leaveCb) || el.nodeType !== 1) {\n      return;\n    }\n\n    var css = data.css;\n    var type = data.type;\n    var leaveClass = data.leaveClass;\n    var leaveToClass = data.leaveToClass;\n    var leaveActiveClass = data.leaveActiveClass;\n    var beforeLeave = data.beforeLeave;\n    var leave = data.leave;\n    var afterLeave = data.afterLeave;\n    var leaveCancelled = data.leaveCancelled;\n    var delayLeave = data.delayLeave;\n    var duration = data.duration;\n\n    var expectsCSS = css !== false && !isIE9;\n    var userWantsControl = getHookArgumentsLength(leave);\n\n    var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);\n\n    if (\"development\" !== 'production' && isDef(explicitLeaveDuration)) {\n      checkDuration(explicitLeaveDuration, 'leave', vnode);\n    }\n\n    var cb = el._leaveCb = once(function () {\n      if (el.parentNode && el.parentNode._pending) {\n        el.parentNode._pending[vnode.key] = null;\n      }\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveToClass);\n        removeTransitionClass(el, leaveActiveClass);\n      }\n      if (cb.cancelled) {\n        if (expectsCSS) {\n          removeTransitionClass(el, leaveClass);\n        }\n        leaveCancelled && leaveCancelled(el);\n      } else {\n        rm();\n        afterLeave && afterLeave(el);\n      }\n      el._leaveCb = null;\n    });\n\n    if (delayLeave) {\n      delayLeave(performLeave);\n    } else {\n      performLeave();\n    }\n\n    function performLeave() {\n      // the delayed leave may have already been cancelled\n      if (cb.cancelled) {\n        return;\n      }\n      // record leaving element\n      if (!vnode.data.show) {\n        (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;\n      }\n      beforeLeave && beforeLeave(el);\n      if (expectsCSS) {\n        addTransitionClass(el, leaveClass);\n        addTransitionClass(el, leaveActiveClass);\n        nextFrame(function () {\n          addTransitionClass(el, leaveToClass);\n          removeTransitionClass(el, leaveClass);\n          if (!cb.cancelled && !userWantsControl) {\n            if (isValidDuration(explicitLeaveDuration)) {\n              setTimeout(cb, explicitLeaveDuration);\n            } else {\n              whenTransitionEnds(el, type, cb);\n            }\n          }\n        });\n      }\n      leave && leave(el, cb);\n      if (!expectsCSS && !userWantsControl) {\n        cb();\n      }\n    }\n  }\n\n  // only used in dev mode\n  function checkDuration(val, name, vnode) {\n    if (typeof val !== 'number') {\n      warn(\"<transition> explicit \" + name + \" duration is not a valid number - \" + \"got \" + JSON.stringify(val) + \".\", vnode.context);\n    } else if (isNaN(val)) {\n      warn(\"<transition> explicit \" + name + \" duration is NaN - \" + 'the duration expression might be incorrect.', vnode.context);\n    }\n  }\n\n  function isValidDuration(val) {\n    return typeof val === 'number' && !isNaN(val);\n  }\n\n  /**\n   * Normalize a transition hook's argument length. The hook may be:\n   * - a merged hook (invoker) with the original in .fns\n   * - a wrapped component method (check ._length)\n   * - a plain function (.length)\n   */\n  function getHookArgumentsLength(fn) {\n    if (isUndef(fn)) {\n      return false;\n    }\n    var invokerFns = fn.fns;\n    if (isDef(invokerFns)) {\n      // invoker\n      return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);\n    } else {\n      return (fn._length || fn.length) > 1;\n    }\n  }\n\n  function _enter(_, vnode) {\n    if (vnode.data.show !== true) {\n      enter(vnode);\n    }\n  }\n\n  var transition = inBrowser ? {\n    create: _enter,\n    activate: _enter,\n    remove: function remove$$1(vnode, rm) {\n      /* istanbul ignore else */\n      if (vnode.data.show !== true) {\n        leave(vnode, rm);\n      } else {\n        rm();\n      }\n    }\n  } : {};\n\n  var platformModules = [attrs, klass, events, domProps, style, transition];\n\n  /*  */\n\n  // the directive module should be applied last, after all\n  // built-in modules have been applied.\n  var modules = platformModules.concat(baseModules);\n\n  var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n  /**\n   * Not type checking this file because flow doesn't like attaching\n   * properties to Elements.\n   */\n\n  var isTextInputType = makeMap('text,number,password,search,email,tel,url');\n\n  /* istanbul ignore if */\n  if (isIE9) {\n    // http://www.matts411.com/post/internet-explorer-9-oninput/\n    document.addEventListener('selectionchange', function () {\n      var el = document.activeElement;\n      if (el && el.vmodel) {\n        trigger(el, 'input');\n      }\n    });\n  }\n\n  var model$1 = {\n    inserted: function inserted(el, binding, vnode) {\n      if (vnode.tag === 'select') {\n        var cb = function cb() {\n          setSelected(el, binding, vnode.context);\n        };\n        cb();\n        /* istanbul ignore if */\n        if (isIE || isEdge) {\n          setTimeout(cb, 0);\n        }\n      } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {\n        el._vModifiers = binding.modifiers;\n        if (!binding.modifiers.lazy) {\n          // Safari < 10.2 & UIWebView doesn't fire compositionend when\n          // switching focus before confirming composition choice\n          // this also fixes the issue where some browsers e.g. iOS Chrome\n          // fires \"change\" instead of \"input\" on autocomplete.\n          el.addEventListener('change', onCompositionEnd);\n          if (!isAndroid) {\n            el.addEventListener('compositionstart', onCompositionStart);\n            el.addEventListener('compositionend', onCompositionEnd);\n          }\n          /* istanbul ignore if */\n          if (isIE9) {\n            el.vmodel = true;\n          }\n        }\n      }\n    },\n    componentUpdated: function componentUpdated(el, binding, vnode) {\n      if (vnode.tag === 'select') {\n        setSelected(el, binding, vnode.context);\n        // in case the options rendered by v-for have changed,\n        // it's possible that the value is out-of-sync with the rendered options.\n        // detect such cases and filter out values that no longer has a matching\n        // option in the DOM.\n        var needReset = el.multiple ? binding.value.some(function (v) {\n          return hasNoMatchingOption(v, el.options);\n        }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, el.options);\n        if (needReset) {\n          trigger(el, 'change');\n        }\n      }\n    }\n  };\n\n  function setSelected(el, binding, vm) {\n    var value = binding.value;\n    var isMultiple = el.multiple;\n    if (isMultiple && !Array.isArray(value)) {\n      \"development\" !== 'production' && warn(\"<select multiple v-model=\\\"\" + binding.expression + \"\\\"> \" + \"expects an Array value for its binding, but got \" + Object.prototype.toString.call(value).slice(8, -1), vm);\n      return;\n    }\n    var selected, option;\n    for (var i = 0, l = el.options.length; i < l; i++) {\n      option = el.options[i];\n      if (isMultiple) {\n        selected = looseIndexOf(value, getValue(option)) > -1;\n        if (option.selected !== selected) {\n          option.selected = selected;\n        }\n      } else {\n        if (looseEqual(getValue(option), value)) {\n          if (el.selectedIndex !== i) {\n            el.selectedIndex = i;\n          }\n          return;\n        }\n      }\n    }\n    if (!isMultiple) {\n      el.selectedIndex = -1;\n    }\n  }\n\n  function hasNoMatchingOption(value, options) {\n    for (var i = 0, l = options.length; i < l; i++) {\n      if (looseEqual(getValue(options[i]), value)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  function getValue(option) {\n    return '_value' in option ? option._value : option.value;\n  }\n\n  function onCompositionStart(e) {\n    e.target.composing = true;\n  }\n\n  function onCompositionEnd(e) {\n    // prevent triggering an input event for no reason\n    if (!e.target.composing) {\n      return;\n    }\n    e.target.composing = false;\n    trigger(e.target, 'input');\n  }\n\n  function trigger(el, type) {\n    var e = document.createEvent('HTMLEvents');\n    e.initEvent(type, true, true);\n    el.dispatchEvent(e);\n  }\n\n  /*  */\n\n  // recursively search for possible transition defined inside the component root\n  function locateNode(vnode) {\n    return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;\n  }\n\n  var show = {\n    bind: function bind(el, ref, vnode) {\n      var value = ref.value;\n\n      vnode = locateNode(vnode);\n      var transition$$1 = vnode.data && vnode.data.transition;\n      var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;\n      if (value && transition$$1 && !isIE9) {\n        vnode.data.show = true;\n        enter(vnode, function () {\n          el.style.display = originalDisplay;\n        });\n      } else {\n        el.style.display = value ? originalDisplay : 'none';\n      }\n    },\n\n    update: function update(el, ref, vnode) {\n      var value = ref.value;\n      var oldValue = ref.oldValue;\n\n      /* istanbul ignore if */\n      if (value === oldValue) {\n        return;\n      }\n      vnode = locateNode(vnode);\n      var transition$$1 = vnode.data && vnode.data.transition;\n      if (transition$$1 && !isIE9) {\n        vnode.data.show = true;\n        if (value) {\n          enter(vnode, function () {\n            el.style.display = el.__vOriginalDisplay;\n          });\n        } else {\n          leave(vnode, function () {\n            el.style.display = 'none';\n          });\n        }\n      } else {\n        el.style.display = value ? el.__vOriginalDisplay : 'none';\n      }\n    },\n\n    unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {\n      if (!isDestroy) {\n        el.style.display = el.__vOriginalDisplay;\n      }\n    }\n  };\n\n  var platformDirectives = {\n    model: model$1,\n    show: show\n  };\n\n  /*  */\n\n  // Provides transition support for a single element/component.\n  // supports transition mode (out-in / in-out)\n\n  var transitionProps = {\n    name: String,\n    appear: Boolean,\n    css: Boolean,\n    mode: String,\n    type: String,\n    enterClass: String,\n    leaveClass: String,\n    enterToClass: String,\n    leaveToClass: String,\n    enterActiveClass: String,\n    leaveActiveClass: String,\n    appearClass: String,\n    appearActiveClass: String,\n    appearToClass: String,\n    duration: [Number, String, Object]\n  };\n\n  // in case the child is also an abstract component, e.g. <keep-alive>\n  // we want to recursively retrieve the real component to be rendered\n  function getRealChild(vnode) {\n    var compOptions = vnode && vnode.componentOptions;\n    if (compOptions && compOptions.Ctor.options.abstract) {\n      return getRealChild(getFirstComponentChild(compOptions.children));\n    } else {\n      return vnode;\n    }\n  }\n\n  function extractTransitionData(comp) {\n    var data = {};\n    var options = comp.$options;\n    // props\n    for (var key in options.propsData) {\n      data[key] = comp[key];\n    }\n    // events.\n    // extract listeners and pass them directly to the transition methods\n    var listeners = options._parentListeners;\n    for (var key$1 in listeners) {\n      data[camelize(key$1)] = listeners[key$1];\n    }\n    return data;\n  }\n\n  function placeholder(h, rawChild) {\n    if (/\\d-keep-alive$/.test(rawChild.tag)) {\n      return h('keep-alive', {\n        props: rawChild.componentOptions.propsData\n      });\n    }\n  }\n\n  function hasParentTransition(vnode) {\n    while (vnode = vnode.parent) {\n      if (vnode.data.transition) {\n        return true;\n      }\n    }\n  }\n\n  function isSameChild(child, oldChild) {\n    return oldChild.key === child.key && oldChild.tag === child.tag;\n  }\n\n  function isAsyncPlaceholder(node) {\n    return node.isComment && node.asyncFactory;\n  }\n\n  var Transition = {\n    name: 'transition',\n    props: transitionProps,\n    abstract: true,\n\n    render: function render(h) {\n      var this$1 = this;\n\n      var children = this.$options._renderChildren;\n      if (!children) {\n        return;\n      }\n\n      // filter out text nodes (possible whitespaces)\n      children = children.filter(function (c) {\n        return c.tag || isAsyncPlaceholder(c);\n      });\n      /* istanbul ignore if */\n      if (!children.length) {\n        return;\n      }\n\n      // warn multiple elements\n      if (\"development\" !== 'production' && children.length > 1) {\n        warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);\n      }\n\n      var mode = this.mode;\n\n      // warn invalid mode\n      if (\"development\" !== 'production' && mode && mode !== 'in-out' && mode !== 'out-in') {\n        warn('invalid <transition> mode: ' + mode, this.$parent);\n      }\n\n      var rawChild = children[0];\n\n      // if this is a component root node and the component's\n      // parent container node also has transition, skip.\n      if (hasParentTransition(this.$vnode)) {\n        return rawChild;\n      }\n\n      // apply transition data to child\n      // use getRealChild() to ignore abstract components e.g. keep-alive\n      var child = getRealChild(rawChild);\n      /* istanbul ignore if */\n      if (!child) {\n        return rawChild;\n      }\n\n      if (this._leaving) {\n        return placeholder(h, rawChild);\n      }\n\n      // ensure a key that is unique to the vnode type and to this transition\n      // component instance. This key will be used to remove pending leaving nodes\n      // during entering.\n      var id = \"__transition-\" + this._uid + \"-\";\n      child.key = child.key == null ? child.isComment ? id + 'comment' : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;\n\n      var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n      var oldRawChild = this._vnode;\n      var oldChild = getRealChild(oldRawChild);\n\n      // mark v-show\n      // so that the transition module can hand over the control to the directive\n      if (child.data.directives && child.data.directives.some(function (d) {\n        return d.name === 'show';\n      })) {\n        child.data.show = true;\n      }\n\n      if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild)) {\n        // replace old child transition data with fresh one\n        // important for dynamic transitions!\n        var oldData = oldChild && (oldChild.data.transition = extend({}, data));\n        // handle transition mode\n        if (mode === 'out-in') {\n          // return placeholder node and queue update when leave finishes\n          this._leaving = true;\n          mergeVNodeHook(oldData, 'afterLeave', function () {\n            this$1._leaving = false;\n            this$1.$forceUpdate();\n          });\n          return placeholder(h, rawChild);\n        } else if (mode === 'in-out') {\n          if (isAsyncPlaceholder(child)) {\n            return oldRawChild;\n          }\n          var delayedLeave;\n          var performLeave = function performLeave() {\n            delayedLeave();\n          };\n          mergeVNodeHook(data, 'afterEnter', performLeave);\n          mergeVNodeHook(data, 'enterCancelled', performLeave);\n          mergeVNodeHook(oldData, 'delayLeave', function (leave) {\n            delayedLeave = leave;\n          });\n        }\n      }\n\n      return rawChild;\n    }\n  };\n\n  /*  */\n\n  // Provides transition support for list items.\n  // supports move transitions using the FLIP technique.\n\n  // Because the vdom's children update algorithm is \"unstable\" - i.e.\n  // it doesn't guarantee the relative positioning of removed elements,\n  // we force transition-group to update its children into two passes:\n  // in the first pass, we remove all nodes that need to be removed,\n  // triggering their leaving transition; in the second pass, we insert/move\n  // into the final desired state. This way in the second pass removed\n  // nodes will remain where they should be.\n\n  var props = extend({\n    tag: String,\n    moveClass: String\n  }, transitionProps);\n\n  delete props.mode;\n\n  var TransitionGroup = {\n    props: props,\n\n    render: function render(h) {\n      var tag = this.tag || this.$vnode.data.tag || 'span';\n      var map = Object.create(null);\n      var prevChildren = this.prevChildren = this.children;\n      var rawChildren = this.$slots.default || [];\n      var children = this.children = [];\n      var transitionData = extractTransitionData(this);\n\n      for (var i = 0; i < rawChildren.length; i++) {\n        var c = rawChildren[i];\n        if (c.tag) {\n          if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n            children.push(c);\n            map[c.key] = c;(c.data || (c.data = {})).transition = transitionData;\n          } else {\n            var opts = c.componentOptions;\n            var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;\n            warn(\"<transition-group> children must be keyed: <\" + name + \">\");\n          }\n        }\n      }\n\n      if (prevChildren) {\n        var kept = [];\n        var removed = [];\n        for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n          var c$1 = prevChildren[i$1];\n          c$1.data.transition = transitionData;\n          c$1.data.pos = c$1.elm.getBoundingClientRect();\n          if (map[c$1.key]) {\n            kept.push(c$1);\n          } else {\n            removed.push(c$1);\n          }\n        }\n        this.kept = h(tag, null, kept);\n        this.removed = removed;\n      }\n\n      return h(tag, null, children);\n    },\n\n    beforeUpdate: function beforeUpdate() {\n      // force removing pass\n      this.__patch__(this._vnode, this.kept, false, // hydrating\n      true // removeOnly (!important, avoids unnecessary moves)\n      );\n      this._vnode = this.kept;\n    },\n\n    updated: function updated() {\n      var children = this.prevChildren;\n      var moveClass = this.moveClass || (this.name || 'v') + '-move';\n      if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n        return;\n      }\n\n      // we divide the work into three loops to avoid mixing DOM reads and writes\n      // in each iteration - which helps prevent layout thrashing.\n      children.forEach(callPendingCbs);\n      children.forEach(recordPosition);\n      children.forEach(applyTranslation);\n\n      // force reflow to put everything in position\n      var body = document.body;\n      var f = body.offsetHeight; // eslint-disable-line\n\n      children.forEach(function (c) {\n        if (c.data.moved) {\n          var el = c.elm;\n          var s = el.style;\n          addTransitionClass(el, moveClass);\n          s.transform = s.WebkitTransform = s.transitionDuration = '';\n          el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {\n            if (!e || /transform$/.test(e.propertyName)) {\n              el.removeEventListener(transitionEndEvent, cb);\n              el._moveCb = null;\n              removeTransitionClass(el, moveClass);\n            }\n          });\n        }\n      });\n    },\n\n    methods: {\n      hasMove: function hasMove(el, moveClass) {\n        /* istanbul ignore if */\n        if (!hasTransition) {\n          return false;\n        }\n        /* istanbul ignore if */\n        if (this._hasMove) {\n          return this._hasMove;\n        }\n        // Detect whether an element with the move class applied has\n        // CSS transitions. Since the element may be inside an entering\n        // transition at this very moment, we make a clone of it and remove\n        // all other transition classes applied to ensure only the move class\n        // is applied.\n        var clone = el.cloneNode();\n        if (el._transitionClasses) {\n          el._transitionClasses.forEach(function (cls) {\n            removeClass(clone, cls);\n          });\n        }\n        addClass(clone, moveClass);\n        clone.style.display = 'none';\n        this.$el.appendChild(clone);\n        var info = getTransitionInfo(clone);\n        this.$el.removeChild(clone);\n        return this._hasMove = info.hasTransform;\n      }\n    }\n  };\n\n  function callPendingCbs(c) {\n    /* istanbul ignore if */\n    if (c.elm._moveCb) {\n      c.elm._moveCb();\n    }\n    /* istanbul ignore if */\n    if (c.elm._enterCb) {\n      c.elm._enterCb();\n    }\n  }\n\n  function recordPosition(c) {\n    c.data.newPos = c.elm.getBoundingClientRect();\n  }\n\n  function applyTranslation(c) {\n    var oldPos = c.data.pos;\n    var newPos = c.data.newPos;\n    var dx = oldPos.left - newPos.left;\n    var dy = oldPos.top - newPos.top;\n    if (dx || dy) {\n      c.data.moved = true;\n      var s = c.elm.style;\n      s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n      s.transitionDuration = '0s';\n    }\n  }\n\n  var platformComponents = {\n    Transition: Transition,\n    TransitionGroup: TransitionGroup\n  };\n\n  /*  */\n\n  // install platform specific utils\n  Vue$3.config.mustUseProp = mustUseProp;\n  Vue$3.config.isReservedTag = isReservedTag;\n  Vue$3.config.isReservedAttr = isReservedAttr;\n  Vue$3.config.getTagNamespace = getTagNamespace;\n  Vue$3.config.isUnknownElement = isUnknownElement;\n\n  // install platform runtime directives & components\n  extend(Vue$3.options.directives, platformDirectives);\n  extend(Vue$3.options.components, platformComponents);\n\n  // install platform patch function\n  Vue$3.prototype.__patch__ = inBrowser ? patch : noop;\n\n  // public mount method\n  Vue$3.prototype.$mount = function (el, hydrating) {\n    el = el && inBrowser ? query(el) : undefined;\n    return mountComponent(this, el, hydrating);\n  };\n\n  // devtools global hook\n  /* istanbul ignore next */\n  setTimeout(function () {\n    if (config.devtools) {\n      if (devtools) {\n        devtools.emit('init', Vue$3);\n      } else if (\"development\" !== 'production' && isChrome) {\n        console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\\n' + 'https://github.com/vuejs/vue-devtools');\n      }\n    }\n    if (\"development\" !== 'production' && config.productionTip !== false && inBrowser && typeof console !== 'undefined') {\n      console[console.info ? 'info' : 'log'](\"You are running Vue in development mode.\\n\" + \"Make sure to turn on production mode when deploying for production.\\n\" + \"See more tips at https://vuejs.org/guide/deployment.html\");\n    }\n  }, 0);\n\n  /*  */\n\n  // check whether current browser encodes a char inside attribute values\n  function shouldDecode(content, encoded) {\n    var div = document.createElement('div');\n    div.innerHTML = \"<div a=\\\"\" + content + \"\\\"/>\";\n    return div.innerHTML.indexOf(encoded) > 0;\n  }\n\n  // #3663\n  // IE encodes newlines inside attribute values while other browsers don't\n  var shouldDecodeNewlines = inBrowser ? shouldDecode('\\n', '&#10;') : false;\n\n  /*  */\n\n  var defaultTagRE = /\\{\\{((?:.|\\n)+?)\\}\\}/g;\n  var regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n\n  var buildRegex = cached(function (delimiters) {\n    var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n    var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n    return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g');\n  });\n\n  function parseText(text, delimiters) {\n    var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n    if (!tagRE.test(text)) {\n      return;\n    }\n    var tokens = [];\n    var lastIndex = tagRE.lastIndex = 0;\n    var match, index;\n    while (match = tagRE.exec(text)) {\n      index = match.index;\n      // push text token\n      if (index > lastIndex) {\n        tokens.push(JSON.stringify(text.slice(lastIndex, index)));\n      }\n      // tag token\n      var exp = parseFilters(match[1].trim());\n      tokens.push(\"_s(\" + exp + \")\");\n      lastIndex = index + match[0].length;\n    }\n    if (lastIndex < text.length) {\n      tokens.push(JSON.stringify(text.slice(lastIndex)));\n    }\n    return tokens.join('+');\n  }\n\n  /*  */\n\n  function transformNode(el, options) {\n    var warn = options.warn || baseWarn;\n    var staticClass = getAndRemoveAttr(el, 'class');\n    if (\"development\" !== 'production' && staticClass) {\n      var expression = parseText(staticClass, options.delimiters);\n      if (expression) {\n        warn(\"class=\\\"\" + staticClass + \"\\\": \" + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.');\n      }\n    }\n    if (staticClass) {\n      el.staticClass = JSON.stringify(staticClass);\n    }\n    var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n    if (classBinding) {\n      el.classBinding = classBinding;\n    }\n  }\n\n  function genData(el) {\n    var data = '';\n    if (el.staticClass) {\n      data += \"staticClass:\" + el.staticClass + \",\";\n    }\n    if (el.classBinding) {\n      data += \"class:\" + el.classBinding + \",\";\n    }\n    return data;\n  }\n\n  var klass$1 = {\n    staticKeys: ['staticClass'],\n    transformNode: transformNode,\n    genData: genData\n  };\n\n  /*  */\n\n  function transformNode$1(el, options) {\n    var warn = options.warn || baseWarn;\n    var staticStyle = getAndRemoveAttr(el, 'style');\n    if (staticStyle) {\n      /* istanbul ignore if */\n      {\n        var expression = parseText(staticStyle, options.delimiters);\n        if (expression) {\n          warn(\"style=\\\"\" + staticStyle + \"\\\": \" + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.');\n        }\n      }\n      el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n    }\n\n    var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\n    if (styleBinding) {\n      el.styleBinding = styleBinding;\n    }\n  }\n\n  function genData$1(el) {\n    var data = '';\n    if (el.staticStyle) {\n      data += \"staticStyle:\" + el.staticStyle + \",\";\n    }\n    if (el.styleBinding) {\n      data += \"style:(\" + el.styleBinding + \"),\";\n    }\n    return data;\n  }\n\n  var style$1 = {\n    staticKeys: ['staticStyle'],\n    transformNode: transformNode$1,\n    genData: genData$1\n  };\n\n  var modules$1 = [klass$1, style$1];\n\n  /*  */\n\n  function text(el, dir) {\n    if (dir.value) {\n      addProp(el, 'textContent', \"_s(\" + dir.value + \")\");\n    }\n  }\n\n  /*  */\n\n  function html(el, dir) {\n    if (dir.value) {\n      addProp(el, 'innerHTML', \"_s(\" + dir.value + \")\");\n    }\n  }\n\n  var directives$1 = {\n    model: model,\n    text: text,\n    html: html\n  };\n\n  /*  */\n\n  var isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' + 'link,meta,param,source,track,wbr');\n\n  // Elements that you can, intentionally, leave open\n  // (and which close themselves)\n  var canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source');\n\n  // HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n  // Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\n  var isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' + 'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' + 'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' + 'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' + 'title,tr,track');\n\n  /*  */\n\n  var baseOptions = {\n    expectHTML: true,\n    modules: modules$1,\n    directives: directives$1,\n    isPreTag: isPreTag,\n    isUnaryTag: isUnaryTag,\n    mustUseProp: mustUseProp,\n    canBeLeftOpenTag: canBeLeftOpenTag,\n    isReservedTag: isReservedTag,\n    getTagNamespace: getTagNamespace,\n    staticKeys: genStaticKeys(modules$1)\n  };\n\n  /*  */\n\n  var decoder;\n\n  var he = {\n    decode: function decode(html) {\n      decoder = decoder || document.createElement('div');\n      decoder.innerHTML = html;\n      return decoder.textContent;\n    }\n  };\n\n  /**\n   * Not type-checking this file because it's mostly vendor code.\n   */\n\n  /*!\n   * HTML Parser By John Resig (ejohn.org)\n   * Modified by Juriy \"kangax\" Zaytsev\n   * Original code by Erik Arvidsson, Mozilla Public License\n   * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n   */\n\n  // Regular Expressions for parsing tags and attributes\n  var singleAttrIdentifier = /([^\\s\"'<>/=]+)/;\n  var singleAttrAssign = /(?:=)/;\n  var singleAttrValues = [\n  // attr value double quotes\n  /\"([^\"]*)\"+/.source,\n  // attr value, single quotes\n  /'([^']*)'+/.source,\n  // attr value, no quotes\n  /([^\\s\"'=<>`]+)/.source];\n  var attribute = new RegExp('^\\\\s*' + singleAttrIdentifier.source + '(?:\\\\s*(' + singleAttrAssign.source + ')' + '\\\\s*(?:' + singleAttrValues.join('|') + '))?');\n\n  // could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName\n  // but for Vue templates we can enforce a simple charset\n  var ncname = '[a-zA-Z_][\\\\w\\\\-\\\\.]*';\n  var qnameCapture = '((?:' + ncname + '\\\\:)?' + ncname + ')';\n  var startTagOpen = new RegExp('^<' + qnameCapture);\n  var startTagClose = /^\\s*(\\/?)>/;\n  var endTag = new RegExp('^<\\\\/' + qnameCapture + '[^>]*>');\n  var doctype = /^<!DOCTYPE [^>]+>/i;\n  var comment = /^<!--/;\n  var conditionalComment = /^<!\\[/;\n\n  var IS_REGEX_CAPTURING_BROKEN = false;\n  'x'.replace(/x(.)?/g, function (m, g) {\n    IS_REGEX_CAPTURING_BROKEN = g === '';\n  });\n\n  // Special Elements (can contain anything)\n  var isPlainTextElement = makeMap('script,style,textarea', true);\n  var reCache = {};\n\n  var decodingMap = {\n    '&lt;': '<',\n    '&gt;': '>',\n    '&quot;': '\"',\n    '&amp;': '&',\n    '&#10;': '\\n'\n  };\n  var encodedAttr = /&(?:lt|gt|quot|amp);/g;\n  var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10);/g;\n\n  // #5992\n  var isIgnoreNewlineTag = makeMap('pre,textarea', true);\n  var shouldIgnoreFirstNewline = function shouldIgnoreFirstNewline(tag, html) {\n    return tag && isIgnoreNewlineTag(tag) && html[0] === '\\n';\n  };\n\n  function decodeAttr(value, shouldDecodeNewlines) {\n    var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n    return value.replace(re, function (match) {\n      return decodingMap[match];\n    });\n  }\n\n  function parseHTML(html, options) {\n    var stack = [];\n    var expectHTML = options.expectHTML;\n    var isUnaryTag$$1 = options.isUnaryTag || no;\n    var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n    var index = 0;\n    var last, lastTag;\n    while (html) {\n      last = html;\n      // Make sure we're not in a plaintext content element like script/style\n      if (!lastTag || !isPlainTextElement(lastTag)) {\n        if (shouldIgnoreFirstNewline(lastTag, html)) {\n          advance(1);\n        }\n        var textEnd = html.indexOf('<');\n        if (textEnd === 0) {\n          // Comment:\n          if (comment.test(html)) {\n            var commentEnd = html.indexOf('-->');\n\n            if (commentEnd >= 0) {\n              if (options.shouldKeepComment) {\n                options.comment(html.substring(4, commentEnd));\n              }\n              advance(commentEnd + 3);\n              continue;\n            }\n          }\n\n          // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n          if (conditionalComment.test(html)) {\n            var conditionalEnd = html.indexOf(']>');\n\n            if (conditionalEnd >= 0) {\n              advance(conditionalEnd + 2);\n              continue;\n            }\n          }\n\n          // Doctype:\n          var doctypeMatch = html.match(doctype);\n          if (doctypeMatch) {\n            advance(doctypeMatch[0].length);\n            continue;\n          }\n\n          // End tag:\n          var endTagMatch = html.match(endTag);\n          if (endTagMatch) {\n            var curIndex = index;\n            advance(endTagMatch[0].length);\n            parseEndTag(endTagMatch[1], curIndex, index);\n            continue;\n          }\n\n          // Start tag:\n          var startTagMatch = parseStartTag();\n          if (startTagMatch) {\n            handleStartTag(startTagMatch);\n            continue;\n          }\n        }\n\n        var text = void 0,\n            rest = void 0,\n            next = void 0;\n        if (textEnd >= 0) {\n          rest = html.slice(textEnd);\n          while (!endTag.test(rest) && !startTagOpen.test(rest) && !comment.test(rest) && !conditionalComment.test(rest)) {\n            // < in plain text, be forgiving and treat it as text\n            next = rest.indexOf('<', 1);\n            if (next < 0) {\n              break;\n            }\n            textEnd += next;\n            rest = html.slice(textEnd);\n          }\n          text = html.substring(0, textEnd);\n          advance(textEnd);\n        }\n\n        if (textEnd < 0) {\n          text = html;\n          html = '';\n        }\n\n        if (options.chars && text) {\n          options.chars(text);\n        }\n      } else {\n        var endTagLength = 0;\n        var stackedTag = lastTag.toLowerCase();\n        var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n        var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {\n          endTagLength = endTag.length;\n          if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\n            text = text.replace(/<!--([\\s\\S]*?)-->/g, '$1').replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n          }\n          if (shouldIgnoreFirstNewline(stackedTag, text)) {\n            text = text.slice(1);\n          }\n          if (options.chars) {\n            options.chars(text);\n          }\n          return '';\n        });\n        index += html.length - rest$1.length;\n        html = rest$1;\n        parseEndTag(stackedTag, index - endTagLength, index);\n      }\n\n      if (html === last) {\n        options.chars && options.chars(html);\n        if (\"development\" !== 'production' && !stack.length && options.warn) {\n          options.warn(\"Mal-formatted tag at end of template: \\\"\" + html + \"\\\"\");\n        }\n        break;\n      }\n    }\n\n    // Clean up any remaining tags\n    parseEndTag();\n\n    function advance(n) {\n      index += n;\n      html = html.substring(n);\n    }\n\n    function parseStartTag() {\n      var start = html.match(startTagOpen);\n      if (start) {\n        var match = {\n          tagName: start[1],\n          attrs: [],\n          start: index\n        };\n        advance(start[0].length);\n        var end, attr;\n        while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n          advance(attr[0].length);\n          match.attrs.push(attr);\n        }\n        if (end) {\n          match.unarySlash = end[1];\n          advance(end[0].length);\n          match.end = index;\n          return match;\n        }\n      }\n    }\n\n    function handleStartTag(match) {\n      var tagName = match.tagName;\n      var unarySlash = match.unarySlash;\n\n      if (expectHTML) {\n        if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n          parseEndTag(lastTag);\n        }\n        if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\n          parseEndTag(tagName);\n        }\n      }\n\n      var unary = isUnaryTag$$1(tagName) || !!unarySlash;\n\n      var l = match.attrs.length;\n      var attrs = new Array(l);\n      for (var i = 0; i < l; i++) {\n        var args = match.attrs[i];\n        // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778\n        if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('\"\"') === -1) {\n          if (args[3] === '') {\n            delete args[3];\n          }\n          if (args[4] === '') {\n            delete args[4];\n          }\n          if (args[5] === '') {\n            delete args[5];\n          }\n        }\n        var value = args[3] || args[4] || args[5] || '';\n        attrs[i] = {\n          name: args[1],\n          value: decodeAttr(value, options.shouldDecodeNewlines)\n        };\n      }\n\n      if (!unary) {\n        stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });\n        lastTag = tagName;\n      }\n\n      if (options.start) {\n        options.start(tagName, attrs, unary, match.start, match.end);\n      }\n    }\n\n    function parseEndTag(tagName, start, end) {\n      var pos, lowerCasedTagName;\n      if (start == null) {\n        start = index;\n      }\n      if (end == null) {\n        end = index;\n      }\n\n      if (tagName) {\n        lowerCasedTagName = tagName.toLowerCase();\n      }\n\n      // Find the closest opened tag of the same type\n      if (tagName) {\n        for (pos = stack.length - 1; pos >= 0; pos--) {\n          if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n            break;\n          }\n        }\n      } else {\n        // If no tag name is provided, clean shop\n        pos = 0;\n      }\n\n      if (pos >= 0) {\n        // Close all the open elements, up the stack\n        for (var i = stack.length - 1; i >= pos; i--) {\n          if (\"development\" !== 'production' && (i > pos || !tagName) && options.warn) {\n            options.warn(\"tag <\" + stack[i].tag + \"> has no matching end tag.\");\n          }\n          if (options.end) {\n            options.end(stack[i].tag, start, end);\n          }\n        }\n\n        // Remove the open elements from the stack\n        stack.length = pos;\n        lastTag = pos && stack[pos - 1].tag;\n      } else if (lowerCasedTagName === 'br') {\n        if (options.start) {\n          options.start(tagName, [], true, start, end);\n        }\n      } else if (lowerCasedTagName === 'p') {\n        if (options.start) {\n          options.start(tagName, [], false, start, end);\n        }\n        if (options.end) {\n          options.end(tagName, start, end);\n        }\n      }\n    }\n  }\n\n  /*  */\n\n  var onRE = /^@|^v-on:/;\n  var dirRE = /^v-|^@|^:/;\n  var forAliasRE = /(.*?)\\s+(?:in|of)\\s+(.*)/;\n  var forIteratorRE = /\\((\\{[^}]*\\}|[^,]*),([^,]*)(?:,([^,]*))?\\)/;\n\n  var argRE = /:(.*)$/;\n  var bindRE = /^:|^v-bind:/;\n  var modifierRE = /\\.[^.]+/g;\n\n  var decodeHTMLCached = cached(he.decode);\n\n  // configurable state\n  var warn$2;\n  var delimiters;\n  var transforms;\n  var preTransforms;\n  var postTransforms;\n  var platformIsPreTag;\n  var platformMustUseProp;\n  var platformGetTagNamespace;\n\n  /**\n   * Convert HTML string to AST.\n   */\n  function parse(template, options) {\n    warn$2 = options.warn || baseWarn;\n\n    platformIsPreTag = options.isPreTag || no;\n    platformMustUseProp = options.mustUseProp || no;\n    platformGetTagNamespace = options.getTagNamespace || no;\n\n    transforms = pluckModuleFunction(options.modules, 'transformNode');\n    preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n    postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n\n    delimiters = options.delimiters;\n\n    var stack = [];\n    var preserveWhitespace = options.preserveWhitespace !== false;\n    var root;\n    var currentParent;\n    var inVPre = false;\n    var inPre = false;\n    var warned = false;\n\n    function warnOnce(msg) {\n      if (!warned) {\n        warned = true;\n        warn$2(msg);\n      }\n    }\n\n    function endPre(element) {\n      // check pre state\n      if (element.pre) {\n        inVPre = false;\n      }\n      if (platformIsPreTag(element.tag)) {\n        inPre = false;\n      }\n    }\n\n    parseHTML(template, {\n      warn: warn$2,\n      expectHTML: options.expectHTML,\n      isUnaryTag: options.isUnaryTag,\n      canBeLeftOpenTag: options.canBeLeftOpenTag,\n      shouldDecodeNewlines: options.shouldDecodeNewlines,\n      shouldKeepComment: options.comments,\n      start: function start(tag, attrs, unary) {\n        // check namespace.\n        // inherit parent ns if there is one\n        var ns = currentParent && currentParent.ns || platformGetTagNamespace(tag);\n\n        // handle IE svg bug\n        /* istanbul ignore if */\n        if (isIE && ns === 'svg') {\n          attrs = guardIESVGBug(attrs);\n        }\n\n        var element = {\n          type: 1,\n          tag: tag,\n          attrsList: attrs,\n          attrsMap: makeAttrsMap(attrs),\n          parent: currentParent,\n          children: []\n        };\n        if (ns) {\n          element.ns = ns;\n        }\n\n        if (isForbiddenTag(element) && !isServerRendering()) {\n          element.forbidden = true;\n          \"development\" !== 'production' && warn$2('Templates should only be responsible for mapping the state to the ' + 'UI. Avoid placing tags with side-effects in your templates, such as ' + \"<\" + tag + \">\" + ', as they will not be parsed.');\n        }\n\n        // apply pre-transforms\n        for (var i = 0; i < preTransforms.length; i++) {\n          preTransforms[i](element, options);\n        }\n\n        if (!inVPre) {\n          processPre(element);\n          if (element.pre) {\n            inVPre = true;\n          }\n        }\n        if (platformIsPreTag(element.tag)) {\n          inPre = true;\n        }\n        if (inVPre) {\n          processRawAttrs(element);\n        } else {\n          processFor(element);\n          processIf(element);\n          processOnce(element);\n          processKey(element);\n\n          // determine whether this is a plain element after\n          // removing structural attributes\n          element.plain = !element.key && !attrs.length;\n\n          processRef(element);\n          processSlot(element);\n          processComponent(element);\n          for (var i$1 = 0; i$1 < transforms.length; i$1++) {\n            transforms[i$1](element, options);\n          }\n          processAttrs(element);\n        }\n\n        function checkRootConstraints(el) {\n          {\n            if (el.tag === 'slot' || el.tag === 'template') {\n              warnOnce(\"Cannot use <\" + el.tag + \"> as component root element because it may \" + 'contain multiple nodes.');\n            }\n            if (el.attrsMap.hasOwnProperty('v-for')) {\n              warnOnce('Cannot use v-for on stateful component root element because ' + 'it renders multiple elements.');\n            }\n          }\n        }\n\n        // tree management\n        if (!root) {\n          root = element;\n          checkRootConstraints(root);\n        } else if (!stack.length) {\n          // allow root elements with v-if, v-else-if and v-else\n          if (root.if && (element.elseif || element.else)) {\n            checkRootConstraints(element);\n            addIfCondition(root, {\n              exp: element.elseif,\n              block: element\n            });\n          } else {\n            warnOnce(\"Component template should contain exactly one root element. \" + \"If you are using v-if on multiple elements, \" + \"use v-else-if to chain them instead.\");\n          }\n        }\n        if (currentParent && !element.forbidden) {\n          if (element.elseif || element.else) {\n            processIfConditions(element, currentParent);\n          } else if (element.slotScope) {\n            // scoped slot\n            currentParent.plain = false;\n            var name = element.slotTarget || '\"default\"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n          } else {\n            currentParent.children.push(element);\n            element.parent = currentParent;\n          }\n        }\n        if (!unary) {\n          currentParent = element;\n          stack.push(element);\n        } else {\n          endPre(element);\n        }\n        // apply post-transforms\n        for (var i$2 = 0; i$2 < postTransforms.length; i$2++) {\n          postTransforms[i$2](element, options);\n        }\n      },\n\n      end: function end() {\n        // remove trailing whitespace\n        var element = stack[stack.length - 1];\n        var lastNode = element.children[element.children.length - 1];\n        if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {\n          element.children.pop();\n        }\n        // pop stack\n        stack.length -= 1;\n        currentParent = stack[stack.length - 1];\n        endPre(element);\n      },\n\n      chars: function chars(text) {\n        if (!currentParent) {\n          {\n            if (text === template) {\n              warnOnce('Component template requires a root element, rather than just text.');\n            } else if (text = text.trim()) {\n              warnOnce(\"text \\\"\" + text + \"\\\" outside root element will be ignored.\");\n            }\n          }\n          return;\n        }\n        // IE textarea placeholder bug\n        /* istanbul ignore if */\n        if (isIE && currentParent.tag === 'textarea' && currentParent.attrsMap.placeholder === text) {\n          return;\n        }\n        var children = currentParent.children;\n        text = inPre || text.trim() ? isTextTag(currentParent) ? text : decodeHTMLCached(text)\n        // only preserve whitespace if its not right after a starting tag\n        : preserveWhitespace && children.length ? ' ' : '';\n        if (text) {\n          var expression;\n          if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {\n            children.push({\n              type: 2,\n              expression: expression,\n              text: text\n            });\n          } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {\n            children.push({\n              type: 3,\n              text: text\n            });\n          }\n        }\n      },\n      comment: function comment(text) {\n        currentParent.children.push({\n          type: 3,\n          text: text,\n          isComment: true\n        });\n      }\n    });\n    return root;\n  }\n\n  function processPre(el) {\n    if (getAndRemoveAttr(el, 'v-pre') != null) {\n      el.pre = true;\n    }\n  }\n\n  function processRawAttrs(el) {\n    var l = el.attrsList.length;\n    if (l) {\n      var attrs = el.attrs = new Array(l);\n      for (var i = 0; i < l; i++) {\n        attrs[i] = {\n          name: el.attrsList[i].name,\n          value: JSON.stringify(el.attrsList[i].value)\n        };\n      }\n    } else if (!el.pre) {\n      // non root node in pre blocks with no attributes\n      el.plain = true;\n    }\n  }\n\n  function processKey(el) {\n    var exp = getBindingAttr(el, 'key');\n    if (exp) {\n      if (\"development\" !== 'production' && el.tag === 'template') {\n        warn$2(\"<template> cannot be keyed. Place the key on real elements instead.\");\n      }\n      el.key = exp;\n    }\n  }\n\n  function processRef(el) {\n    var ref = getBindingAttr(el, 'ref');\n    if (ref) {\n      el.ref = ref;\n      el.refInFor = checkInFor(el);\n    }\n  }\n\n  function processFor(el) {\n    var exp;\n    if (exp = getAndRemoveAttr(el, 'v-for')) {\n      var inMatch = exp.match(forAliasRE);\n      if (!inMatch) {\n        \"development\" !== 'production' && warn$2(\"Invalid v-for expression: \" + exp);\n        return;\n      }\n      el.for = inMatch[2].trim();\n      var alias = inMatch[1].trim();\n      var iteratorMatch = alias.match(forIteratorRE);\n      if (iteratorMatch) {\n        el.alias = iteratorMatch[1].trim();\n        el.iterator1 = iteratorMatch[2].trim();\n        if (iteratorMatch[3]) {\n          el.iterator2 = iteratorMatch[3].trim();\n        }\n      } else {\n        el.alias = alias;\n      }\n    }\n  }\n\n  function processIf(el) {\n    var exp = getAndRemoveAttr(el, 'v-if');\n    if (exp) {\n      el.if = exp;\n      addIfCondition(el, {\n        exp: exp,\n        block: el\n      });\n    } else {\n      if (getAndRemoveAttr(el, 'v-else') != null) {\n        el.else = true;\n      }\n      var elseif = getAndRemoveAttr(el, 'v-else-if');\n      if (elseif) {\n        el.elseif = elseif;\n      }\n    }\n  }\n\n  function processIfConditions(el, parent) {\n    var prev = findPrevElement(parent.children);\n    if (prev && prev.if) {\n      addIfCondition(prev, {\n        exp: el.elseif,\n        block: el\n      });\n    } else {\n      warn$2(\"v-\" + (el.elseif ? 'else-if=\"' + el.elseif + '\"' : 'else') + \" \" + \"used on element <\" + el.tag + \"> without corresponding v-if.\");\n    }\n  }\n\n  function findPrevElement(children) {\n    var i = children.length;\n    while (i--) {\n      if (children[i].type === 1) {\n        return children[i];\n      } else {\n        if (\"development\" !== 'production' && children[i].text !== ' ') {\n          warn$2(\"text \\\"\" + children[i].text.trim() + \"\\\" between v-if and v-else(-if) \" + \"will be ignored.\");\n        }\n        children.pop();\n      }\n    }\n  }\n\n  function addIfCondition(el, condition) {\n    if (!el.ifConditions) {\n      el.ifConditions = [];\n    }\n    el.ifConditions.push(condition);\n  }\n\n  function processOnce(el) {\n    var once$$1 = getAndRemoveAttr(el, 'v-once');\n    if (once$$1 != null) {\n      el.once = true;\n    }\n  }\n\n  function processSlot(el) {\n    if (el.tag === 'slot') {\n      el.slotName = getBindingAttr(el, 'name');\n      if (\"development\" !== 'production' && el.key) {\n        warn$2(\"`key` does not work on <slot> because slots are abstract outlets \" + \"and can possibly expand into multiple elements. \" + \"Use the key on a wrapping element instead.\");\n      }\n    } else {\n      var slotTarget = getBindingAttr(el, 'slot');\n      if (slotTarget) {\n        el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n      }\n      if (el.tag === 'template') {\n        el.slotScope = getAndRemoveAttr(el, 'scope');\n      }\n    }\n  }\n\n  function processComponent(el) {\n    var binding;\n    if (binding = getBindingAttr(el, 'is')) {\n      el.component = binding;\n    }\n    if (getAndRemoveAttr(el, 'inline-template') != null) {\n      el.inlineTemplate = true;\n    }\n  }\n\n  function processAttrs(el) {\n    var list = el.attrsList;\n    var i, l, name, rawName, value, modifiers, isProp;\n    for (i = 0, l = list.length; i < l; i++) {\n      name = rawName = list[i].name;\n      value = list[i].value;\n      if (dirRE.test(name)) {\n        // mark element as dynamic\n        el.hasBindings = true;\n        // modifiers\n        modifiers = parseModifiers(name);\n        if (modifiers) {\n          name = name.replace(modifierRE, '');\n        }\n        if (bindRE.test(name)) {\n          // v-bind\n          name = name.replace(bindRE, '');\n          value = parseFilters(value);\n          isProp = false;\n          if (modifiers) {\n            if (modifiers.prop) {\n              isProp = true;\n              name = camelize(name);\n              if (name === 'innerHtml') {\n                name = 'innerHTML';\n              }\n            }\n            if (modifiers.camel) {\n              name = camelize(name);\n            }\n            if (modifiers.sync) {\n              addHandler(el, \"update:\" + camelize(name), genAssignmentCode(value, \"$event\"));\n            }\n          }\n          if (!el.component && (isProp || platformMustUseProp(el.tag, el.attrsMap.type, name))) {\n            addProp(el, name, value);\n          } else {\n            addAttr(el, name, value);\n          }\n        } else if (onRE.test(name)) {\n          // v-on\n          name = name.replace(onRE, '');\n          addHandler(el, name, value, modifiers, false, warn$2);\n        } else {\n          // normal directives\n          name = name.replace(dirRE, '');\n          // parse arg\n          var argMatch = name.match(argRE);\n          var arg = argMatch && argMatch[1];\n          if (arg) {\n            name = name.slice(0, -(arg.length + 1));\n          }\n          addDirective(el, name, rawName, value, arg, modifiers);\n          if (\"development\" !== 'production' && name === 'model') {\n            checkForAliasModel(el, value);\n          }\n        }\n      } else {\n        // literal attribute\n        {\n          var expression = parseText(value, delimiters);\n          if (expression) {\n            warn$2(name + \"=\\\"\" + value + \"\\\": \" + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.');\n          }\n        }\n        addAttr(el, name, JSON.stringify(value));\n      }\n    }\n  }\n\n  function checkInFor(el) {\n    var parent = el;\n    while (parent) {\n      if (parent.for !== undefined) {\n        return true;\n      }\n      parent = parent.parent;\n    }\n    return false;\n  }\n\n  function parseModifiers(name) {\n    var match = name.match(modifierRE);\n    if (match) {\n      var ret = {};\n      match.forEach(function (m) {\n        ret[m.slice(1)] = true;\n      });\n      return ret;\n    }\n  }\n\n  function makeAttrsMap(attrs) {\n    var map = {};\n    for (var i = 0, l = attrs.length; i < l; i++) {\n      if (\"development\" !== 'production' && map[attrs[i].name] && !isIE && !isEdge) {\n        warn$2('duplicate attribute: ' + attrs[i].name);\n      }\n      map[attrs[i].name] = attrs[i].value;\n    }\n    return map;\n  }\n\n  // for script (e.g. type=\"x/template\") or style, do not decode content\n  function isTextTag(el) {\n    return el.tag === 'script' || el.tag === 'style';\n  }\n\n  function isForbiddenTag(el) {\n    return el.tag === 'style' || el.tag === 'script' && (!el.attrsMap.type || el.attrsMap.type === 'text/javascript');\n  }\n\n  var ieNSBug = /^xmlns:NS\\d+/;\n  var ieNSPrefix = /^NS\\d+:/;\n\n  /* istanbul ignore next */\n  function guardIESVGBug(attrs) {\n    var res = [];\n    for (var i = 0; i < attrs.length; i++) {\n      var attr = attrs[i];\n      if (!ieNSBug.test(attr.name)) {\n        attr.name = attr.name.replace(ieNSPrefix, '');\n        res.push(attr);\n      }\n    }\n    return res;\n  }\n\n  function checkForAliasModel(el, value) {\n    var _el = el;\n    while (_el) {\n      if (_el.for && _el.alias === value) {\n        warn$2(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\">: \" + \"You are binding v-model directly to a v-for iteration alias. \" + \"This will not be able to modify the v-for source array because \" + \"writing to the alias is like modifying a function local variable. \" + \"Consider using an array of objects and use v-model on an object property instead.\");\n      }\n      _el = _el.parent;\n    }\n  }\n\n  /*  */\n\n  var isStaticKey;\n  var isPlatformReservedTag;\n\n  var genStaticKeysCached = cached(genStaticKeys$1);\n\n  /**\n   * Goal of the optimizer: walk the generated template AST tree\n   * and detect sub-trees that are purely static, i.e. parts of\n   * the DOM that never needs to change.\n   *\n   * Once we detect these sub-trees, we can:\n   *\n   * 1. Hoist them into constants, so that we no longer need to\n   *    create fresh nodes for them on each re-render;\n   * 2. Completely skip them in the patching process.\n   */\n  function optimize(root, options) {\n    if (!root) {\n      return;\n    }\n    isStaticKey = genStaticKeysCached(options.staticKeys || '');\n    isPlatformReservedTag = options.isReservedTag || no;\n    // first pass: mark all non-static nodes.\n    markStatic$1(root);\n    // second pass: mark static roots.\n    markStaticRoots(root, false);\n  }\n\n  function genStaticKeys$1(keys) {\n    return makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs' + (keys ? ',' + keys : ''));\n  }\n\n  function markStatic$1(node) {\n    node.static = isStatic(node);\n    if (node.type === 1) {\n      // do not make component slot content static. this avoids\n      // 1. components not able to mutate slot nodes\n      // 2. static slot content fails for hot-reloading\n      if (!isPlatformReservedTag(node.tag) && node.tag !== 'slot' && node.attrsMap['inline-template'] == null) {\n        return;\n      }\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        var child = node.children[i];\n        markStatic$1(child);\n        if (!child.static) {\n          node.static = false;\n        }\n      }\n      if (node.ifConditions) {\n        for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n          var block = node.ifConditions[i$1].block;\n          markStatic$1(block);\n          if (!block.static) {\n            node.static = false;\n          }\n        }\n      }\n    }\n  }\n\n  function markStaticRoots(node, isInFor) {\n    if (node.type === 1) {\n      if (node.static || node.once) {\n        node.staticInFor = isInFor;\n      }\n      // For a node to qualify as a static root, it should have children that\n      // are not just static text. Otherwise the cost of hoisting out will\n      // outweigh the benefits and it's better off to just always render it fresh.\n      if (node.static && node.children.length && !(node.children.length === 1 && node.children[0].type === 3)) {\n        node.staticRoot = true;\n        return;\n      } else {\n        node.staticRoot = false;\n      }\n      if (node.children) {\n        for (var i = 0, l = node.children.length; i < l; i++) {\n          markStaticRoots(node.children[i], isInFor || !!node.for);\n        }\n      }\n      if (node.ifConditions) {\n        for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n          markStaticRoots(node.ifConditions[i$1].block, isInFor);\n        }\n      }\n    }\n  }\n\n  function isStatic(node) {\n    if (node.type === 2) {\n      // expression\n      return false;\n    }\n    if (node.type === 3) {\n      // text\n      return true;\n    }\n    return !!(node.pre || !node.hasBindings && // no dynamic bindings\n    !node.if && !node.for && // not v-if or v-for or v-else\n    !isBuiltInTag(node.tag) && // not a built-in\n    isPlatformReservedTag(node.tag) && // not a component\n    !isDirectChildOfTemplateFor(node) && Object.keys(node).every(isStaticKey));\n  }\n\n  function isDirectChildOfTemplateFor(node) {\n    while (node.parent) {\n      node = node.parent;\n      if (node.tag !== 'template') {\n        return false;\n      }\n      if (node.for) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /*  */\n\n  var fnExpRE = /^\\s*([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*\\(/;\n  var simplePathRE = /^\\s*[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['.*?']|\\[\".*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*\\s*$/;\n\n  // keyCode aliases\n  var keyCodes = {\n    esc: 27,\n    tab: 9,\n    enter: 13,\n    space: 32,\n    up: 38,\n    left: 37,\n    right: 39,\n    down: 40,\n    'delete': [8, 46]\n  };\n\n  // #4868: modifiers that prevent the execution of the listener\n  // need to explicitly return null so that we can determine whether to remove\n  // the listener for .once\n  var genGuard = function genGuard(condition) {\n    return \"if(\" + condition + \")return null;\";\n  };\n\n  var modifierCode = {\n    stop: '$event.stopPropagation();',\n    prevent: '$event.preventDefault();',\n    self: genGuard(\"$event.target !== $event.currentTarget\"),\n    ctrl: genGuard(\"!$event.ctrlKey\"),\n    shift: genGuard(\"!$event.shiftKey\"),\n    alt: genGuard(\"!$event.altKey\"),\n    meta: genGuard(\"!$event.metaKey\"),\n    left: genGuard(\"'button' in $event && $event.button !== 0\"),\n    middle: genGuard(\"'button' in $event && $event.button !== 1\"),\n    right: genGuard(\"'button' in $event && $event.button !== 2\")\n  };\n\n  function genHandlers(events, isNative, warn) {\n    var res = isNative ? 'nativeOn:{' : 'on:{';\n    for (var name in events) {\n      var handler = events[name];\n      // #5330: warn click.right, since right clicks do not actually fire click events.\n      if (\"development\" !== 'production' && name === 'click' && handler && handler.modifiers && handler.modifiers.right) {\n        warn(\"Use \\\"contextmenu\\\" instead of \\\"click.right\\\" since right clicks \" + \"do not actually fire \\\"click\\\" events.\");\n      }\n      res += \"\\\"\" + name + \"\\\":\" + genHandler(name, handler) + \",\";\n    }\n    return res.slice(0, -1) + '}';\n  }\n\n  function genHandler(name, handler) {\n    if (!handler) {\n      return 'function(){}';\n    }\n\n    if (Array.isArray(handler)) {\n      return \"[\" + handler.map(function (handler) {\n        return genHandler(name, handler);\n      }).join(',') + \"]\";\n    }\n\n    var isMethodPath = simplePathRE.test(handler.value);\n    var isFunctionExpression = fnExpRE.test(handler.value);\n\n    if (!handler.modifiers) {\n      return isMethodPath || isFunctionExpression ? handler.value : \"function($event){\" + handler.value + \"}\"; // inline statement\n    } else {\n      var code = '';\n      var genModifierCode = '';\n      var keys = [];\n      for (var key in handler.modifiers) {\n        if (modifierCode[key]) {\n          genModifierCode += modifierCode[key];\n          // left/right\n          if (keyCodes[key]) {\n            keys.push(key);\n          }\n        } else {\n          keys.push(key);\n        }\n      }\n      if (keys.length) {\n        code += genKeyFilter(keys);\n      }\n      // Make sure modifiers like prevent and stop get executed after key filtering\n      if (genModifierCode) {\n        code += genModifierCode;\n      }\n      var handlerCode = isMethodPath ? handler.value + '($event)' : isFunctionExpression ? \"(\" + handler.value + \")($event)\" : handler.value;\n      return \"function($event){\" + code + handlerCode + \"}\";\n    }\n  }\n\n  function genKeyFilter(keys) {\n    return \"if(!('button' in $event)&&\" + keys.map(genFilterCode).join('&&') + \")return null;\";\n  }\n\n  function genFilterCode(key) {\n    var keyVal = parseInt(key, 10);\n    if (keyVal) {\n      return \"$event.keyCode!==\" + keyVal;\n    }\n    var alias = keyCodes[key];\n    return \"_k($event.keyCode,\" + JSON.stringify(key) + (alias ? ',' + JSON.stringify(alias) : '') + \")\";\n  }\n\n  /*  */\n\n  function on(el, dir) {\n    if (\"development\" !== 'production' && dir.modifiers) {\n      warn(\"v-on without argument does not support modifiers.\");\n    }\n    el.wrapListeners = function (code) {\n      return \"_g(\" + code + \",\" + dir.value + \")\";\n    };\n  }\n\n  /*  */\n\n  function bind$1(el, dir) {\n    el.wrapData = function (code) {\n      return \"_b(\" + code + \",'\" + el.tag + \"',\" + dir.value + \",\" + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + \")\";\n    };\n  }\n\n  /*  */\n\n  var baseDirectives = {\n    on: on,\n    bind: bind$1,\n    cloak: noop\n  };\n\n  /*  */\n\n  var CodegenState = function CodegenState(options) {\n    this.options = options;\n    this.warn = options.warn || baseWarn;\n    this.transforms = pluckModuleFunction(options.modules, 'transformCode');\n    this.dataGenFns = pluckModuleFunction(options.modules, 'genData');\n    this.directives = extend(extend({}, baseDirectives), options.directives);\n    var isReservedTag = options.isReservedTag || no;\n    this.maybeComponent = function (el) {\n      return !isReservedTag(el.tag);\n    };\n    this.onceId = 0;\n    this.staticRenderFns = [];\n  };\n\n  function generate(ast, options) {\n    var state = new CodegenState(options);\n    var code = ast ? genElement(ast, state) : '_c(\"div\")';\n    return {\n      render: \"with(this){return \" + code + \"}\",\n      staticRenderFns: state.staticRenderFns\n    };\n  }\n\n  function genElement(el, state) {\n    if (el.staticRoot && !el.staticProcessed) {\n      return genStatic(el, state);\n    } else if (el.once && !el.onceProcessed) {\n      return genOnce(el, state);\n    } else if (el.for && !el.forProcessed) {\n      return genFor(el, state);\n    } else if (el.if && !el.ifProcessed) {\n      return genIf(el, state);\n    } else if (el.tag === 'template' && !el.slotTarget) {\n      return genChildren(el, state) || 'void 0';\n    } else if (el.tag === 'slot') {\n      return genSlot(el, state);\n    } else {\n      // component or element\n      var code;\n      if (el.component) {\n        code = genComponent(el.component, el, state);\n      } else {\n        var data = el.plain ? undefined : genData$2(el, state);\n\n        var children = el.inlineTemplate ? null : genChildren(el, state, true);\n        code = \"_c('\" + el.tag + \"'\" + (data ? \",\" + data : '') + (children ? \",\" + children : '') + \")\";\n      }\n      // module transforms\n      for (var i = 0; i < state.transforms.length; i++) {\n        code = state.transforms[i](el, code);\n      }\n      return code;\n    }\n  }\n\n  // hoist static sub-trees out\n  function genStatic(el, state) {\n    el.staticProcessed = true;\n    state.staticRenderFns.push(\"with(this){return \" + genElement(el, state) + \"}\");\n    return \"_m(\" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\";\n  }\n\n  // v-once\n  function genOnce(el, state) {\n    el.onceProcessed = true;\n    if (el.if && !el.ifProcessed) {\n      return genIf(el, state);\n    } else if (el.staticInFor) {\n      var key = '';\n      var parent = el.parent;\n      while (parent) {\n        if (parent.for) {\n          key = parent.key;\n          break;\n        }\n        parent = parent.parent;\n      }\n      if (!key) {\n        \"development\" !== 'production' && state.warn(\"v-once can only be used inside v-for that is keyed. \");\n        return genElement(el, state);\n      }\n      return \"_o(\" + genElement(el, state) + \",\" + state.onceId++ + (key ? \",\" + key : \"\") + \")\";\n    } else {\n      return genStatic(el, state);\n    }\n  }\n\n  function genIf(el, state, altGen, altEmpty) {\n    el.ifProcessed = true; // avoid recursion\n    return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty);\n  }\n\n  function genIfConditions(conditions, state, altGen, altEmpty) {\n    if (!conditions.length) {\n      return altEmpty || '_e()';\n    }\n\n    var condition = conditions.shift();\n    if (condition.exp) {\n      return \"(\" + condition.exp + \")?\" + genTernaryExp(condition.block) + \":\" + genIfConditions(conditions, state, altGen, altEmpty);\n    } else {\n      return \"\" + genTernaryExp(condition.block);\n    }\n\n    // v-if with v-once should generate code like (a)?_m(0):_m(1)\n    function genTernaryExp(el) {\n      return altGen ? altGen(el, state) : el.once ? genOnce(el, state) : genElement(el, state);\n    }\n  }\n\n  function genFor(el, state, altGen, altHelper) {\n    var exp = el.for;\n    var alias = el.alias;\n    var iterator1 = el.iterator1 ? \",\" + el.iterator1 : '';\n    var iterator2 = el.iterator2 ? \",\" + el.iterator2 : '';\n\n    if (\"development\" !== 'production' && state.maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key) {\n      state.warn(\"<\" + el.tag + \" v-for=\\\"\" + alias + \" in \" + exp + \"\\\">: component lists rendered with \" + \"v-for should have explicit keys. \" + \"See https://vuejs.org/guide/list.html#key for more info.\", true /* tip */\n      );\n    }\n\n    el.forProcessed = true; // avoid recursion\n    return (altHelper || '_l') + \"((\" + exp + \"),\" + \"function(\" + alias + iterator1 + iterator2 + \"){\" + \"return \" + (altGen || genElement)(el, state) + '})';\n  }\n\n  function genData$2(el, state) {\n    var data = '{';\n\n    // directives first.\n    // directives may mutate the el's other properties before they are generated.\n    var dirs = genDirectives(el, state);\n    if (dirs) {\n      data += dirs + ',';\n    }\n\n    // key\n    if (el.key) {\n      data += \"key:\" + el.key + \",\";\n    }\n    // ref\n    if (el.ref) {\n      data += \"ref:\" + el.ref + \",\";\n    }\n    if (el.refInFor) {\n      data += \"refInFor:true,\";\n    }\n    // pre\n    if (el.pre) {\n      data += \"pre:true,\";\n    }\n    // record original tag name for components using \"is\" attribute\n    if (el.component) {\n      data += \"tag:\\\"\" + el.tag + \"\\\",\";\n    }\n    // module data generation functions\n    for (var i = 0; i < state.dataGenFns.length; i++) {\n      data += state.dataGenFns[i](el);\n    }\n    // attributes\n    if (el.attrs) {\n      data += \"attrs:{\" + genProps(el.attrs) + \"},\";\n    }\n    // DOM props\n    if (el.props) {\n      data += \"domProps:{\" + genProps(el.props) + \"},\";\n    }\n    // event handlers\n    if (el.events) {\n      data += genHandlers(el.events, false, state.warn) + \",\";\n    }\n    if (el.nativeEvents) {\n      data += genHandlers(el.nativeEvents, true, state.warn) + \",\";\n    }\n    // slot target\n    if (el.slotTarget) {\n      data += \"slot:\" + el.slotTarget + \",\";\n    }\n    // scoped slots\n    if (el.scopedSlots) {\n      data += genScopedSlots(el.scopedSlots, state) + \",\";\n    }\n    // component v-model\n    if (el.model) {\n      data += \"model:{value:\" + el.model.value + \",callback:\" + el.model.callback + \",expression:\" + el.model.expression + \"},\";\n    }\n    // inline-template\n    if (el.inlineTemplate) {\n      var inlineTemplate = genInlineTemplate(el, state);\n      if (inlineTemplate) {\n        data += inlineTemplate + \",\";\n      }\n    }\n    data = data.replace(/,$/, '') + '}';\n    // v-bind data wrap\n    if (el.wrapData) {\n      data = el.wrapData(data);\n    }\n    // v-on data wrap\n    if (el.wrapListeners) {\n      data = el.wrapListeners(data);\n    }\n    return data;\n  }\n\n  function genDirectives(el, state) {\n    var dirs = el.directives;\n    if (!dirs) {\n      return;\n    }\n    var res = 'directives:[';\n    var hasRuntime = false;\n    var i, l, dir, needRuntime;\n    for (i = 0, l = dirs.length; i < l; i++) {\n      dir = dirs[i];\n      needRuntime = true;\n      var gen = state.directives[dir.name];\n      if (gen) {\n        // compile-time directive that manipulates AST.\n        // returns true if it also needs a runtime counterpart.\n        needRuntime = !!gen(el, dir, state.warn);\n      }\n      if (needRuntime) {\n        hasRuntime = true;\n        res += \"{name:\\\"\" + dir.name + \"\\\",rawName:\\\"\" + dir.rawName + \"\\\"\" + (dir.value ? \",value:(\" + dir.value + \"),expression:\" + JSON.stringify(dir.value) : '') + (dir.arg ? \",arg:\\\"\" + dir.arg + \"\\\"\" : '') + (dir.modifiers ? \",modifiers:\" + JSON.stringify(dir.modifiers) : '') + \"},\";\n      }\n    }\n    if (hasRuntime) {\n      return res.slice(0, -1) + ']';\n    }\n  }\n\n  function genInlineTemplate(el, state) {\n    var ast = el.children[0];\n    if (\"development\" !== 'production' && (el.children.length > 1 || ast.type !== 1)) {\n      state.warn('Inline-template components must have exactly one child element.');\n    }\n    if (ast.type === 1) {\n      var inlineRenderFns = generate(ast, state.options);\n      return \"inlineTemplate:{render:function(){\" + inlineRenderFns.render + \"},staticRenderFns:[\" + inlineRenderFns.staticRenderFns.map(function (code) {\n        return \"function(){\" + code + \"}\";\n      }).join(',') + \"]}\";\n    }\n  }\n\n  function genScopedSlots(slots, state) {\n    return \"scopedSlots:_u([\" + Object.keys(slots).map(function (key) {\n      return genScopedSlot(key, slots[key], state);\n    }).join(',') + \"])\";\n  }\n\n  function genScopedSlot(key, el, state) {\n    if (el.for && !el.forProcessed) {\n      return genForScopedSlot(key, el, state);\n    }\n    return \"{key:\" + key + \",fn:function(\" + String(el.attrsMap.scope) + \"){\" + \"return \" + (el.tag === 'template' ? genChildren(el, state) || 'void 0' : genElement(el, state)) + \"}}\";\n  }\n\n  function genForScopedSlot(key, el, state) {\n    var exp = el.for;\n    var alias = el.alias;\n    var iterator1 = el.iterator1 ? \",\" + el.iterator1 : '';\n    var iterator2 = el.iterator2 ? \",\" + el.iterator2 : '';\n    el.forProcessed = true; // avoid recursion\n    return \"_l((\" + exp + \"),\" + \"function(\" + alias + iterator1 + iterator2 + \"){\" + \"return \" + genScopedSlot(key, el, state) + '})';\n  }\n\n  function genChildren(el, state, checkSkip, altGenElement, altGenNode) {\n    var children = el.children;\n    if (children.length) {\n      var el$1 = children[0];\n      // optimize single v-for\n      if (children.length === 1 && el$1.for && el$1.tag !== 'template' && el$1.tag !== 'slot') {\n        return (altGenElement || genElement)(el$1, state);\n      }\n      var normalizationType = checkSkip ? getNormalizationType(children, state.maybeComponent) : 0;\n      var gen = altGenNode || genNode;\n      return \"[\" + children.map(function (c) {\n        return gen(c, state);\n      }).join(',') + \"]\" + (normalizationType ? \",\" + normalizationType : '');\n    }\n  }\n\n  // determine the normalization needed for the children array.\n  // 0: no normalization needed\n  // 1: simple normalization needed (possible 1-level deep nested array)\n  // 2: full normalization needed\n  function getNormalizationType(children, maybeComponent) {\n    var res = 0;\n    for (var i = 0; i < children.length; i++) {\n      var el = children[i];\n      if (el.type !== 1) {\n        continue;\n      }\n      if (needsNormalization(el) || el.ifConditions && el.ifConditions.some(function (c) {\n        return needsNormalization(c.block);\n      })) {\n        res = 2;\n        break;\n      }\n      if (maybeComponent(el) || el.ifConditions && el.ifConditions.some(function (c) {\n        return maybeComponent(c.block);\n      })) {\n        res = 1;\n      }\n    }\n    return res;\n  }\n\n  function needsNormalization(el) {\n    return el.for !== undefined || el.tag === 'template' || el.tag === 'slot';\n  }\n\n  function genNode(node, state) {\n    if (node.type === 1) {\n      return genElement(node, state);\n    }if (node.type === 3 && node.isComment) {\n      return genComment(node);\n    } else {\n      return genText(node);\n    }\n  }\n\n  function genText(text) {\n    return \"_v(\" + (text.type === 2 ? text.expression // no need for () because already wrapped in _s()\n    : transformSpecialNewlines(JSON.stringify(text.text))) + \")\";\n  }\n\n  function genComment(comment) {\n    return \"_e('\" + comment.text + \"')\";\n  }\n\n  function genSlot(el, state) {\n    var slotName = el.slotName || '\"default\"';\n    var children = genChildren(el, state);\n    var res = \"_t(\" + slotName + (children ? \",\" + children : '');\n    var attrs = el.attrs && \"{\" + el.attrs.map(function (a) {\n      return camelize(a.name) + \":\" + a.value;\n    }).join(',') + \"}\";\n    var bind$$1 = el.attrsMap['v-bind'];\n    if ((attrs || bind$$1) && !children) {\n      res += \",null\";\n    }\n    if (attrs) {\n      res += \",\" + attrs;\n    }\n    if (bind$$1) {\n      res += (attrs ? '' : ',null') + \",\" + bind$$1;\n    }\n    return res + ')';\n  }\n\n  // componentName is el.component, take it as argument to shun flow's pessimistic refinement\n  function genComponent(componentName, el, state) {\n    var children = el.inlineTemplate ? null : genChildren(el, state, true);\n    return \"_c(\" + componentName + \",\" + genData$2(el, state) + (children ? \",\" + children : '') + \")\";\n  }\n\n  function genProps(props) {\n    var res = '';\n    for (var i = 0; i < props.length; i++) {\n      var prop = props[i];\n      res += \"\\\"\" + prop.name + \"\\\":\" + transformSpecialNewlines(prop.value) + \",\";\n    }\n    return res.slice(0, -1);\n  }\n\n  // #3895, #4268\n  function transformSpecialNewlines(text) {\n    return text.replace(/\\u2028/g, '\\\\u2028').replace(/\\u2029/g, '\\\\u2029');\n  }\n\n  /*  */\n\n  // these keywords should not appear inside expressions, but operators like\n  // typeof, instanceof and in are allowed\n  var prohibitedKeywordRE = new RegExp('\\\\b' + ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' + 'super,throw,while,yield,delete,export,import,return,switch,default,' + 'extends,finally,continue,debugger,function,arguments').split(',').join('\\\\b|\\\\b') + '\\\\b');\n\n  // these unary operators should not be used as property/method names\n  var unaryOperatorsRE = new RegExp('\\\\b' + 'delete,typeof,void'.split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') + '\\\\s*\\\\([^\\\\)]*\\\\)');\n\n  // check valid identifier for v-for\n  var identRE = /[A-Za-z_$][\\w$]*/;\n\n  // strip strings in expressions\n  var stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n\n  // detect problematic expressions in a template\n  function detectErrors(ast) {\n    var errors = [];\n    if (ast) {\n      checkNode(ast, errors);\n    }\n    return errors;\n  }\n\n  function checkNode(node, errors) {\n    if (node.type === 1) {\n      for (var name in node.attrsMap) {\n        if (dirRE.test(name)) {\n          var value = node.attrsMap[name];\n          if (value) {\n            if (name === 'v-for') {\n              checkFor(node, \"v-for=\\\"\" + value + \"\\\"\", errors);\n            } else if (onRE.test(name)) {\n              checkEvent(value, name + \"=\\\"\" + value + \"\\\"\", errors);\n            } else {\n              checkExpression(value, name + \"=\\\"\" + value + \"\\\"\", errors);\n            }\n          }\n        }\n      }\n      if (node.children) {\n        for (var i = 0; i < node.children.length; i++) {\n          checkNode(node.children[i], errors);\n        }\n      }\n    } else if (node.type === 2) {\n      checkExpression(node.expression, node.text, errors);\n    }\n  }\n\n  function checkEvent(exp, text, errors) {\n    var stipped = exp.replace(stripStringRE, '');\n    var keywordMatch = stipped.match(unaryOperatorsRE);\n    if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {\n      errors.push(\"avoid using JavaScript unary operator as property name: \" + \"\\\"\" + keywordMatch[0] + \"\\\" in expression \" + text.trim());\n    }\n    checkExpression(exp, text, errors);\n  }\n\n  function checkFor(node, text, errors) {\n    checkExpression(node.for || '', text, errors);\n    checkIdentifier(node.alias, 'v-for alias', text, errors);\n    checkIdentifier(node.iterator1, 'v-for iterator', text, errors);\n    checkIdentifier(node.iterator2, 'v-for iterator', text, errors);\n  }\n\n  function checkIdentifier(ident, type, text, errors) {\n    if (typeof ident === 'string' && !identRE.test(ident)) {\n      errors.push(\"invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + text.trim());\n    }\n  }\n\n  function checkExpression(exp, text, errors) {\n    try {\n      new Function(\"return \" + exp);\n    } catch (e) {\n      var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n      if (keywordMatch) {\n        errors.push(\"avoid using JavaScript keyword as property name: \" + \"\\\"\" + keywordMatch[0] + \"\\\" in expression \" + text.trim());\n      } else {\n        errors.push(\"invalid expression: \" + text.trim());\n      }\n    }\n  }\n\n  /*  */\n\n  function createFunction(code, errors) {\n    try {\n      return new Function(code);\n    } catch (err) {\n      errors.push({ err: err, code: code });\n      return noop;\n    }\n  }\n\n  function createCompileToFunctionFn(compile) {\n    var cache = Object.create(null);\n\n    return function compileToFunctions(template, options, vm) {\n      options = options || {};\n\n      /* istanbul ignore if */\n      {\n        // detect possible CSP restriction\n        try {\n          new Function('return 1');\n        } catch (e) {\n          if (e.toString().match(/unsafe-eval|CSP/)) {\n            warn('It seems you are using the standalone build of Vue.js in an ' + 'environment with Content Security Policy that prohibits unsafe-eval. ' + 'The template compiler cannot work in this environment. Consider ' + 'relaxing the policy to allow unsafe-eval or pre-compiling your ' + 'templates into render functions.');\n          }\n        }\n      }\n\n      // check cache\n      var key = options.delimiters ? String(options.delimiters) + template : template;\n      if (cache[key]) {\n        return cache[key];\n      }\n\n      // compile\n      var compiled = compile(template, options);\n\n      // check compilation errors/tips\n      {\n        if (compiled.errors && compiled.errors.length) {\n          warn(\"Error compiling template:\\n\\n\" + template + \"\\n\\n\" + compiled.errors.map(function (e) {\n            return \"- \" + e;\n          }).join('\\n') + '\\n', vm);\n        }\n        if (compiled.tips && compiled.tips.length) {\n          compiled.tips.forEach(function (msg) {\n            return tip(msg, vm);\n          });\n        }\n      }\n\n      // turn code into functions\n      var res = {};\n      var fnGenErrors = [];\n      res.render = createFunction(compiled.render, fnGenErrors);\n      res.staticRenderFns = compiled.staticRenderFns.map(function (code) {\n        return createFunction(code, fnGenErrors);\n      });\n\n      // check function generation errors.\n      // this should only happen if there is a bug in the compiler itself.\n      // mostly for codegen development use\n      /* istanbul ignore if */\n      {\n        if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\n          warn(\"Failed to generate render function:\\n\\n\" + fnGenErrors.map(function (ref) {\n            var err = ref.err;\n            var code = ref.code;\n\n            return err.toString() + \" in\\n\\n\" + code + \"\\n\";\n          }).join('\\n'), vm);\n        }\n      }\n\n      return cache[key] = res;\n    };\n  }\n\n  /*  */\n\n  function createCompilerCreator(baseCompile) {\n    return function createCompiler(baseOptions) {\n      function compile(template, options) {\n        var finalOptions = Object.create(baseOptions);\n        var errors = [];\n        var tips = [];\n        finalOptions.warn = function (msg, tip) {\n          (tip ? tips : errors).push(msg);\n        };\n\n        if (options) {\n          // merge custom modules\n          if (options.modules) {\n            finalOptions.modules = (baseOptions.modules || []).concat(options.modules);\n          }\n          // merge custom directives\n          if (options.directives) {\n            finalOptions.directives = extend(Object.create(baseOptions.directives), options.directives);\n          }\n          // copy other options\n          for (var key in options) {\n            if (key !== 'modules' && key !== 'directives') {\n              finalOptions[key] = options[key];\n            }\n          }\n        }\n\n        var compiled = baseCompile(template, finalOptions);\n        {\n          errors.push.apply(errors, detectErrors(compiled.ast));\n        }\n        compiled.errors = errors;\n        compiled.tips = tips;\n        return compiled;\n      }\n\n      return {\n        compile: compile,\n        compileToFunctions: createCompileToFunctionFn(compile)\n      };\n    };\n  }\n\n  /*  */\n\n  // `createCompilerCreator` allows creating compilers that use alternative\n  // parser/optimizer/codegen, e.g the SSR optimizing compiler.\n  // Here we just export a default compiler using the default parts.\n  var createCompiler = createCompilerCreator(function baseCompile(template, options) {\n    var ast = parse(template.trim(), options);\n    optimize(ast, options);\n    var code = generate(ast, options);\n    return {\n      ast: ast,\n      render: code.render,\n      staticRenderFns: code.staticRenderFns\n    };\n  });\n\n  /*  */\n\n  var ref$1 = createCompiler(baseOptions);\n  var compileToFunctions = ref$1.compileToFunctions;\n\n  /*  */\n\n  var idToTemplate = cached(function (id) {\n    var el = query(id);\n    return el && el.innerHTML;\n  });\n\n  var mount = Vue$3.prototype.$mount;\n  Vue$3.prototype.$mount = function (el, hydrating) {\n    el = el && query(el);\n\n    /* istanbul ignore if */\n    if (el === document.body || el === document.documentElement) {\n      \"development\" !== 'production' && warn(\"Do not mount Vue to <html> or <body> - mount to normal elements instead.\");\n      return this;\n    }\n\n    var options = this.$options;\n    // resolve template/el and convert to render function\n    if (!options.render) {\n      var template = options.template;\n      if (template) {\n        if (typeof template === 'string') {\n          if (template.charAt(0) === '#') {\n            template = idToTemplate(template);\n            /* istanbul ignore if */\n            if (\"development\" !== 'production' && !template) {\n              warn(\"Template element not found or is empty: \" + options.template, this);\n            }\n          }\n        } else if (template.nodeType) {\n          template = template.innerHTML;\n        } else {\n          {\n            warn('invalid template option:' + template, this);\n          }\n          return this;\n        }\n      } else if (el) {\n        template = getOuterHTML(el);\n      }\n      if (template) {\n        /* istanbul ignore if */\n        if (\"development\" !== 'production' && config.performance && mark) {\n          mark('compile');\n        }\n\n        var ref = compileToFunctions(template, {\n          shouldDecodeNewlines: shouldDecodeNewlines,\n          delimiters: options.delimiters,\n          comments: options.comments\n        }, this);\n        var render = ref.render;\n        var staticRenderFns = ref.staticRenderFns;\n        options.render = render;\n        options.staticRenderFns = staticRenderFns;\n\n        /* istanbul ignore if */\n        if (\"development\" !== 'production' && config.performance && mark) {\n          mark('compile end');\n          measure(this._name + \" compile\", 'compile', 'compile end');\n        }\n      }\n    }\n    return mount.call(this, el, hydrating);\n  };\n\n  /**\n   * Get outerHTML of elements, taking care\n   * of SVG elements in IE as well.\n   */\n  function getOuterHTML(el) {\n    if (el.outerHTML) {\n      return el.outerHTML;\n    } else {\n      var container = document.createElement('div');\n      container.appendChild(el.cloneNode(true));\n      return container.innerHTML;\n    }\n  }\n\n  Vue$3.compile = compileToFunctions;\n\n  return Vue$3;\n});\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdnVlQDIuNC4xLmpzPzU5YzkiXSwibmFtZXMiOlsiZ2xvYmFsIiwiZmFjdG9yeSIsImV4cG9ydHMiLCJtb2R1bGUiLCJWdWUiLCJpc1VuZGVmIiwidiIsInVuZGVmaW5lZCIsImlzRGVmIiwiaXNUcnVlIiwiaXNGYWxzZSIsImlzUHJpbWl0aXZlIiwidmFsdWUiLCJpc09iamVjdCIsIm9iaiIsIl90b1N0cmluZyIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiaXNQbGFpbk9iamVjdCIsImNhbGwiLCJpc1JlZ0V4cCIsImlzVmFsaWRBcnJheUluZGV4IiwidmFsIiwibiIsInBhcnNlRmxvYXQiLCJNYXRoIiwiZmxvb3IiLCJpc0Zpbml0ZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJTdHJpbmciLCJ0b051bWJlciIsImlzTmFOIiwibWFrZU1hcCIsInN0ciIsImV4cGVjdHNMb3dlckNhc2UiLCJtYXAiLCJjcmVhdGUiLCJsaXN0Iiwic3BsaXQiLCJpIiwibGVuZ3RoIiwidG9Mb3dlckNhc2UiLCJpc0J1aWx0SW5UYWciLCJpc1Jlc2VydmVkQXR0cmlidXRlIiwicmVtb3ZlIiwiYXJyIiwiaXRlbSIsImluZGV4IiwiaW5kZXhPZiIsInNwbGljZSIsImhhc093blByb3BlcnR5IiwiaGFzT3duIiwia2V5IiwiY2FjaGVkIiwiZm4iLCJjYWNoZSIsImNhY2hlZEZuIiwiaGl0IiwiY2FtZWxpemVSRSIsImNhbWVsaXplIiwicmVwbGFjZSIsIl8iLCJjIiwidG9VcHBlckNhc2UiLCJjYXBpdGFsaXplIiwiY2hhckF0Iiwic2xpY2UiLCJoeXBoZW5hdGVSRSIsImh5cGhlbmF0ZSIsImJpbmQiLCJjdHgiLCJib3VuZEZuIiwiYSIsImwiLCJhcmd1bWVudHMiLCJhcHBseSIsIl9sZW5ndGgiLCJ0b0FycmF5Iiwic3RhcnQiLCJyZXQiLCJBcnJheSIsImV4dGVuZCIsInRvIiwiX2Zyb20iLCJ0b09iamVjdCIsInJlcyIsIm5vb3AiLCJiIiwibm8iLCJpZGVudGl0eSIsImdlblN0YXRpY0tleXMiLCJtb2R1bGVzIiwicmVkdWNlIiwia2V5cyIsIm0iLCJjb25jYXQiLCJzdGF0aWNLZXlzIiwiam9pbiIsImxvb3NlRXF1YWwiLCJpc09iamVjdEEiLCJpc09iamVjdEIiLCJlIiwibG9vc2VJbmRleE9mIiwib25jZSIsImNhbGxlZCIsIlNTUl9BVFRSIiwiQVNTRVRfVFlQRVMiLCJMSUZFQ1lDTEVfSE9PS1MiLCJjb25maWciLCJvcHRpb25NZXJnZVN0cmF0ZWdpZXMiLCJzaWxlbnQiLCJwcm9kdWN0aW9uVGlwIiwiZGV2dG9vbHMiLCJwZXJmb3JtYW5jZSIsImVycm9ySGFuZGxlciIsIndhcm5IYW5kbGVyIiwiaWdub3JlZEVsZW1lbnRzIiwia2V5Q29kZXMiLCJpc1Jlc2VydmVkVGFnIiwiaXNSZXNlcnZlZEF0dHIiLCJpc1Vua25vd25FbGVtZW50IiwiZ2V0VGFnTmFtZXNwYWNlIiwicGFyc2VQbGF0Zm9ybVRhZ05hbWUiLCJtdXN0VXNlUHJvcCIsIl9saWZlY3ljbGVIb29rcyIsImVtcHR5T2JqZWN0IiwiZnJlZXplIiwiaXNSZXNlcnZlZCIsImNoYXJDb2RlQXQiLCJkZWYiLCJlbnVtZXJhYmxlIiwiZGVmaW5lUHJvcGVydHkiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImJhaWxSRSIsInBhcnNlUGF0aCIsInBhdGgiLCJ0ZXN0Iiwic2VnbWVudHMiLCJ3YXJuIiwidGlwIiwiZm9ybWF0Q29tcG9uZW50TmFtZSIsImhhc0NvbnNvbGUiLCJjb25zb2xlIiwiY2xhc3NpZnlSRSIsImNsYXNzaWZ5IiwibXNnIiwidm0iLCJ0cmFjZSIsImdlbmVyYXRlQ29tcG9uZW50VHJhY2UiLCJlcnJvciIsImluY2x1ZGVGaWxlIiwiJHJvb3QiLCJuYW1lIiwib3B0aW9ucyIsIl9pc1Z1ZSIsIiRvcHRpb25zIiwiX2NvbXBvbmVudFRhZyIsImZpbGUiLCJfX2ZpbGUiLCJtYXRjaCIsInJlcGVhdCIsIiRwYXJlbnQiLCJ0cmVlIiwiY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlIiwibGFzdCIsImNvbnN0cnVjdG9yIiwicHVzaCIsImlzQXJyYXkiLCJoYW5kbGVFcnJvciIsImVyciIsImluZm8iLCJpbkJyb3dzZXIiLCJoYXNQcm90byIsIndpbmRvdyIsIlVBIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiaXNJRSIsImlzSUU5IiwiaXNFZGdlIiwiaXNBbmRyb2lkIiwiaXNJT1MiLCJpc0Nocm9tZSIsIm5hdGl2ZVdhdGNoIiwid2F0Y2giLCJzdXBwb3J0c1Bhc3NpdmUiLCJvcHRzIiwiZ2V0IiwiYWRkRXZlbnRMaXN0ZW5lciIsIl9pc1NlcnZlciIsImlzU2VydmVyUmVuZGVyaW5nIiwiZW52IiwiVlVFX0VOViIsIl9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX18iLCJpc05hdGl2ZSIsIkN0b3IiLCJoYXNTeW1ib2wiLCJTeW1ib2wiLCJSZWZsZWN0Iiwib3duS2V5cyIsIm5leHRUaWNrIiwiY2FsbGJhY2tzIiwicGVuZGluZyIsInRpbWVyRnVuYyIsIm5leHRUaWNrSGFuZGxlciIsImNvcGllcyIsIlByb21pc2UiLCJwIiwicmVzb2x2ZSIsImxvZ0Vycm9yIiwidGhlbiIsImNhdGNoIiwic2V0VGltZW91dCIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJjb3VudGVyIiwib2JzZXJ2ZXIiLCJ0ZXh0Tm9kZSIsImRvY3VtZW50IiwiY3JlYXRlVGV4dE5vZGUiLCJvYnNlcnZlIiwiY2hhcmFjdGVyRGF0YSIsImRhdGEiLCJxdWV1ZU5leHRUaWNrIiwiY2IiLCJfcmVzb2x2ZSIsInJlamVjdCIsIl9TZXQiLCJTZXQiLCJzZXQiLCJoYXMiLCJhZGQiLCJjbGVhciIsInVpZCIsIkRlcCIsImlkIiwic3VicyIsImFkZFN1YiIsInN1YiIsInJlbW92ZVN1YiIsImRlcGVuZCIsInRhcmdldCIsImFkZERlcCIsIm5vdGlmeSIsInVwZGF0ZSIsInRhcmdldFN0YWNrIiwicHVzaFRhcmdldCIsIl90YXJnZXQiLCJwb3BUYXJnZXQiLCJwb3AiLCJhcnJheVByb3RvIiwiYXJyYXlNZXRob2RzIiwiZm9yRWFjaCIsIm1ldGhvZCIsIm9yaWdpbmFsIiwibXV0YXRvciIsImFyZ3MiLCJsZW4iLCJyZXN1bHQiLCJvYiIsIl9fb2JfXyIsImluc2VydGVkIiwib2JzZXJ2ZUFycmF5IiwiZGVwIiwiYXJyYXlLZXlzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsIm9ic2VydmVyU3RhdGUiLCJzaG91bGRDb252ZXJ0IiwiT2JzZXJ2ZXIiLCJ2bUNvdW50IiwiYXVnbWVudCIsInByb3RvQXVnbWVudCIsImNvcHlBdWdtZW50Iiwid2FsayIsImRlZmluZVJlYWN0aXZlJCQxIiwiaXRlbXMiLCJzcmMiLCJfX3Byb3RvX18iLCJhc1Jvb3REYXRhIiwiaXNFeHRlbnNpYmxlIiwiY3VzdG9tU2V0dGVyIiwic2hhbGxvdyIsInByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0dGVyIiwic2V0dGVyIiwiY2hpbGRPYiIsInJlYWN0aXZlR2V0dGVyIiwiZGVwZW5kQXJyYXkiLCJyZWFjdGl2ZVNldHRlciIsIm5ld1ZhbCIsIm1heCIsImRlbCIsInN0cmF0cyIsImVsIiwicHJvcHNEYXRhIiwicGFyZW50IiwiY2hpbGQiLCJkZWZhdWx0U3RyYXQiLCJtZXJnZURhdGEiLCJmcm9tIiwidG9WYWwiLCJmcm9tVmFsIiwibWVyZ2VEYXRhT3JGbiIsInBhcmVudFZhbCIsImNoaWxkVmFsIiwibWVyZ2VkRGF0YUZuIiwibWVyZ2VkSW5zdGFuY2VEYXRhRm4iLCJpbnN0YW5jZURhdGEiLCJkZWZhdWx0RGF0YSIsIm1lcmdlSG9vayIsImhvb2siLCJtZXJnZUFzc2V0cyIsInR5cGUiLCJwcm9wcyIsIm1ldGhvZHMiLCJpbmplY3QiLCJjb21wdXRlZCIsInByb3ZpZGUiLCJjaGVja0NvbXBvbmVudHMiLCJjb21wb25lbnRzIiwibG93ZXIiLCJub3JtYWxpemVQcm9wcyIsIm5vcm1hbGl6ZUluamVjdCIsIm5vcm1hbGl6ZWQiLCJub3JtYWxpemVEaXJlY3RpdmVzIiwiZGlycyIsImRpcmVjdGl2ZXMiLCJtZXJnZU9wdGlvbnMiLCJleHRlbmRzRnJvbSIsImV4dGVuZHMiLCJtaXhpbnMiLCJtZXJnZUZpZWxkIiwic3RyYXQiLCJyZXNvbHZlQXNzZXQiLCJ3YXJuTWlzc2luZyIsImFzc2V0cyIsImNhbWVsaXplZElkIiwiUGFzY2FsQ2FzZUlkIiwidmFsaWRhdGVQcm9wIiwicHJvcE9wdGlvbnMiLCJwcm9wIiwiYWJzZW50IiwiaXNUeXBlIiwiQm9vbGVhbiIsImdldFByb3BEZWZhdWx0VmFsdWUiLCJwcmV2U2hvdWxkQ29udmVydCIsImFzc2VydFByb3AiLCJkZWZhdWx0IiwiX3Byb3BzIiwiZ2V0VHlwZSIsInJlcXVpcmVkIiwidmFsaWQiLCJleHBlY3RlZFR5cGVzIiwiYXNzZXJ0ZWRUeXBlIiwiYXNzZXJ0VHlwZSIsImV4cGVjdGVkVHlwZSIsInZhbGlkYXRvciIsInNpbXBsZUNoZWNrUkUiLCJtYXJrIiwibWVhc3VyZSIsInBlcmYiLCJjbGVhck1hcmtzIiwiY2xlYXJNZWFzdXJlcyIsInRhZyIsInN0YXJ0VGFnIiwiZW5kVGFnIiwiaW5pdFByb3h5IiwiYWxsb3dlZEdsb2JhbHMiLCJ3YXJuTm9uUHJlc2VudCIsImhhc1Byb3h5IiwiUHJveHkiLCJpc0J1aWx0SW5Nb2RpZmllciIsImhhc0hhbmRsZXIiLCJpc0FsbG93ZWQiLCJnZXRIYW5kbGVyIiwiaGFuZGxlcnMiLCJyZW5kZXIiLCJfd2l0aFN0cmlwcGVkIiwiX3JlbmRlclByb3h5IiwiVk5vZGUiLCJjaGlsZHJlbiIsInRleHQiLCJlbG0iLCJjb250ZXh0IiwiY29tcG9uZW50T3B0aW9ucyIsImFzeW5jRmFjdG9yeSIsIm5zIiwiZnVuY3Rpb25hbENvbnRleHQiLCJjb21wb25lbnRJbnN0YW5jZSIsInJhdyIsImlzU3RhdGljIiwiaXNSb290SW5zZXJ0IiwiaXNDb21tZW50IiwiaXNDbG9uZWQiLCJpc09uY2UiLCJhc3luY01ldGEiLCJpc0FzeW5jUGxhY2Vob2xkZXIiLCJwcm90b3R5cGVBY2Nlc3NvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiY3JlYXRlRW1wdHlWTm9kZSIsIm5vZGUiLCJjcmVhdGVUZXh0Vk5vZGUiLCJjbG9uZVZOb2RlIiwidm5vZGUiLCJjbG9uZWQiLCJjbG9uZVZOb2RlcyIsInZub2RlcyIsIm5vcm1hbGl6ZUV2ZW50IiwicGFzc2l2ZSIsIm9uY2UkJDEiLCJjYXB0dXJlIiwiY3JlYXRlRm5JbnZva2VyIiwiZm5zIiwiaW52b2tlciIsImFyZ3VtZW50cyQxIiwidXBkYXRlTGlzdGVuZXJzIiwib24iLCJvbGRPbiIsInJlbW92ZSQkMSIsImN1ciIsIm9sZCIsImV2ZW50IiwibWVyZ2VWTm9kZUhvb2siLCJob29rS2V5Iiwib2xkSG9vayIsIndyYXBwZWRIb29rIiwibWVyZ2VkIiwiZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YSIsImF0dHJzIiwiYWx0S2V5Iiwia2V5SW5Mb3dlckNhc2UiLCJjaGVja1Byb3AiLCJoYXNoIiwicHJlc2VydmUiLCJzaW1wbGVOb3JtYWxpemVDaGlsZHJlbiIsIm5vcm1hbGl6ZUNoaWxkcmVuIiwibm9ybWFsaXplQXJyYXlDaGlsZHJlbiIsImlzVGV4dE5vZGUiLCJuZXN0ZWRJbmRleCIsIl9pc1ZMaXN0IiwiZW5zdXJlQ3RvciIsImNvbXAiLCJiYXNlIiwiX19lc01vZHVsZSIsImNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIiLCJyZXNvbHZlQXN5bmNDb21wb25lbnQiLCJiYXNlQ3RvciIsImVycm9yQ29tcCIsInJlc29sdmVkIiwibG9hZGluZyIsImxvYWRpbmdDb21wIiwiY29udGV4dHMiLCJzeW5jIiwiZm9yY2VSZW5kZXIiLCIkZm9yY2VVcGRhdGUiLCJyZWFzb24iLCJjb21wb25lbnQiLCJkZWxheSIsInRpbWVvdXQiLCJnZXRGaXJzdENvbXBvbmVudENoaWxkIiwiaW5pdEV2ZW50cyIsIl9ldmVudHMiLCJfaGFzSG9va0V2ZW50IiwibGlzdGVuZXJzIiwiX3BhcmVudExpc3RlbmVycyIsInVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyIsIiRvbmNlIiwiJG9uIiwicmVtb3ZlJDEiLCIkb2ZmIiwib2xkTGlzdGVuZXJzIiwiZXZlbnRzTWl4aW4iLCJob29rUkUiLCJ0aGlzJDEiLCJpJDEiLCJjYnMiLCIkZW1pdCIsImxvd2VyQ2FzZUV2ZW50IiwicmVzb2x2ZVNsb3RzIiwic2xvdHMiLCJkZWZhdWx0U2xvdCIsInNsb3QiLCJldmVyeSIsImlzV2hpdGVzcGFjZSIsInJlc29sdmVTY29wZWRTbG90cyIsImFjdGl2ZUluc3RhbmNlIiwiaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50IiwiaW5pdExpZmVjeWNsZSIsImFic3RyYWN0IiwiJGNoaWxkcmVuIiwiJHJlZnMiLCJfd2F0Y2hlciIsIl9pbmFjdGl2ZSIsIl9kaXJlY3RJbmFjdGl2ZSIsIl9pc01vdW50ZWQiLCJfaXNEZXN0cm95ZWQiLCJfaXNCZWluZ0Rlc3Ryb3llZCIsImxpZmVjeWNsZU1peGluIiwiX3VwZGF0ZSIsImh5ZHJhdGluZyIsImNhbGxIb29rIiwicHJldkVsIiwiJGVsIiwicHJldlZub2RlIiwiX3Zub2RlIiwicHJldkFjdGl2ZUluc3RhbmNlIiwiX19wYXRjaF9fIiwiX3BhcmVudEVsbSIsIl9yZWZFbG0iLCJfX3Z1ZV9fIiwiJHZub2RlIiwiJGRlc3Ryb3kiLCJ0ZWFyZG93biIsIl93YXRjaGVycyIsIl9kYXRhIiwibW91bnRDb21wb25lbnQiLCJ0ZW1wbGF0ZSIsInVwZGF0ZUNvbXBvbmVudCIsIl9uYW1lIiwiX3VpZCIsIl9yZW5kZXIiLCJXYXRjaGVyIiwidXBkYXRlQ2hpbGRDb21wb25lbnQiLCJwYXJlbnRWbm9kZSIsInJlbmRlckNoaWxkcmVuIiwiaGFzQ2hpbGRyZW4iLCJfcmVuZGVyQ2hpbGRyZW4iLCJzY29wZWRTbG90cyIsIiRzY29wZWRTbG90cyIsIl9wYXJlbnRWbm9kZSIsIiRhdHRycyIsIiRsaXN0ZW5lcnMiLCJwcm9wS2V5cyIsIl9wcm9wS2V5cyIsIiRzbG90cyIsImlzSW5JbmFjdGl2ZVRyZWUiLCJhY3RpdmF0ZUNoaWxkQ29tcG9uZW50IiwiZGlyZWN0IiwiZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50IiwiaiIsIk1BWF9VUERBVEVfQ09VTlQiLCJxdWV1ZSIsImFjdGl2YXRlZENoaWxkcmVuIiwiY2lyY3VsYXIiLCJ3YWl0aW5nIiwiZmx1c2hpbmciLCJyZXNldFNjaGVkdWxlclN0YXRlIiwiZmx1c2hTY2hlZHVsZXJRdWV1ZSIsIndhdGNoZXIiLCJzb3J0IiwicnVuIiwidXNlciIsImV4cHJlc3Npb24iLCJhY3RpdmF0ZWRRdWV1ZSIsInVwZGF0ZWRRdWV1ZSIsImNhbGxBY3RpdmF0ZWRIb29rcyIsImNhbGxVcGRhdGVkSG9va3MiLCJlbWl0IiwicXVldWVBY3RpdmF0ZWRDb21wb25lbnQiLCJxdWV1ZVdhdGNoZXIiLCJ1aWQkMiIsImV4cE9yRm4iLCJkZWVwIiwibGF6eSIsImFjdGl2ZSIsImRpcnR5IiwiZGVwcyIsIm5ld0RlcHMiLCJkZXBJZHMiLCJuZXdEZXBJZHMiLCJ0cmF2ZXJzZSIsImNsZWFudXBEZXBzIiwidG1wIiwib2xkVmFsdWUiLCJldmFsdWF0ZSIsInNlZW5PYmplY3RzIiwiX3RyYXZlcnNlIiwic2VlbiIsImlzQSIsImRlcElkIiwic2hhcmVkUHJvcGVydHlEZWZpbml0aW9uIiwicHJveHkiLCJzb3VyY2VLZXkiLCJwcm94eUdldHRlciIsInByb3h5U2V0dGVyIiwiaW5pdFN0YXRlIiwiaW5pdFByb3BzIiwiaW5pdE1ldGhvZHMiLCJpbml0RGF0YSIsImluaXRDb21wdXRlZCIsImluaXRXYXRjaCIsImNoZWNrT3B0aW9uVHlwZSIsIm9wdGlvbiIsInByb3BzT3B0aW9ucyIsImlzUm9vdCIsImxvb3AiLCJnZXREYXRhIiwiY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyIsIndhdGNoZXJzIiwiX2NvbXB1dGVkV2F0Y2hlcnMiLCJ1c2VyRGVmIiwiZGVmaW5lQ29tcHV0ZWQiLCIkZGF0YSIsImNyZWF0ZUNvbXB1dGVkR2V0dGVyIiwiY29tcHV0ZWRHZXR0ZXIiLCJoYW5kbGVyIiwiY3JlYXRlV2F0Y2hlciIsImtleU9yRm4iLCIkd2F0Y2giLCJzdGF0ZU1peGluIiwiZGF0YURlZiIsInByb3BzRGVmIiwibmV3RGF0YSIsIiRzZXQiLCIkZGVsZXRlIiwiaW1tZWRpYXRlIiwidW53YXRjaEZuIiwiaW5pdFByb3ZpZGUiLCJfcHJvdmlkZWQiLCJpbml0SW5qZWN0aW9ucyIsInJlc29sdmVJbmplY3QiLCJwcm92aWRlS2V5Iiwic291cmNlIiwiY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudCIsIm1lcmdlUHJvcHMiLCJfY29udGV4dCIsImgiLCJkIiwiY3JlYXRlRWxlbWVudCIsImluamVjdGlvbnMiLCJmdW5jdGlvbmFsT3B0aW9ucyIsImNvbXBvbmVudFZOb2RlSG9va3MiLCJpbml0IiwicGFyZW50RWxtIiwicmVmRWxtIiwiY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZSIsIiRtb3VudCIsImtlZXBBbGl2ZSIsIm1vdW50ZWROb2RlIiwicHJlcGF0Y2giLCJvbGRWbm9kZSIsImluc2VydCIsImRlc3Ryb3kiLCJob29rc1RvTWVyZ2UiLCJjcmVhdGVDb21wb25lbnQiLCJfYmFzZSIsImNpZCIsInJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMiLCJtb2RlbCIsInRyYW5zZm9ybU1vZGVsIiwiZnVuY3Rpb25hbCIsIm1lcmdlSG9va3MiLCJ2bm9kZUNvbXBvbmVudE9wdGlvbnMiLCJfaXNDb21wb25lbnQiLCJpbmxpbmVUZW1wbGF0ZSIsInN0YXRpY1JlbmRlckZucyIsImZyb21QYXJlbnQiLCJvdXJzIiwibWVyZ2VIb29rJDEiLCJvbmUiLCJ0d28iLCJjYWxsYmFjayIsIlNJTVBMRV9OT1JNQUxJWkUiLCJBTFdBWVNfTk9STUFMSVpFIiwibm9ybWFsaXphdGlvblR5cGUiLCJhbHdheXNOb3JtYWxpemUiLCJfY3JlYXRlRWxlbWVudCIsImlzIiwiYXBwbHlOUyIsInJlbmRlckxpc3QiLCJyZW5kZXJTbG90IiwiZmFsbGJhY2siLCJiaW5kT2JqZWN0Iiwic2NvcGVkU2xvdEZuIiwic2xvdE5vZGVzIiwiX3JlbmRlcmVkIiwicmVzb2x2ZUZpbHRlciIsImNoZWNrS2V5Q29kZXMiLCJldmVudEtleUNvZGUiLCJidWlsdEluQWxpYXMiLCJiaW5kT2JqZWN0UHJvcHMiLCJhc1Byb3AiLCJpc1N5bmMiLCJkb21Qcm9wcyIsIiRldmVudCIsInJlbmRlclN0YXRpYyIsImlzSW5Gb3IiLCJfc3RhdGljVHJlZXMiLCJtYXJrU3RhdGljIiwibWFya09uY2UiLCJtYXJrU3RhdGljTm9kZSIsImJpbmRPYmplY3RMaXN0ZW5lcnMiLCJleGlzdGluZyIsImluaXRSZW5kZXIiLCJyZW5kZXJDb250ZXh0IiwiX2MiLCIkY3JlYXRlRWxlbWVudCIsInBhcmVudERhdGEiLCJyZW5kZXJNaXhpbiIsIiRuZXh0VGljayIsInJlZiIsInJlbmRlckVycm9yIiwiX28iLCJfbiIsIl9zIiwiX2wiLCJfdCIsIl9xIiwiX2kiLCJfbSIsIl9mIiwiX2siLCJfYiIsIl92IiwiX2UiLCJfdSIsIl9nIiwidWlkJDEiLCJpbml0TWl4aW4iLCJfaW5pdCIsImluaXRJbnRlcm5hbENvbXBvbmVudCIsIl9zZWxmIiwic3VwZXIiLCJzdXBlck9wdGlvbnMiLCJjYWNoZWRTdXBlck9wdGlvbnMiLCJtb2RpZmllZE9wdGlvbnMiLCJyZXNvbHZlTW9kaWZpZWRPcHRpb25zIiwiZXh0ZW5kT3B0aW9ucyIsIm1vZGlmaWVkIiwibGF0ZXN0IiwiZXh0ZW5kZWQiLCJzZWFsZWQiLCJzZWFsZWRPcHRpb25zIiwiZGVkdXBlIiwiVnVlJDMiLCJpbml0VXNlIiwidXNlIiwicGx1Z2luIiwiaW5zdGFsbGVkUGx1Z2lucyIsIl9pbnN0YWxsZWRQbHVnaW5zIiwidW5zaGlmdCIsImluc3RhbGwiLCJpbml0TWl4aW4kMSIsIm1peGluIiwiaW5pdEV4dGVuZCIsIlN1cGVyIiwiU3VwZXJJZCIsImNhY2hlZEN0b3JzIiwiX0N0b3IiLCJTdWIiLCJWdWVDb21wb25lbnQiLCJpbml0UHJvcHMkMSIsImluaXRDb21wdXRlZCQxIiwiQ29tcCIsImluaXRBc3NldFJlZ2lzdGVycyIsImRlZmluaXRpb24iLCJwYXR0ZXJuVHlwZXMiLCJSZWdFeHAiLCJnZXRDb21wb25lbnROYW1lIiwibWF0Y2hlcyIsInBhdHRlcm4iLCJwcnVuZUNhY2hlIiwiY3VycmVudCIsImZpbHRlciIsImNhY2hlZE5vZGUiLCJwcnVuZUNhY2hlRW50cnkiLCJLZWVwQWxpdmUiLCJpbmNsdWRlIiwiZXhjbHVkZSIsImNyZWF0ZWQiLCJkZXN0cm95ZWQiLCJidWlsdEluQ29tcG9uZW50cyIsImluaXRHbG9iYWxBUEkiLCJjb25maWdEZWYiLCJ1dGlsIiwiZGVmaW5lUmVhY3RpdmUiLCJkZWxldGUiLCJzc3JDb250ZXh0IiwidmVyc2lvbiIsImFjY2VwdFZhbHVlIiwiYXR0ciIsImlzRW51bWVyYXRlZEF0dHIiLCJpc0Jvb2xlYW5BdHRyIiwieGxpbmtOUyIsImlzWGxpbmsiLCJnZXRYbGlua1Byb3AiLCJpc0ZhbHN5QXR0clZhbHVlIiwiZ2VuQ2xhc3NGb3JWbm9kZSIsInBhcmVudE5vZGUiLCJjaGlsZE5vZGUiLCJtZXJnZUNsYXNzRGF0YSIsInJlbmRlckNsYXNzIiwic3RhdGljQ2xhc3MiLCJjbGFzcyIsImR5bmFtaWNDbGFzcyIsInN0cmluZ2lmeUNsYXNzIiwic3RyaW5naWZ5QXJyYXkiLCJzdHJpbmdpZnlPYmplY3QiLCJzdHJpbmdpZmllZCIsIm5hbWVzcGFjZU1hcCIsInN2ZyIsIm1hdGgiLCJpc0hUTUxUYWciLCJpc1NWRyIsImlzUHJlVGFnIiwidW5rbm93bkVsZW1lbnRDYWNoZSIsIkhUTUxVbmtub3duRWxlbWVudCIsIkhUTUxFbGVtZW50IiwicXVlcnkiLCJzZWxlY3RlZCIsInF1ZXJ5U2VsZWN0b3IiLCJjcmVhdGVFbGVtZW50JDEiLCJ0YWdOYW1lIiwibXVsdGlwbGUiLCJzZXRBdHRyaWJ1dGUiLCJjcmVhdGVFbGVtZW50TlMiLCJuYW1lc3BhY2UiLCJjcmVhdGVDb21tZW50IiwiaW5zZXJ0QmVmb3JlIiwibmV3Tm9kZSIsInJlZmVyZW5jZU5vZGUiLCJyZW1vdmVDaGlsZCIsImFwcGVuZENoaWxkIiwibmV4dFNpYmxpbmciLCJzZXRUZXh0Q29udGVudCIsInRleHRDb250ZW50Iiwibm9kZU9wcyIsInJlZ2lzdGVyUmVmIiwiaXNSZW1vdmFsIiwicmVmcyIsInJlZkluRm9yIiwiZW1wdHlOb2RlIiwiaG9va3MiLCJzYW1lVm5vZGUiLCJzYW1lSW5wdXRUeXBlIiwidHlwZUEiLCJ0eXBlQiIsImNyZWF0ZUtleVRvT2xkSWR4IiwiYmVnaW5JZHgiLCJlbmRJZHgiLCJjcmVhdGVQYXRjaEZ1bmN0aW9uIiwiYmFja2VuZCIsImVtcHR5Tm9kZUF0IiwiY3JlYXRlUm1DYiIsImNoaWxkRWxtIiwicmVtb3ZlTm9kZSIsImluUHJlIiwiY3JlYXRlRWxtIiwiaW5zZXJ0ZWRWbm9kZVF1ZXVlIiwibmVzdGVkIiwicHJlIiwic2V0U2NvcGUiLCJjcmVhdGVDaGlsZHJlbiIsImludm9rZUNyZWF0ZUhvb2tzIiwiaXNSZWFjdGl2YXRlZCIsImluaXRDb21wb25lbnQiLCJyZWFjdGl2YXRlQ29tcG9uZW50IiwicGVuZGluZ0luc2VydCIsImlzUGF0Y2hhYmxlIiwiaW5uZXJOb2RlIiwidHJhbnNpdGlvbiIsImFjdGl2YXRlIiwicmVmJCQxIiwiYW5jZXN0b3IiLCJfc2NvcGVJZCIsImFkZFZub2RlcyIsInN0YXJ0SWR4IiwiaW52b2tlRGVzdHJveUhvb2siLCJyZW1vdmVWbm9kZXMiLCJjaCIsInJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2siLCJybSIsInVwZGF0ZUNoaWxkcmVuIiwib2xkQ2giLCJuZXdDaCIsInJlbW92ZU9ubHkiLCJvbGRTdGFydElkeCIsIm5ld1N0YXJ0SWR4Iiwib2xkRW5kSWR4Iiwib2xkU3RhcnRWbm9kZSIsIm9sZEVuZFZub2RlIiwibmV3RW5kSWR4IiwibmV3U3RhcnRWbm9kZSIsIm5ld0VuZFZub2RlIiwib2xkS2V5VG9JZHgiLCJpZHhJbk9sZCIsImVsbVRvTW92ZSIsImNhbk1vdmUiLCJwYXRjaFZub2RlIiwiaHlkcmF0ZSIsInBvc3RwYXRjaCIsImludm9rZUluc2VydEhvb2siLCJpbml0aWFsIiwiYmFpbGVkIiwiaXNSZW5kZXJlZE1vZHVsZSIsImFzc2VydE5vZGVNYXRjaCIsImhhc0NoaWxkTm9kZXMiLCJjaGlsZHJlbk1hdGNoIiwiZmlyc3RDaGlsZCIsImNoaWxkTm9kZXMiLCJub2RlVHlwZSIsInBhdGNoIiwiaXNJbml0aWFsUGF0Y2giLCJpc1JlYWxFbGVtZW50IiwiaGFzQXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwib2xkRWxtIiwicGFyZW50RWxtJDEiLCJfbGVhdmVDYiIsInVwZGF0ZURpcmVjdGl2ZXMiLCJ1bmJpbmREaXJlY3RpdmVzIiwiaXNDcmVhdGUiLCJpc0Rlc3Ryb3kiLCJvbGREaXJzIiwibm9ybWFsaXplRGlyZWN0aXZlcyQxIiwibmV3RGlycyIsImRpcnNXaXRoSW5zZXJ0IiwiZGlyc1dpdGhQb3N0cGF0Y2giLCJvbGREaXIiLCJkaXIiLCJjYWxsSG9vayQxIiwiY29tcG9uZW50VXBkYXRlZCIsImNhbGxJbnNlcnQiLCJlbXB0eU1vZGlmaWVycyIsIm1vZGlmaWVycyIsImdldFJhd0Rpck5hbWUiLCJyYXdOYW1lIiwiYmFzZU1vZHVsZXMiLCJ1cGRhdGVBdHRycyIsImluaGVyaXRBdHRycyIsIm9sZEF0dHJzIiwic2V0QXR0ciIsInJlbW92ZUF0dHJpYnV0ZU5TIiwic2V0QXR0cmlidXRlTlMiLCJ1cGRhdGVDbGFzcyIsIm9sZERhdGEiLCJjbHMiLCJ0cmFuc2l0aW9uQ2xhc3MiLCJfdHJhbnNpdGlvbkNsYXNzZXMiLCJfcHJldkNsYXNzIiwia2xhc3MiLCJ2YWxpZERpdmlzaW9uQ2hhclJFIiwicGFyc2VGaWx0ZXJzIiwiZXhwIiwiaW5TaW5nbGUiLCJpbkRvdWJsZSIsImluVGVtcGxhdGVTdHJpbmciLCJpblJlZ2V4IiwiY3VybHkiLCJzcXVhcmUiLCJwYXJlbiIsImxhc3RGaWx0ZXJJbmRleCIsInByZXYiLCJmaWx0ZXJzIiwidHJpbSIsInB1c2hGaWx0ZXIiLCJ3cmFwRmlsdGVyIiwiYmFzZVdhcm4iLCJwbHVja01vZHVsZUZ1bmN0aW9uIiwiYWRkUHJvcCIsImFkZEF0dHIiLCJhZGREaXJlY3RpdmUiLCJhcmciLCJhZGRIYW5kbGVyIiwiaW1wb3J0YW50IiwicHJldmVudCIsImV2ZW50cyIsIm5hdGl2ZSIsIm5hdGl2ZUV2ZW50cyIsIm5ld0hhbmRsZXIiLCJnZXRCaW5kaW5nQXR0ciIsImdldFN0YXRpYyIsImR5bmFtaWNWYWx1ZSIsImdldEFuZFJlbW92ZUF0dHIiLCJzdGF0aWNWYWx1ZSIsImF0dHJzTWFwIiwiYXR0cnNMaXN0IiwiZ2VuQ29tcG9uZW50TW9kZWwiLCJudW1iZXIiLCJiYXNlVmFsdWVFeHByZXNzaW9uIiwidmFsdWVFeHByZXNzaW9uIiwiYXNzaWdubWVudCIsImdlbkFzc2lnbm1lbnRDb2RlIiwibW9kZWxScyIsInBhcnNlTW9kZWwiLCJpZHgiLCJjaHIiLCJpbmRleCQxIiwiZXhwcmVzc2lvblBvcyIsImV4cHJlc3Npb25FbmRQb3MiLCJsYXN0SW5kZXhPZiIsImVvZiIsIm5leHQiLCJpc1N0cmluZ1N0YXJ0IiwicGFyc2VTdHJpbmciLCJwYXJzZUJyYWNrZXQiLCJzdWJzdHJpbmciLCJpbkJyYWNrZXQiLCJzdHJpbmdRdW90ZSIsIndhcm4kMSIsIlJBTkdFX1RPS0VOIiwiQ0hFQ0tCT1hfUkFESU9fVE9LRU4iLCJfd2FybiIsImR5bmFtaWNUeXBlIiwiZ2VuU2VsZWN0IiwiZ2VuQ2hlY2tib3hNb2RlbCIsImdlblJhZGlvTW9kZWwiLCJnZW5EZWZhdWx0TW9kZWwiLCJ2YWx1ZUJpbmRpbmciLCJ0cnVlVmFsdWVCaW5kaW5nIiwiZmFsc2VWYWx1ZUJpbmRpbmciLCJzZWxlY3RlZFZhbCIsImNvZGUiLCJuZWVkQ29tcG9zaXRpb25HdWFyZCIsIm5vcm1hbGl6ZUV2ZW50cyIsInRhcmdldCQxIiwiYWRkJDEiLCJvbGRIYW5kbGVyIiwiZXYiLCJyZW1vdmUkMiIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ1cGRhdGVET01MaXN0ZW5lcnMiLCJpc0NvbXBvbmVudFJvb3QiLCJuYXRpdmVPbiIsInVwZGF0ZURPTVByb3BzIiwib2xkUHJvcHMiLCJfdmFsdWUiLCJzdHJDdXIiLCJzaG91bGRVcGRhdGVWYWx1ZSIsImNoZWNrVmFsIiwiY29tcG9zaW5nIiwiaXNEaXJ0eSIsImlzSW5wdXRDaGFuZ2VkIiwiYWN0aXZlRWxlbWVudCIsIl92TW9kaWZpZXJzIiwicGFyc2VTdHlsZVRleHQiLCJjc3NUZXh0IiwibGlzdERlbGltaXRlciIsInByb3BlcnR5RGVsaW1pdGVyIiwibm9ybWFsaXplU3R5bGVEYXRhIiwic3R5bGUiLCJub3JtYWxpemVTdHlsZUJpbmRpbmciLCJzdGF0aWNTdHlsZSIsImJpbmRpbmdTdHlsZSIsImdldFN0eWxlIiwiY2hlY2tDaGlsZCIsInN0eWxlRGF0YSIsImNzc1ZhclJFIiwiaW1wb3J0YW50UkUiLCJzZXRQcm9wIiwic2V0UHJvcGVydHkiLCJub3JtYWxpemVkTmFtZSIsIm5vcm1hbGl6ZSIsInZlbmRvck5hbWVzIiwiZW1wdHlTdHlsZSIsImNhcE5hbWUiLCJ1cGRhdGVTdHlsZSIsIm9sZFN0YXRpY1N0eWxlIiwib2xkU3R5bGVCaW5kaW5nIiwibm9ybWFsaXplZFN0eWxlIiwib2xkU3R5bGUiLCJuZXdTdHlsZSIsImFkZENsYXNzIiwiY2xhc3NMaXN0IiwiZ2V0QXR0cmlidXRlIiwicmVtb3ZlQ2xhc3MiLCJ0YXIiLCJyZXNvbHZlVHJhbnNpdGlvbiIsImRlZiQkMSIsImNzcyIsImF1dG9Dc3NUcmFuc2l0aW9uIiwiZW50ZXJDbGFzcyIsImVudGVyVG9DbGFzcyIsImVudGVyQWN0aXZlQ2xhc3MiLCJsZWF2ZUNsYXNzIiwibGVhdmVUb0NsYXNzIiwibGVhdmVBY3RpdmVDbGFzcyIsImhhc1RyYW5zaXRpb24iLCJUUkFOU0lUSU9OIiwiQU5JTUFUSU9OIiwidHJhbnNpdGlvblByb3AiLCJ0cmFuc2l0aW9uRW5kRXZlbnQiLCJhbmltYXRpb25Qcm9wIiwiYW5pbWF0aW9uRW5kRXZlbnQiLCJvbnRyYW5zaXRpb25lbmQiLCJvbndlYmtpdHRyYW5zaXRpb25lbmQiLCJvbmFuaW1hdGlvbmVuZCIsIm9ud2Via2l0YW5pbWF0aW9uZW5kIiwicmFmIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibmV4dEZyYW1lIiwiYWRkVHJhbnNpdGlvbkNsYXNzIiwidHJhbnNpdGlvbkNsYXNzZXMiLCJyZW1vdmVUcmFuc2l0aW9uQ2xhc3MiLCJ3aGVuVHJhbnNpdGlvbkVuZHMiLCJnZXRUcmFuc2l0aW9uSW5mbyIsInByb3BDb3VudCIsImVuZGVkIiwiZW5kIiwib25FbmQiLCJ0cmFuc2Zvcm1SRSIsInN0eWxlcyIsImdldENvbXB1dGVkU3R5bGUiLCJ0cmFuc2l0aW9uRGVsYXlzIiwidHJhbnNpdGlvbkR1cmF0aW9ucyIsInRyYW5zaXRpb25UaW1lb3V0IiwiZ2V0VGltZW91dCIsImFuaW1hdGlvbkRlbGF5cyIsImFuaW1hdGlvbkR1cmF0aW9ucyIsImFuaW1hdGlvblRpbWVvdXQiLCJoYXNUcmFuc2Zvcm0iLCJkZWxheXMiLCJkdXJhdGlvbnMiLCJ0b01zIiwicyIsIk51bWJlciIsImVudGVyIiwidG9nZ2xlRGlzcGxheSIsImNhbmNlbGxlZCIsIl9lbnRlckNiIiwiYXBwZWFyQ2xhc3MiLCJhcHBlYXJUb0NsYXNzIiwiYXBwZWFyQWN0aXZlQ2xhc3MiLCJiZWZvcmVFbnRlciIsImFmdGVyRW50ZXIiLCJlbnRlckNhbmNlbGxlZCIsImJlZm9yZUFwcGVhciIsImFwcGVhciIsImFmdGVyQXBwZWFyIiwiYXBwZWFyQ2FuY2VsbGVkIiwiZHVyYXRpb24iLCJ0cmFuc2l0aW9uTm9kZSIsImlzQXBwZWFyIiwic3RhcnRDbGFzcyIsImFjdGl2ZUNsYXNzIiwidG9DbGFzcyIsImJlZm9yZUVudGVySG9vayIsImVudGVySG9vayIsImFmdGVyRW50ZXJIb29rIiwiZW50ZXJDYW5jZWxsZWRIb29rIiwiZXhwbGljaXRFbnRlckR1cmF0aW9uIiwiY2hlY2tEdXJhdGlvbiIsImV4cGVjdHNDU1MiLCJ1c2VyV2FudHNDb250cm9sIiwiZ2V0SG9va0FyZ3VtZW50c0xlbmd0aCIsInNob3ciLCJwZW5kaW5nTm9kZSIsIl9wZW5kaW5nIiwiaXNWYWxpZER1cmF0aW9uIiwibGVhdmUiLCJiZWZvcmVMZWF2ZSIsImFmdGVyTGVhdmUiLCJsZWF2ZUNhbmNlbGxlZCIsImRlbGF5TGVhdmUiLCJleHBsaWNpdExlYXZlRHVyYXRpb24iLCJwZXJmb3JtTGVhdmUiLCJpbnZva2VyRm5zIiwiX2VudGVyIiwicGxhdGZvcm1Nb2R1bGVzIiwiaXNUZXh0SW5wdXRUeXBlIiwidm1vZGVsIiwidHJpZ2dlciIsIm1vZGVsJDEiLCJiaW5kaW5nIiwic2V0U2VsZWN0ZWQiLCJvbkNvbXBvc2l0aW9uRW5kIiwib25Db21wb3NpdGlvblN0YXJ0IiwibmVlZFJlc2V0Iiwic29tZSIsImhhc05vTWF0Y2hpbmdPcHRpb24iLCJpc011bHRpcGxlIiwiZ2V0VmFsdWUiLCJzZWxlY3RlZEluZGV4IiwiY3JlYXRlRXZlbnQiLCJpbml0RXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwibG9jYXRlTm9kZSIsInRyYW5zaXRpb24kJDEiLCJvcmlnaW5hbERpc3BsYXkiLCJfX3ZPcmlnaW5hbERpc3BsYXkiLCJkaXNwbGF5IiwidW5iaW5kIiwicGxhdGZvcm1EaXJlY3RpdmVzIiwidHJhbnNpdGlvblByb3BzIiwibW9kZSIsImdldFJlYWxDaGlsZCIsImNvbXBPcHRpb25zIiwiZXh0cmFjdFRyYW5zaXRpb25EYXRhIiwia2V5JDEiLCJwbGFjZWhvbGRlciIsInJhd0NoaWxkIiwiaGFzUGFyZW50VHJhbnNpdGlvbiIsImlzU2FtZUNoaWxkIiwib2xkQ2hpbGQiLCJUcmFuc2l0aW9uIiwiX2xlYXZpbmciLCJvbGRSYXdDaGlsZCIsImRlbGF5ZWRMZWF2ZSIsIm1vdmVDbGFzcyIsIlRyYW5zaXRpb25Hcm91cCIsInByZXZDaGlsZHJlbiIsInJhd0NoaWxkcmVuIiwidHJhbnNpdGlvbkRhdGEiLCJrZXB0IiwicmVtb3ZlZCIsImMkMSIsInBvcyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImJlZm9yZVVwZGF0ZSIsInVwZGF0ZWQiLCJoYXNNb3ZlIiwiY2FsbFBlbmRpbmdDYnMiLCJyZWNvcmRQb3NpdGlvbiIsImFwcGx5VHJhbnNsYXRpb24iLCJib2R5IiwiZiIsIm9mZnNldEhlaWdodCIsIm1vdmVkIiwidHJhbnNmb3JtIiwiV2Via2l0VHJhbnNmb3JtIiwidHJhbnNpdGlvbkR1cmF0aW9uIiwiX21vdmVDYiIsInByb3BlcnR5TmFtZSIsIl9oYXNNb3ZlIiwiY2xvbmUiLCJjbG9uZU5vZGUiLCJuZXdQb3MiLCJvbGRQb3MiLCJkeCIsImxlZnQiLCJkeSIsInRvcCIsInBsYXRmb3JtQ29tcG9uZW50cyIsInNob3VsZERlY29kZSIsImNvbnRlbnQiLCJlbmNvZGVkIiwiZGl2IiwiaW5uZXJIVE1MIiwic2hvdWxkRGVjb2RlTmV3bGluZXMiLCJkZWZhdWx0VGFnUkUiLCJyZWdleEVzY2FwZVJFIiwiYnVpbGRSZWdleCIsImRlbGltaXRlcnMiLCJvcGVuIiwiY2xvc2UiLCJwYXJzZVRleHQiLCJ0YWdSRSIsInRva2VucyIsImxhc3RJbmRleCIsImV4ZWMiLCJ0cmFuc2Zvcm1Ob2RlIiwiY2xhc3NCaW5kaW5nIiwiZ2VuRGF0YSIsImtsYXNzJDEiLCJ0cmFuc2Zvcm1Ob2RlJDEiLCJzdHlsZUJpbmRpbmciLCJnZW5EYXRhJDEiLCJzdHlsZSQxIiwibW9kdWxlcyQxIiwiaHRtbCIsImRpcmVjdGl2ZXMkMSIsImlzVW5hcnlUYWciLCJjYW5CZUxlZnRPcGVuVGFnIiwiaXNOb25QaHJhc2luZ1RhZyIsImJhc2VPcHRpb25zIiwiZXhwZWN0SFRNTCIsImRlY29kZXIiLCJoZSIsImRlY29kZSIsInNpbmdsZUF0dHJJZGVudGlmaWVyIiwic2luZ2xlQXR0ckFzc2lnbiIsInNpbmdsZUF0dHJWYWx1ZXMiLCJhdHRyaWJ1dGUiLCJuY25hbWUiLCJxbmFtZUNhcHR1cmUiLCJzdGFydFRhZ09wZW4iLCJzdGFydFRhZ0Nsb3NlIiwiZG9jdHlwZSIsImNvbW1lbnQiLCJjb25kaXRpb25hbENvbW1lbnQiLCJJU19SRUdFWF9DQVBUVVJJTkdfQlJPS0VOIiwiZyIsImlzUGxhaW5UZXh0RWxlbWVudCIsInJlQ2FjaGUiLCJkZWNvZGluZ01hcCIsImVuY29kZWRBdHRyIiwiZW5jb2RlZEF0dHJXaXRoTmV3TGluZXMiLCJpc0lnbm9yZU5ld2xpbmVUYWciLCJzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUiLCJkZWNvZGVBdHRyIiwicmUiLCJwYXJzZUhUTUwiLCJzdGFjayIsImlzVW5hcnlUYWckJDEiLCJjYW5CZUxlZnRPcGVuVGFnJCQxIiwibGFzdFRhZyIsImFkdmFuY2UiLCJ0ZXh0RW5kIiwiY29tbWVudEVuZCIsInNob3VsZEtlZXBDb21tZW50IiwiY29uZGl0aW9uYWxFbmQiLCJkb2N0eXBlTWF0Y2giLCJlbmRUYWdNYXRjaCIsImN1ckluZGV4IiwicGFyc2VFbmRUYWciLCJzdGFydFRhZ01hdGNoIiwicGFyc2VTdGFydFRhZyIsImhhbmRsZVN0YXJ0VGFnIiwicmVzdCIsImNoYXJzIiwiZW5kVGFnTGVuZ3RoIiwic3RhY2tlZFRhZyIsInJlU3RhY2tlZFRhZyIsInJlc3QkMSIsImFsbCIsInVuYXJ5U2xhc2giLCJ1bmFyeSIsImxvd2VyQ2FzZWRUYWciLCJsb3dlckNhc2VkVGFnTmFtZSIsIm9uUkUiLCJkaXJSRSIsImZvckFsaWFzUkUiLCJmb3JJdGVyYXRvclJFIiwiYXJnUkUiLCJiaW5kUkUiLCJtb2RpZmllclJFIiwiZGVjb2RlSFRNTENhY2hlZCIsIndhcm4kMiIsInRyYW5zZm9ybXMiLCJwcmVUcmFuc2Zvcm1zIiwicG9zdFRyYW5zZm9ybXMiLCJwbGF0Zm9ybUlzUHJlVGFnIiwicGxhdGZvcm1NdXN0VXNlUHJvcCIsInBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlIiwicGFyc2UiLCJwcmVzZXJ2ZVdoaXRlc3BhY2UiLCJyb290IiwiY3VycmVudFBhcmVudCIsImluVlByZSIsIndhcm5lZCIsIndhcm5PbmNlIiwiZW5kUHJlIiwiZWxlbWVudCIsImNvbW1lbnRzIiwiZ3VhcmRJRVNWR0J1ZyIsIm1ha2VBdHRyc01hcCIsImlzRm9yYmlkZGVuVGFnIiwiZm9yYmlkZGVuIiwicHJvY2Vzc1ByZSIsInByb2Nlc3NSYXdBdHRycyIsInByb2Nlc3NGb3IiLCJwcm9jZXNzSWYiLCJwcm9jZXNzT25jZSIsInByb2Nlc3NLZXkiLCJwbGFpbiIsInByb2Nlc3NSZWYiLCJwcm9jZXNzU2xvdCIsInByb2Nlc3NDb21wb25lbnQiLCJwcm9jZXNzQXR0cnMiLCJjaGVja1Jvb3RDb25zdHJhaW50cyIsImlmIiwiZWxzZWlmIiwiZWxzZSIsImFkZElmQ29uZGl0aW9uIiwiYmxvY2siLCJwcm9jZXNzSWZDb25kaXRpb25zIiwic2xvdFNjb3BlIiwic2xvdFRhcmdldCIsImkkMiIsImxhc3ROb2RlIiwiaXNUZXh0VGFnIiwiY2hlY2tJbkZvciIsImluTWF0Y2giLCJmb3IiLCJhbGlhcyIsIml0ZXJhdG9yTWF0Y2giLCJpdGVyYXRvcjEiLCJpdGVyYXRvcjIiLCJmaW5kUHJldkVsZW1lbnQiLCJjb25kaXRpb24iLCJpZkNvbmRpdGlvbnMiLCJzbG90TmFtZSIsImlzUHJvcCIsImhhc0JpbmRpbmdzIiwicGFyc2VNb2RpZmllcnMiLCJjYW1lbCIsImFyZ01hdGNoIiwiY2hlY2tGb3JBbGlhc01vZGVsIiwiaWVOU0J1ZyIsImllTlNQcmVmaXgiLCJfZWwiLCJpc1N0YXRpY0tleSIsImlzUGxhdGZvcm1SZXNlcnZlZFRhZyIsImdlblN0YXRpY0tleXNDYWNoZWQiLCJnZW5TdGF0aWNLZXlzJDEiLCJvcHRpbWl6ZSIsIm1hcmtTdGF0aWMkMSIsIm1hcmtTdGF0aWNSb290cyIsInN0YXRpYyIsImwkMSIsInN0YXRpY0luRm9yIiwic3RhdGljUm9vdCIsImlzRGlyZWN0Q2hpbGRPZlRlbXBsYXRlRm9yIiwiZm5FeHBSRSIsInNpbXBsZVBhdGhSRSIsImVzYyIsInRhYiIsInNwYWNlIiwidXAiLCJyaWdodCIsImRvd24iLCJnZW5HdWFyZCIsIm1vZGlmaWVyQ29kZSIsInN0b3AiLCJzZWxmIiwiY3RybCIsInNoaWZ0IiwiYWx0IiwibWV0YSIsIm1pZGRsZSIsImdlbkhhbmRsZXJzIiwiZ2VuSGFuZGxlciIsImlzTWV0aG9kUGF0aCIsImlzRnVuY3Rpb25FeHByZXNzaW9uIiwiZ2VuTW9kaWZpZXJDb2RlIiwiZ2VuS2V5RmlsdGVyIiwiaGFuZGxlckNvZGUiLCJnZW5GaWx0ZXJDb2RlIiwia2V5VmFsIiwicGFyc2VJbnQiLCJ3cmFwTGlzdGVuZXJzIiwiYmluZCQxIiwid3JhcERhdGEiLCJiYXNlRGlyZWN0aXZlcyIsImNsb2FrIiwiQ29kZWdlblN0YXRlIiwiZGF0YUdlbkZucyIsIm1heWJlQ29tcG9uZW50Iiwib25jZUlkIiwiZ2VuZXJhdGUiLCJhc3QiLCJzdGF0ZSIsImdlbkVsZW1lbnQiLCJzdGF0aWNQcm9jZXNzZWQiLCJnZW5TdGF0aWMiLCJvbmNlUHJvY2Vzc2VkIiwiZ2VuT25jZSIsImZvclByb2Nlc3NlZCIsImdlbkZvciIsImlmUHJvY2Vzc2VkIiwiZ2VuSWYiLCJnZW5DaGlsZHJlbiIsImdlblNsb3QiLCJnZW5Db21wb25lbnQiLCJnZW5EYXRhJDIiLCJhbHRHZW4iLCJhbHRFbXB0eSIsImdlbklmQ29uZGl0aW9ucyIsImNvbmRpdGlvbnMiLCJnZW5UZXJuYXJ5RXhwIiwiYWx0SGVscGVyIiwiZ2VuRGlyZWN0aXZlcyIsImdlblByb3BzIiwiZ2VuU2NvcGVkU2xvdHMiLCJnZW5JbmxpbmVUZW1wbGF0ZSIsImhhc1J1bnRpbWUiLCJuZWVkUnVudGltZSIsImdlbiIsImlubGluZVJlbmRlckZucyIsImdlblNjb3BlZFNsb3QiLCJnZW5Gb3JTY29wZWRTbG90Iiwic2NvcGUiLCJjaGVja1NraXAiLCJhbHRHZW5FbGVtZW50IiwiYWx0R2VuTm9kZSIsImVsJDEiLCJnZXROb3JtYWxpemF0aW9uVHlwZSIsImdlbk5vZGUiLCJuZWVkc05vcm1hbGl6YXRpb24iLCJnZW5Db21tZW50IiwiZ2VuVGV4dCIsInRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyIsImJpbmQkJDEiLCJjb21wb25lbnROYW1lIiwicHJvaGliaXRlZEtleXdvcmRSRSIsInVuYXJ5T3BlcmF0b3JzUkUiLCJpZGVudFJFIiwic3RyaXBTdHJpbmdSRSIsImRldGVjdEVycm9ycyIsImVycm9ycyIsImNoZWNrTm9kZSIsImNoZWNrRm9yIiwiY2hlY2tFdmVudCIsImNoZWNrRXhwcmVzc2lvbiIsInN0aXBwZWQiLCJrZXl3b3JkTWF0Y2giLCJjaGVja0lkZW50aWZpZXIiLCJpZGVudCIsIkZ1bmN0aW9uIiwiY3JlYXRlRnVuY3Rpb24iLCJjcmVhdGVDb21waWxlVG9GdW5jdGlvbkZuIiwiY29tcGlsZSIsImNvbXBpbGVUb0Z1bmN0aW9ucyIsImNvbXBpbGVkIiwidGlwcyIsImZuR2VuRXJyb3JzIiwiY3JlYXRlQ29tcGlsZXJDcmVhdG9yIiwiYmFzZUNvbXBpbGUiLCJjcmVhdGVDb21waWxlciIsImZpbmFsT3B0aW9ucyIsInJlZiQxIiwiaWRUb1RlbXBsYXRlIiwibW91bnQiLCJkb2N1bWVudEVsZW1lbnQiLCJnZXRPdXRlckhUTUwiLCJvdXRlckhUTUwiLCJjb250YWluZXIiXSwibWFwcGluZ3MiOiI7O0FBQUE7Ozs7O0FBS0MsV0FBVUEsTUFBVixFQUFrQkMsT0FBbEIsRUFBMkI7QUFDM0Isa0NBQU9DLE9BQVAsT0FBbUIsUUFBbkIsSUFBK0IsT0FBT0MsTUFBUCxLQUFrQixXQUFqRCxHQUErREEsT0FBT0QsT0FBUCxHQUFpQkQsU0FBaEYsR0FDQSxRQUE2QyxvQ0FBT0EsT0FBUDtBQUFBO0FBQUE7QUFBQTtBQUFBLG9HQUE3QyxHQUNDRCxPQUFPSSxHQUFQLEdBQWFILFNBRmQ7QUFHQSxDQUpBLEVBSUMsSUFKRCxFQUlRLFlBQVk7QUFBRTs7QUFFdkI7O0FBRUE7QUFDQTs7QUFDQSxXQUFTSSxPQUFULENBQWtCQyxDQUFsQixFQUFxQjtBQUNuQixXQUFPQSxNQUFNQyxTQUFOLElBQW1CRCxNQUFNLElBQWhDO0FBQ0Q7O0FBRUQsV0FBU0UsS0FBVCxDQUFnQkYsQ0FBaEIsRUFBbUI7QUFDakIsV0FBT0EsTUFBTUMsU0FBTixJQUFtQkQsTUFBTSxJQUFoQztBQUNEOztBQUVELFdBQVNHLE1BQVQsQ0FBaUJILENBQWpCLEVBQW9CO0FBQ2xCLFdBQU9BLE1BQU0sSUFBYjtBQUNEOztBQUVELFdBQVNJLE9BQVQsQ0FBa0JKLENB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QXpDLElBQXdEc1AsSUFBNUQsRUFBa0U7QUFDaEVBLGVBQUssYUFBTDtBQUNBQyxrQkFBVSxLQUFLK0osS0FBTixHQUFlLFVBQXhCLEVBQXFDLFNBQXJDLEVBQWdELGFBQWhEO0FBQ0Q7QUFDRjtBQUNGO0FBQ0QsV0FBT2srQixNQUFNdjlDLElBQU4sQ0FBVyxJQUFYLEVBQWlCb1IsRUFBakIsRUFBcUI4TSxTQUFyQixDQUFQO0FBQ0QsR0FqRUQ7O0FBbUVBOzs7O0FBSUEsV0FBU3UvQixZQUFULENBQXVCcnNDLEVBQXZCLEVBQTJCO0FBQ3pCLFFBQUlBLEdBQUdzc0MsU0FBUCxFQUFrQjtBQUNoQixhQUFPdHNDLEdBQUdzc0MsU0FBVjtBQUNELEtBRkQsTUFFTztBQUNMLFVBQUlDLFlBQVlueEMsU0FBUzJaLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBaEI7QUFDQXczQixnQkFBVXRyQixXQUFWLENBQXNCamhCLEdBQUdvNkIsU0FBSCxDQUFhLElBQWIsQ0FBdEI7QUFDQSxhQUFPbVMsVUFBVXZSLFNBQWpCO0FBQ0Q7QUFDRjs7QUFFRHZmLFFBQU0rdkIsT0FBTixHQUFnQkMsa0JBQWhCOztBQUVBLFNBQU9od0IsS0FBUDtBQUVDLENBbjBUQSxDQUFELEMiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVnVlLmpzIHYyLjQuMVxuICogKGMpIDIwMTQtMjAxNyBFdmFuIFlvdVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG5cdChnbG9iYWwuVnVlID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4vKiAgKi9cblxuLy8gdGhlc2UgaGVscGVycyBwcm9kdWNlcyBiZXR0ZXIgdm0gY29kZSBpbiBKUyBlbmdpbmVzIGR1ZSB0byB0aGVpclxuLy8gZXhwbGljaXRuZXNzIGFuZCBmdW5jdGlvbiBpbmxpbmluZ1xuZnVuY3Rpb24gaXNVbmRlZiAodikge1xuICByZXR1cm4gdiA9PT0gdW5kZWZpbmVkIHx8IHYgPT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNEZWYgKHYpIHtcbiAgcmV0dXJuIHYgIT09IHVuZGVmaW5lZCAmJiB2ICE9PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzVHJ1ZSAodikge1xuICByZXR1cm4gdiA9PT0gdHJ1ZVxufVxuXG5mdW5jdGlvbiBpc0ZhbHNlICh2KSB7XG4gIHJldHVybiB2ID09PSBmYWxzZVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHZhbHVlIGlzIHByaW1pdGl2ZVxuICovXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZSAodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJ1xufVxuXG4vKipcbiAqIFF1aWNrIG9iamVjdCBjaGVjayAtIHRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gdGVsbFxuICogT2JqZWN0cyBmcm9tIHByaW1pdGl2ZSB2YWx1ZXMgd2hlbiB3ZSBrbm93IHRoZSB2YWx1ZVxuICogaXMgYSBKU09OLWNvbXBsaWFudCB0eXBlLlxuICovXG5mdW5jdGlvbiBpc09iamVjdCAob2JqKSB7XG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCdcbn1cblxudmFyIF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogU3RyaWN0IG9iamVjdCB0eXBlIGNoZWNrLiBPbmx5IHJldHVybnMgdHJ1ZVxuICogZm9yIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCAob2JqKSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJ1xufVxuXG5mdW5jdGlvbiBpc1JlZ0V4cCAodikge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdmFsIGlzIGEgdmFsaWQgYXJyYXkgaW5kZXguXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRBcnJheUluZGV4ICh2YWwpIHtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KHZhbCk7XG4gIHJldHVybiBuID49IDAgJiYgTWF0aC5mbG9vcihuKSA9PT0gbiAmJiBpc0Zpbml0ZSh2YWwpXG59XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIHRvIGEgc3RyaW5nIHRoYXQgaXMgYWN0dWFsbHkgcmVuZGVyZWQuXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nICh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PSBudWxsXG4gICAgPyAnJ1xuICAgIDogdHlwZW9mIHZhbCA9PT0gJ29iamVjdCdcbiAgICAgID8gSlNPTi5zdHJpbmdpZnkodmFsLCBudWxsLCAyKVxuICAgICAgOiBTdHJpbmcodmFsKVxufVxuXG4vKipcbiAqIENvbnZlcnQgYSBpbnB1dCB2YWx1ZSB0byBhIG51bWJlciBmb3IgcGVyc2lzdGVuY2UuXG4gKiBJZiB0aGUgY29udmVyc2lvbiBmYWlscywgcmV0dXJuIG9yaWdpbmFsIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIgKHZhbCkge1xuICB2YXIgbiA9IHBhcnNlRmxvYXQodmFsKTtcbiAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogblxufVxuXG4vKipcbiAqIE1ha2UgYSBtYXAgYW5kIHJldHVybiBhIGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhIGtleVxuICogaXMgaW4gdGhhdCBtYXAuXG4gKi9cbmZ1bmN0aW9uIG1ha2VNYXAgKFxuICBzdHIsXG4gIGV4cGVjdHNMb3dlckNhc2Vcbikge1xuICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIGxpc3QgPSBzdHIuc3BsaXQoJywnKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgbWFwW2xpc3RbaV1dID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZXhwZWN0c0xvd2VyQ2FzZVxuICAgID8gZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbC50b0xvd2VyQ2FzZSgpXTsgfVxuICAgIDogZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbF07IH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHRhZyBpcyBhIGJ1aWx0LWluIHRhZy5cbiAqL1xudmFyIGlzQnVpbHRJblRhZyA9IG1ha2VNYXAoJ3Nsb3QsY29tcG9uZW50JywgdHJ1ZSk7XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBhdHRyaWJ1dGUgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUuXG4gKi9cbnZhciBpc1Jlc2VydmVkQXR0cmlidXRlID0gbWFrZU1hcCgna2V5LHJlZixzbG90LGlzJyk7XG5cbi8qKlxuICogUmVtb3ZlIGFuIGl0ZW0gZnJvbSBhbiBhcnJheVxuICovXG5mdW5jdGlvbiByZW1vdmUgKGFyciwgaXRlbSkge1xuICBpZiAoYXJyLmxlbmd0aCkge1xuICAgIHZhciBpbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICByZXR1cm4gYXJyLnNwbGljZShpbmRleCwgMSlcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBvYmplY3QgaGFzIHRoZSBwcm9wZXJ0eS5cbiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIGhhc093biAob2JqLCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgY2FjaGVkIHZlcnNpb24gb2YgYSBwdXJlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjYWNoZWQgKGZuKSB7XG4gIHZhciBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiAoZnVuY3Rpb24gY2FjaGVkRm4gKHN0cikge1xuICAgIHZhciBoaXQgPSBjYWNoZVtzdHJdO1xuICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKVxuICB9KVxufVxuXG4vKipcbiAqIENhbWVsaXplIGEgaHlwaGVuLWRlbGltaXRlZCBzdHJpbmcuXG4gKi9cbnZhciBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xudmFyIGNhbWVsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIGZ1bmN0aW9uIChfLCBjKSB7IHJldHVybiBjID8gYy50b1VwcGVyQ2FzZSgpIDogJyc7IH0pXG59KTtcblxuLyoqXG4gKiBDYXBpdGFsaXplIGEgc3RyaW5nLlxuICovXG52YXIgY2FwaXRhbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSlcbn0pO1xuXG4vKipcbiAqIEh5cGhlbmF0ZSBhIGNhbWVsQ2FzZSBzdHJpbmcuXG4gKi9cbnZhciBoeXBoZW5hdGVSRSA9IC8oW14tXSkoW0EtWl0pL2c7XG52YXIgaHlwaGVuYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0clxuICAgIC5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnJDEtJDInKVxuICAgIC5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnJDEtJDInKVxuICAgIC50b0xvd2VyQ2FzZSgpXG59KTtcblxuLyoqXG4gKiBTaW1wbGUgYmluZCwgZmFzdGVyIHRoYW4gbmF0aXZlXG4gKi9cbmZ1bmN0aW9uIGJpbmQgKGZuLCBjdHgpIHtcbiAgZnVuY3Rpb24gYm91bmRGbiAoYSkge1xuICAgIHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICByZXR1cm4gbFxuICAgICAgPyBsID4gMVxuICAgICAgICA/IGZuLmFwcGx5KGN0eCwgYXJndW1lbnRzKVxuICAgICAgICA6IGZuLmNhbGwoY3R4LCBhKVxuICAgICAgOiBmbi5jYWxsKGN0eClcbiAgfVxuICAvLyByZWNvcmQgb3JpZ2luYWwgZm4gbGVuZ3RoXG4gIGJvdW5kRm4uX2xlbmd0aCA9IGZuLmxlbmd0aDtcbiAgcmV0dXJuIGJvdW5kRm5cbn1cblxuLyoqXG4gKiBDb252ZXJ0IGFuIEFycmF5LWxpa2Ugb2JqZWN0IHRvIGEgcmVhbCBBcnJheS5cbiAqL1xuZnVuY3Rpb24gdG9BcnJheSAobGlzdCwgc3RhcnQpIHtcbiAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICB2YXIgaSA9IGxpc3QubGVuZ3RoIC0gc3RhcnQ7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoaSk7XG4gIHdoaWxlIChpLS0pIHtcbiAgICByZXRbaV0gPSBsaXN0W2kgKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vKipcbiAqIE1peCBwcm9wZXJ0aWVzIGludG8gdGFyZ2V0IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZXh0ZW5kICh0bywgX2Zyb20pIHtcbiAgZm9yICh2YXIga2V5IGluIF9mcm9tKSB7XG4gICAgdG9ba2V5XSA9IF9mcm9tW2tleV07XG4gIH1cbiAgcmV0dXJuIHRvXG59XG5cbi8qKlxuICogTWVyZ2UgYW4gQXJyYXkgb2YgT2JqZWN0cyBpbnRvIGEgc2luZ2xlIE9iamVjdC5cbiAqL1xuZnVuY3Rpb24gdG9PYmplY3QgKGFycikge1xuICB2YXIgcmVzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFycltpXSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXJyW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKipcbiAqIFBlcmZvcm0gbm8gb3BlcmF0aW9uLlxuICogU3R1YmJpbmcgYXJncyB0byBtYWtlIEZsb3cgaGFwcHkgd2l0aG91dCBsZWF2aW5nIHVzZWxlc3MgdHJhbnNwaWxlZCBjb2RlXG4gKiB3aXRoIC4uLnJlc3QgKGh0dHBzOi8vZmxvdy5vcmcvYmxvZy8yMDE3LzA1LzA3L1N0cmljdC1GdW5jdGlvbi1DYWxsLUFyaXR5LylcbiAqL1xuZnVuY3Rpb24gbm9vcCAoYSwgYiwgYykge31cblxuLyoqXG4gKiBBbHdheXMgcmV0dXJuIGZhbHNlLlxuICovXG52YXIgbm8gPSBmdW5jdGlvbiAoYSwgYiwgYykgeyByZXR1cm4gZmFsc2U7IH07XG5cbi8qKlxuICogUmV0dXJuIHNhbWUgdmFsdWVcbiAqL1xudmFyIGlkZW50aXR5ID0gZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH07XG5cbi8qKlxuICogR2VuZXJhdGUgYSBzdGF0aWMga2V5cyBzdHJpbmcgZnJvbSBjb21waWxlciBtb2R1bGVzLlxuICovXG5mdW5jdGlvbiBnZW5TdGF0aWNLZXlzIChtb2R1bGVzKSB7XG4gIHJldHVybiBtb2R1bGVzLnJlZHVjZShmdW5jdGlvbiAoa2V5cywgbSkge1xuICAgIHJldHVybiBrZXlzLmNvbmNhdChtLnN0YXRpY0tleXMgfHwgW10pXG4gIH0sIFtdKS5qb2luKCcsJylcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gdmFsdWVzIGFyZSBsb29zZWx5IGVxdWFsIC0gdGhhdCBpcyxcbiAqIGlmIHRoZXkgYXJlIHBsYWluIG9iamVjdHMsIGRvIHRoZXkgaGF2ZSB0aGUgc2FtZSBzaGFwZT9cbiAqL1xuZnVuY3Rpb24gbG9vc2VFcXVhbCAoYSwgYikge1xuICB2YXIgaXNPYmplY3RBID0gaXNPYmplY3QoYSk7XG4gIHZhciBpc09iamVjdEIgPSBpc09iamVjdChiKTtcbiAgaWYgKGlzT2JqZWN0QSAmJiBpc09iamVjdEIpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGEpID09PSBKU09OLnN0cmluZ2lmeShiKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIHBvc3NpYmxlIGNpcmN1bGFyIHJlZmVyZW5jZVxuICAgICAgcmV0dXJuIGEgPT09IGJcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWlzT2JqZWN0QSAmJiAhaXNPYmplY3RCKSB7XG4gICAgcmV0dXJuIFN0cmluZyhhKSA9PT0gU3RyaW5nKGIpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24gbG9vc2VJbmRleE9mIChhcnIsIHZhbCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChsb29zZUVxdWFsKGFycltpXSwgdmFsKSkgeyByZXR1cm4gaSB9XG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbi8qKlxuICogRW5zdXJlIGEgZnVuY3Rpb24gaXMgY2FsbGVkIG9ubHkgb25jZS5cbiAqL1xuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFNTUl9BVFRSID0gJ2RhdGEtc2VydmVyLXJlbmRlcmVkJztcblxudmFyIEFTU0VUX1RZUEVTID0gW1xuICAnY29tcG9uZW50JyxcbiAgJ2RpcmVjdGl2ZScsXG4gICdmaWx0ZXInXG5dO1xuXG52YXIgTElGRUNZQ0xFX0hPT0tTID0gW1xuICAnYmVmb3JlQ3JlYXRlJyxcbiAgJ2NyZWF0ZWQnLFxuICAnYmVmb3JlTW91bnQnLFxuICAnbW91bnRlZCcsXG4gICdiZWZvcmVVcGRhdGUnLFxuICAndXBkYXRlZCcsXG4gICdiZWZvcmVEZXN0cm95JyxcbiAgJ2Rlc3Ryb3llZCcsXG4gICdhY3RpdmF0ZWQnLFxuICAnZGVhY3RpdmF0ZWQnXG5dO1xuXG4vKiAgKi9cblxudmFyIGNvbmZpZyA9ICh7XG4gIC8qKlxuICAgKiBPcHRpb24gbWVyZ2Ugc3RyYXRlZ2llcyAodXNlZCBpbiBjb3JlL3V0aWwvb3B0aW9ucylcbiAgICovXG4gIG9wdGlvbk1lcmdlU3RyYXRlZ2llczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAvKipcbiAgICogV2hldGhlciB0byBzdXBwcmVzcyB3YXJuaW5ncy5cbiAgICovXG4gIHNpbGVudDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFNob3cgcHJvZHVjdGlvbiBtb2RlIHRpcCBtZXNzYWdlIG9uIGJvb3Q/XG4gICAqL1xuICBwcm9kdWN0aW9uVGlwOiBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogV2hldGhlciB0byBlbmFibGUgZGV2dG9vbHNcbiAgICovXG4gIGRldnRvb2xzOiBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogV2hldGhlciB0byByZWNvcmQgcGVyZlxuICAgKi9cbiAgcGVyZm9ybWFuY2U6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBFcnJvciBoYW5kbGVyIGZvciB3YXRjaGVyIGVycm9yc1xuICAgKi9cbiAgZXJyb3JIYW5kbGVyOiBudWxsLFxuXG4gIC8qKlxuICAgKiBXYXJuIGhhbmRsZXIgZm9yIHdhdGNoZXIgd2FybnNcbiAgICovXG4gIHdhcm5IYW5kbGVyOiBudWxsLFxuXG4gIC8qKlxuICAgKiBJZ25vcmUgY2VydGFpbiBjdXN0b20gZWxlbWVudHNcbiAgICovXG4gIGlnbm9yZWRFbGVtZW50czogW10sXG5cbiAgLyoqXG4gICAqIEN1c3RvbSB1c2VyIGtleSBhbGlhc2VzIGZvciB2LW9uXG4gICAqL1xuICBrZXlDb2RlczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgcmVnaXN0ZXJlZCBhcyBhXG4gICAqIGNvbXBvbmVudC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICovXG4gIGlzUmVzZXJ2ZWRUYWc6IG5vLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgdXNlZCBhcyBhIGNvbXBvbmVudFxuICAgKiBwcm9wLiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxuICAgKi9cbiAgaXNSZXNlcnZlZEF0dHI6IG5vLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyBhbiB1bmtub3duIGVsZW1lbnQuXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICovXG4gIGlzVW5rbm93bkVsZW1lbnQ6IG5vLFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG5hbWVzcGFjZSBvZiBhbiBlbGVtZW50XG4gICAqL1xuICBnZXRUYWdOYW1lc3BhY2U6IG5vb3AsXG5cbiAgLyoqXG4gICAqIFBhcnNlIHRoZSByZWFsIHRhZyBuYW1lIGZvciB0aGUgc3BlY2lmaWMgcGxhdGZvcm0uXG4gICAqL1xuICBwYXJzZVBsYXRmb3JtVGFnTmFtZTogaWRlbnRpdHksXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBtdXN0IGJlIGJvdW5kIHVzaW5nIHByb3BlcnR5LCBlLmcuIHZhbHVlXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICovXG4gIG11c3RVc2VQcm9wOiBubyxcblxuICAvKipcbiAgICogRXhwb3NlZCBmb3IgbGVnYWN5IHJlYXNvbnNcbiAgICovXG4gIF9saWZlY3ljbGVIb29rczogTElGRUNZQ0xFX0hPT0tTXG59KTtcblxuLyogICovXG5cbnZhciBlbXB0eU9iamVjdCA9IE9iamVjdC5mcmVlemUoe30pO1xuXG4vKipcbiAqIENoZWNrIGlmIGEgc3RyaW5nIHN0YXJ0cyB3aXRoICQgb3IgX1xuICovXG5mdW5jdGlvbiBpc1Jlc2VydmVkIChzdHIpIHtcbiAgdmFyIGMgPSAoc3RyICsgJycpLmNoYXJDb2RlQXQoMCk7XG4gIHJldHVybiBjID09PSAweDI0IHx8IGMgPT09IDB4NUZcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZGVmIChvYmosIGtleSwgdmFsLCBlbnVtZXJhYmxlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIHZhbHVlOiB2YWwsXG4gICAgZW51bWVyYWJsZTogISFlbnVtZXJhYmxlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLyoqXG4gKiBQYXJzZSBzaW1wbGUgcGF0aC5cbiAqL1xudmFyIGJhaWxSRSA9IC9bXlxcdy4kXS87XG5mdW5jdGlvbiBwYXJzZVBhdGggKHBhdGgpIHtcbiAgaWYgKGJhaWxSRS50ZXN0KHBhdGgpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLicpO1xuICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghb2JqKSB7IHJldHVybiB9XG4gICAgICBvYmogPSBvYmpbc2VnbWVudHNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gb2JqXG4gIH1cbn1cblxuLyogICovXG5cbnZhciB3YXJuID0gbm9vcDtcbnZhciB0aXAgPSBub29wO1xudmFyIGZvcm1hdENvbXBvbmVudE5hbWUgPSAobnVsbCk7IC8vIHdvcmsgYXJvdW5kIGZsb3cgY2hlY2tcblxue1xuICB2YXIgaGFzQ29uc29sZSA9IHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJztcbiAgdmFyIGNsYXNzaWZ5UkUgPSAvKD86XnxbLV9dKShcXHcpL2c7XG4gIHZhciBjbGFzc2lmeSA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0clxuICAgIC5yZXBsYWNlKGNsYXNzaWZ5UkUsIGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRvVXBwZXJDYXNlKCk7IH0pXG4gICAgLnJlcGxhY2UoL1stX10vZywgJycpOyB9O1xuXG4gIHdhcm4gPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgIHZhciB0cmFjZSA9IHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJztcblxuICAgIGlmIChjb25maWcud2FybkhhbmRsZXIpIHtcbiAgICAgIGNvbmZpZy53YXJuSGFuZGxlci5jYWxsKG51bGwsIG1zZywgdm0sIHRyYWNlKTtcbiAgICB9IGVsc2UgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS5lcnJvcigoXCJbVnVlIHdhcm5dOiBcIiArIG1zZyArIHRyYWNlKSk7XG4gICAgfVxuICB9O1xuXG4gIHRpcCA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XG4gICAgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS53YXJuKFwiW1Z1ZSB0aXBdOiBcIiArIG1zZyArIChcbiAgICAgICAgdm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnXG4gICAgICApKTtcbiAgICB9XG4gIH07XG5cbiAgZm9ybWF0Q29tcG9uZW50TmFtZSA9IGZ1bmN0aW9uICh2bSwgaW5jbHVkZUZpbGUpIHtcbiAgICBpZiAodm0uJHJvb3QgPT09IHZtKSB7XG4gICAgICByZXR1cm4gJzxSb290PidcbiAgICB9XG4gICAgdmFyIG5hbWUgPSB0eXBlb2Ygdm0gPT09ICdzdHJpbmcnXG4gICAgICA/IHZtXG4gICAgICA6IHR5cGVvZiB2bSA9PT0gJ2Z1bmN0aW9uJyAmJiB2bS5vcHRpb25zXG4gICAgICAgID8gdm0ub3B0aW9ucy5uYW1lXG4gICAgICAgIDogdm0uX2lzVnVlXG4gICAgICAgICAgPyB2bS4kb3B0aW9ucy5uYW1lIHx8IHZtLiRvcHRpb25zLl9jb21wb25lbnRUYWdcbiAgICAgICAgICA6IHZtLm5hbWU7XG5cbiAgICB2YXIgZmlsZSA9IHZtLl9pc1Z1ZSAmJiB2bS4kb3B0aW9ucy5fX2ZpbGU7XG4gICAgaWYgKCFuYW1lICYmIGZpbGUpIHtcbiAgICAgIHZhciBtYXRjaCA9IGZpbGUubWF0Y2goLyhbXi9cXFxcXSspXFwudnVlJC8pO1xuICAgICAgbmFtZSA9IG1hdGNoICYmIG1hdGNoWzFdO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAobmFtZSA/IChcIjxcIiArIChjbGFzc2lmeShuYW1lKSkgKyBcIj5cIikgOiBcIjxBbm9ueW1vdXM+XCIpICtcbiAgICAgIChmaWxlICYmIGluY2x1ZGVGaWxlICE9PSBmYWxzZSA/IChcIiBhdCBcIiArIGZpbGUpIDogJycpXG4gICAgKVxuICB9O1xuXG4gIHZhciByZXBlYXQgPSBmdW5jdGlvbiAoc3RyLCBuKSB7XG4gICAgdmFyIHJlcyA9ICcnO1xuICAgIHdoaWxlIChuKSB7XG4gICAgICBpZiAobiAlIDIgPT09IDEpIHsgcmVzICs9IHN0cjsgfVxuICAgICAgaWYgKG4gPiAxKSB7IHN0ciArPSBzdHI7IH1cbiAgICAgIG4gPj49IDE7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfTtcblxuICB2YXIgZ2VuZXJhdGVDb21wb25lbnRUcmFjZSA9IGZ1bmN0aW9uICh2bSkge1xuICAgIGlmICh2bS5faXNWdWUgJiYgdm0uJHBhcmVudCkge1xuICAgICAgdmFyIHRyZWUgPSBbXTtcbiAgICAgIHZhciBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPSAwO1xuICAgICAgd2hpbGUgKHZtKSB7XG4gICAgICAgIGlmICh0cmVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgbGFzdCA9IHRyZWVbdHJlZS5sZW5ndGggLSAxXTtcbiAgICAgICAgICBpZiAobGFzdC5jb25zdHJ1Y3RvciA9PT0gdm0uY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSsrO1xuICAgICAgICAgICAgdm0gPSB2bS4kcGFyZW50O1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA+IDApIHtcbiAgICAgICAgICAgIHRyZWVbdHJlZS5sZW5ndGggLSAxXSA9IFtsYXN0LCBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2VdO1xuICAgICAgICAgICAgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdHJlZS5wdXNoKHZtKTtcbiAgICAgICAgdm0gPSB2bS4kcGFyZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuICdcXG5cXG5mb3VuZCBpblxcblxcbicgKyB0cmVlXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHZtLCBpKSB7IHJldHVybiAoXCJcIiArIChpID09PSAwID8gJy0tLT4gJyA6IHJlcGVhdCgnICcsIDUgKyBpICogMikpICsgKEFycmF5LmlzQXJyYXkodm0pXG4gICAgICAgICAgICA/ICgoZm9ybWF0Q29tcG9uZW50TmFtZSh2bVswXSkpICsgXCIuLi4gKFwiICsgKHZtWzFdKSArIFwiIHJlY3Vyc2l2ZSBjYWxscylcIilcbiAgICAgICAgICAgIDogZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpKTsgfSlcbiAgICAgICAgLmpvaW4oJ1xcbicpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoXCJcXG5cXG4oZm91bmQgaW4gXCIgKyAoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpICsgXCIpXCIpXG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaGFuZGxlRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAgaWYgKGNvbmZpZy5lcnJvckhhbmRsZXIpIHtcbiAgICBjb25maWcuZXJyb3JIYW5kbGVyLmNhbGwobnVsbCwgZXJyLCB2bSwgaW5mbyk7XG4gIH0gZWxzZSB7XG4gICAge1xuICAgICAgd2FybigoXCJFcnJvciBpbiBcIiArIGluZm8gKyBcIjogXFxcIlwiICsgKGVyci50b1N0cmluZygpKSArIFwiXFxcIlwiKSwgdm0pO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChpbkJyb3dzZXIgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cbi8qIGdsb2JhbHMgTXV0YXRpb25PYnNlcnZlciAqL1xuXG4vLyBjYW4gd2UgdXNlIF9fcHJvdG9fXz9cbnZhciBoYXNQcm90byA9ICdfX3Byb3RvX18nIGluIHt9O1xuXG4vLyBCcm93c2VyIGVudmlyb25tZW50IHNuaWZmaW5nXG52YXIgaW5Ccm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgVUEgPSBpbkJyb3dzZXIgJiYgd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbnZhciBpc0lFID0gVUEgJiYgL21zaWV8dHJpZGVudC8udGVzdChVQSk7XG52YXIgaXNJRTkgPSBVQSAmJiBVQS5pbmRleE9mKCdtc2llIDkuMCcpID4gMDtcbnZhciBpc0VkZ2UgPSBVQSAmJiBVQS5pbmRleE9mKCdlZGdlLycpID4gMDtcbnZhciBpc0FuZHJvaWQgPSBVQSAmJiBVQS5pbmRleE9mKCdhbmRyb2lkJykgPiAwO1xudmFyIGlzSU9TID0gVUEgJiYgL2lwaG9uZXxpcGFkfGlwb2R8aW9zLy50ZXN0KFVBKTtcbnZhciBpc0Nocm9tZSA9IFVBICYmIC9jaHJvbWVcXC9cXGQrLy50ZXN0KFVBKSAmJiAhaXNFZGdlO1xuXG4vLyBGaXJlZml4IGhhcyBhIFwid2F0Y2hcIiBmdW5jdGlvbiBvbiBPYmplY3QucHJvdG90eXBlLi4uXG52YXIgbmF0aXZlV2F0Y2ggPSAoe30pLndhdGNoO1xuXG52YXIgc3VwcG9ydHNQYXNzaXZlID0gZmFsc2U7XG5pZiAoaW5Ccm93c2VyKSB7XG4gIHRyeSB7XG4gICAgdmFyIG9wdHMgPSB7fTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3B0cywgJ3Bhc3NpdmUnLCAoe1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBzdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzI4NVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0LXBhc3NpdmUnLCBudWxsLCBvcHRzKTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxuLy8gdGhpcyBuZWVkcyB0byBiZSBsYXp5LWV2YWxlZCBiZWNhdXNlIHZ1ZSBtYXkgYmUgcmVxdWlyZWQgYmVmb3JlXG4vLyB2dWUtc2VydmVyLXJlbmRlcmVyIGNhbiBzZXQgVlVFX0VOVlxudmFyIF9pc1NlcnZlcjtcbnZhciBpc1NlcnZlclJlbmRlcmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKF9pc1NlcnZlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFpbkJyb3dzZXIgJiYgdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIGRldGVjdCBwcmVzZW5jZSBvZiB2dWUtc2VydmVyLXJlbmRlcmVyIGFuZCBhdm9pZFxuICAgICAgLy8gV2VicGFjayBzaGltbWluZyB0aGUgcHJvY2Vzc1xuICAgICAgX2lzU2VydmVyID0gZ2xvYmFsWydwcm9jZXNzJ10uZW52LlZVRV9FTlYgPT09ICdzZXJ2ZXInO1xuICAgIH0gZWxzZSB7XG4gICAgICBfaXNTZXJ2ZXIgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIF9pc1NlcnZlclxufTtcblxuLy8gZGV0ZWN0IGRldnRvb2xzXG52YXIgZGV2dG9vbHMgPSBpbkJyb3dzZXIgJiYgd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBpc05hdGl2ZSAoQ3Rvcikge1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT09ICdmdW5jdGlvbicgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KEN0b3IudG9TdHJpbmcoKSlcbn1cblxudmFyIGhhc1N5bWJvbCA9XG4gIHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFN5bWJvbCkgJiZcbiAgdHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFJlZmxlY3Qub3duS2V5cyk7XG5cbi8qKlxuICogRGVmZXIgYSB0YXNrIHRvIGV4ZWN1dGUgaXQgYXN5bmNocm9ub3VzbHkuXG4gKi9cbnZhciBuZXh0VGljayA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBjYWxsYmFja3MgPSBbXTtcbiAgdmFyIHBlbmRpbmcgPSBmYWxzZTtcbiAgdmFyIHRpbWVyRnVuYztcblxuICBmdW5jdGlvbiBuZXh0VGlja0hhbmRsZXIgKCkge1xuICAgIHBlbmRpbmcgPSBmYWxzZTtcbiAgICB2YXIgY29waWVzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICAgIGNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29waWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb3BpZXNbaV0oKTtcbiAgICB9XG4gIH1cblxuICAvLyB0aGUgbmV4dFRpY2sgYmVoYXZpb3IgbGV2ZXJhZ2VzIHRoZSBtaWNyb3Rhc2sgcXVldWUsIHdoaWNoIGNhbiBiZSBhY2Nlc3NlZFxuICAvLyB2aWEgZWl0aGVyIG5hdGl2ZSBQcm9taXNlLnRoZW4gb3IgTXV0YXRpb25PYnNlcnZlci5cbiAgLy8gTXV0YXRpb25PYnNlcnZlciBoYXMgd2lkZXIgc3VwcG9ydCwgaG93ZXZlciBpdCBpcyBzZXJpb3VzbHkgYnVnZ2VkIGluXG4gIC8vIFVJV2ViVmlldyBpbiBpT1MgPj0gOS4zLjMgd2hlbiB0cmlnZ2VyZWQgaW4gdG91Y2ggZXZlbnQgaGFuZGxlcnMuIEl0XG4gIC8vIGNvbXBsZXRlbHkgc3RvcHMgd29ya2luZyBhZnRlciB0cmlnZ2VyaW5nIGEgZmV3IHRpbWVzLi4uIHNvLCBpZiBuYXRpdmVcbiAgLy8gUHJvbWlzZSBpcyBhdmFpbGFibGUsIHdlIHdpbGwgdXNlIGl0OlxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm9taXNlKSkge1xuICAgIHZhciBwID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgdmFyIGxvZ0Vycm9yID0gZnVuY3Rpb24gKGVycikgeyBjb25zb2xlLmVycm9yKGVycik7IH07XG4gICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgcC50aGVuKG5leHRUaWNrSGFuZGxlcikuY2F0Y2gobG9nRXJyb3IpO1xuICAgICAgLy8gaW4gcHJvYmxlbWF0aWMgVUlXZWJWaWV3cywgUHJvbWlzZS50aGVuIGRvZXNuJ3QgY29tcGxldGVseSBicmVhaywgYnV0XG4gICAgICAvLyBpdCBjYW4gZ2V0IHN0dWNrIGluIGEgd2VpcmQgc3RhdGUgd2hlcmUgY2FsbGJhY2tzIGFyZSBwdXNoZWQgaW50byB0aGVcbiAgICAgIC8vIG1pY3JvdGFzayBxdWV1ZSBidXQgdGhlIHF1ZXVlIGlzbid0IGJlaW5nIGZsdXNoZWQsIHVudGlsIHRoZSBicm93c2VyXG4gICAgICAvLyBuZWVkcyB0byBkbyBzb21lIG90aGVyIHdvcmssIGUuZy4gaGFuZGxlIGEgdGltZXIuIFRoZXJlZm9yZSB3ZSBjYW5cbiAgICAgIC8vIFwiZm9yY2VcIiB0aGUgbWljcm90YXNrIHF1ZXVlIHRvIGJlIGZsdXNoZWQgYnkgYWRkaW5nIGFuIGVtcHR5IHRpbWVyLlxuICAgICAgaWYgKGlzSU9TKSB7IHNldFRpbWVvdXQobm9vcCk7IH1cbiAgICB9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJyAmJiAoXG4gICAgaXNOYXRpdmUoTXV0YXRpb25PYnNlcnZlcikgfHxcbiAgICAvLyBQaGFudG9tSlMgYW5kIGlPUyA3LnhcbiAgICBNdXRhdGlvbk9ic2VydmVyLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IE11dGF0aW9uT2JzZXJ2ZXJDb25zdHJ1Y3Rvcl0nXG4gICkpIHtcbiAgICAvLyB1c2UgTXV0YXRpb25PYnNlcnZlciB3aGVyZSBuYXRpdmUgUHJvbWlzZSBpcyBub3QgYXZhaWxhYmxlLFxuICAgIC8vIGUuZy4gUGhhbnRvbUpTIElFMTEsIGlPUzcsIEFuZHJvaWQgNC40XG4gICAgdmFyIGNvdW50ZXIgPSAxO1xuICAgIHZhciBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKG5leHRUaWNrSGFuZGxlcik7XG4gICAgdmFyIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKGNvdW50ZXIpKTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKHRleHROb2RlLCB7XG4gICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlXG4gICAgfSk7XG4gICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgY291bnRlciA9IChjb3VudGVyICsgMSkgJSAyO1xuICAgICAgdGV4dE5vZGUuZGF0YSA9IFN0cmluZyhjb3VudGVyKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIGZhbGxiYWNrIHRvIHNldFRpbWVvdXRcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHNldFRpbWVvdXQobmV4dFRpY2tIYW5kbGVyLCAwKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHF1ZXVlTmV4dFRpY2sgKGNiLCBjdHgpIHtcbiAgICB2YXIgX3Jlc29sdmU7XG4gICAgY2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2IuY2FsbChjdHgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgY3R4LCAnbmV4dFRpY2snKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChfcmVzb2x2ZSkge1xuICAgICAgICBfcmVzb2x2ZShjdHgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghcGVuZGluZykge1xuICAgICAgcGVuZGluZyA9IHRydWU7XG4gICAgICB0aW1lckZ1bmMoKTtcbiAgICB9XG4gICAgaWYgKCFjYiAmJiB0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIF9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIH0pXG4gICAgfVxuICB9XG59KSgpO1xuXG52YXIgX1NldDtcbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFNldCkpIHtcbiAgLy8gdXNlIG5hdGl2ZSBTZXQgd2hlbiBhdmFpbGFibGUuXG4gIF9TZXQgPSBTZXQ7XG59IGVsc2Uge1xuICAvLyBhIG5vbi1zdGFuZGFyZCBTZXQgcG9seWZpbGwgdGhhdCBvbmx5IHdvcmtzIHdpdGggcHJpbWl0aXZlIGtleXMuXG4gIF9TZXQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNldCAoKSB7XG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICAgIFNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gaGFzIChrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldFtrZXldID09PSB0cnVlXG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoa2V5KSB7XG4gICAgICB0aGlzLnNldFtrZXldID0gdHJ1ZTtcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfTtcblxuICAgIHJldHVybiBTZXQ7XG4gIH0oKSk7XG59XG5cbi8qICAqL1xuXG5cbnZhciB1aWQgPSAwO1xuXG4vKipcbiAqIEEgZGVwIGlzIGFuIG9ic2VydmFibGUgdGhhdCBjYW4gaGF2ZSBtdWx0aXBsZVxuICogZGlyZWN0aXZlcyBzdWJzY3JpYmluZyB0byBpdC5cbiAqL1xudmFyIERlcCA9IGZ1bmN0aW9uIERlcCAoKSB7XG4gIHRoaXMuaWQgPSB1aWQrKztcbiAgdGhpcy5zdWJzID0gW107XG59O1xuXG5EZXAucHJvdG90eXBlLmFkZFN1YiA9IGZ1bmN0aW9uIGFkZFN1YiAoc3ViKSB7XG4gIHRoaXMuc3Vicy5wdXNoKHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLnJlbW92ZVN1YiA9IGZ1bmN0aW9uIHJlbW92ZVN1YiAoc3ViKSB7XG4gIHJlbW92ZSh0aGlzLnN1YnMsIHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG4gIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgRGVwLnRhcmdldC5hZGREZXAodGhpcyk7XG4gIH1cbn07XG5cbkRlcC5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24gbm90aWZ5ICgpIHtcbiAgLy8gc3RhYmlsaXplIHRoZSBzdWJzY3JpYmVyIGxpc3QgZmlyc3RcbiAgdmFyIHN1YnMgPSB0aGlzLnN1YnMuc2xpY2UoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdWJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHN1YnNbaV0udXBkYXRlKCk7XG4gIH1cbn07XG5cbi8vIHRoZSBjdXJyZW50IHRhcmdldCB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZC5cbi8vIHRoaXMgaXMgZ2xvYmFsbHkgdW5pcXVlIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb25seSBvbmVcbi8vIHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkIGF0IGFueSB0aW1lLlxuRGVwLnRhcmdldCA9IG51bGw7XG52YXIgdGFyZ2V0U3RhY2sgPSBbXTtcblxuZnVuY3Rpb24gcHVzaFRhcmdldCAoX3RhcmdldCkge1xuICBpZiAoRGVwLnRhcmdldCkgeyB0YXJnZXRTdGFjay5wdXNoKERlcC50YXJnZXQpOyB9XG4gIERlcC50YXJnZXQgPSBfdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBwb3BUYXJnZXQgKCkge1xuICBEZXAudGFyZ2V0ID0gdGFyZ2V0U3RhY2sucG9wKCk7XG59XG5cbi8qXG4gKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGhcbiAqIGR5bmFtaWNhbGx5IGFjY2Vzc2luZyBtZXRob2RzIG9uIEFycmF5IHByb3RvdHlwZVxuICovXG5cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xudmFyIGFycmF5TWV0aG9kcyA9IE9iamVjdC5jcmVhdGUoYXJyYXlQcm90byk7W1xuICAncHVzaCcsXG4gICdwb3AnLFxuICAnc2hpZnQnLFxuICAndW5zaGlmdCcsXG4gICdzcGxpY2UnLFxuICAnc29ydCcsXG4gICdyZXZlcnNlJ1xuXVxuLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAvLyBjYWNoZSBvcmlnaW5hbCBtZXRob2RcbiAgdmFyIG9yaWdpbmFsID0gYXJyYXlQcm90b1ttZXRob2RdO1xuICBkZWYoYXJyYXlNZXRob2RzLCBtZXRob2QsIGZ1bmN0aW9uIG11dGF0b3IgKCkge1xuICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgIHZhciByZXN1bHQgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB2YXIgb2IgPSB0aGlzLl9fb2JfXztcbiAgICB2YXIgaW5zZXJ0ZWQ7XG4gICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgIGNhc2UgJ3B1c2gnOlxuICAgICAgY2FzZSAndW5zaGlmdCc6XG4gICAgICAgIGluc2VydGVkID0gYXJncztcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3NwbGljZSc6XG4gICAgICAgIGluc2VydGVkID0gYXJncy5zbGljZSgyKTtcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gICAgaWYgKGluc2VydGVkKSB7IG9iLm9ic2VydmVBcnJheShpbnNlcnRlZCk7IH1cbiAgICAvLyBub3RpZnkgY2hhbmdlXG4gICAgb2IuZGVwLm5vdGlmeSgpO1xuICAgIHJldHVybiByZXN1bHRcbiAgfSk7XG59KTtcblxuLyogICovXG5cbnZhciBhcnJheUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcnJheU1ldGhvZHMpO1xuXG4vKipcbiAqIEJ5IGRlZmF1bHQsIHdoZW4gYSByZWFjdGl2ZSBwcm9wZXJ0eSBpcyBzZXQsIHRoZSBuZXcgdmFsdWUgaXNcbiAqIGFsc28gY29udmVydGVkIHRvIGJlY29tZSByZWFjdGl2ZS4gSG93ZXZlciB3aGVuIHBhc3NpbmcgZG93biBwcm9wcyxcbiAqIHdlIGRvbid0IHdhbnQgdG8gZm9yY2UgY29udmVyc2lvbiBiZWNhdXNlIHRoZSB2YWx1ZSBtYXkgYmUgYSBuZXN0ZWQgdmFsdWVcbiAqIHVuZGVyIGEgZnJvemVuIGRhdGEgc3RydWN0dXJlLiBDb252ZXJ0aW5nIGl0IHdvdWxkIGRlZmVhdCB0aGUgb3B0aW1pemF0aW9uLlxuICovXG52YXIgb2JzZXJ2ZXJTdGF0ZSA9IHtcbiAgc2hvdWxkQ29udmVydDogdHJ1ZVxufTtcblxuLyoqXG4gKiBPYnNlcnZlciBjbGFzcyB0aGF0IGFyZSBhdHRhY2hlZCB0byBlYWNoIG9ic2VydmVkXG4gKiBvYmplY3QuIE9uY2UgYXR0YWNoZWQsIHRoZSBvYnNlcnZlciBjb252ZXJ0cyB0YXJnZXRcbiAqIG9iamVjdCdzIHByb3BlcnR5IGtleXMgaW50byBnZXR0ZXIvc2V0dGVycyB0aGF0XG4gKiBjb2xsZWN0IGRlcGVuZGVuY2llcyBhbmQgZGlzcGF0Y2hlcyB1cGRhdGVzLlxuICovXG52YXIgT2JzZXJ2ZXIgPSBmdW5jdGlvbiBPYnNlcnZlciAodmFsdWUpIHtcbiAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB0aGlzLmRlcCA9IG5ldyBEZXAoKTtcbiAgdGhpcy52bUNvdW50ID0gMDtcbiAgZGVmKHZhbHVlLCAnX19vYl9fJywgdGhpcyk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHZhciBhdWdtZW50ID0gaGFzUHJvdG9cbiAgICAgID8gcHJvdG9BdWdtZW50XG4gICAgICA6IGNvcHlBdWdtZW50O1xuICAgIGF1Z21lbnQodmFsdWUsIGFycmF5TWV0aG9kcywgYXJyYXlLZXlzKTtcbiAgICB0aGlzLm9ic2VydmVBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy53YWxrKHZhbHVlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXYWxrIHRocm91Z2ggZWFjaCBwcm9wZXJ0eSBhbmQgY29udmVydCB0aGVtIGludG9cbiAqIGdldHRlci9zZXR0ZXJzLiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBjYWxsZWQgd2hlblxuICogdmFsdWUgdHlwZSBpcyBPYmplY3QuXG4gKi9cbk9ic2VydmVyLnByb3RvdHlwZS53YWxrID0gZnVuY3Rpb24gd2FsayAob2JqKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEob2JqLCBrZXlzW2ldLCBvYmpba2V5c1tpXV0pO1xuICB9XG59O1xuXG4vKipcbiAqIE9ic2VydmUgYSBsaXN0IG9mIEFycmF5IGl0ZW1zLlxuICovXG5PYnNlcnZlci5wcm90b3R5cGUub2JzZXJ2ZUFycmF5ID0gZnVuY3Rpb24gb2JzZXJ2ZUFycmF5IChpdGVtcykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9ic2VydmUoaXRlbXNbaV0pO1xuICB9XG59O1xuXG4vLyBoZWxwZXJzXG5cbi8qKlxuICogQXVnbWVudCBhbiB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGludGVyY2VwdGluZ1xuICogdGhlIHByb3RvdHlwZSBjaGFpbiB1c2luZyBfX3Byb3RvX19cbiAqL1xuZnVuY3Rpb24gcHJvdG9BdWdtZW50ICh0YXJnZXQsIHNyYywga2V5cykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuICB0YXJnZXQuX19wcm90b19fID0gc3JjO1xuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvICovXG59XG5cbi8qKlxuICogQXVnbWVudCBhbiB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGRlZmluaW5nXG4gKiBoaWRkZW4gcHJvcGVydGllcy5cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGNvcHlBdWdtZW50ICh0YXJnZXQsIHNyYywga2V5cykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgZGVmKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBdHRlbXB0IHRvIGNyZWF0ZSBhbiBvYnNlcnZlciBpbnN0YW5jZSBmb3IgYSB2YWx1ZSxcbiAqIHJldHVybnMgdGhlIG5ldyBvYnNlcnZlciBpZiBzdWNjZXNzZnVsbHkgb2JzZXJ2ZWQsXG4gKiBvciB0aGUgZXhpc3Rpbmcgb2JzZXJ2ZXIgaWYgdGhlIHZhbHVlIGFscmVhZHkgaGFzIG9uZS5cbiAqL1xuZnVuY3Rpb24gb2JzZXJ2ZSAodmFsdWUsIGFzUm9vdERhdGEpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb2I7XG4gIGlmIChoYXNPd24odmFsdWUsICdfX29iX18nKSAmJiB2YWx1ZS5fX29iX18gaW5zdGFuY2VvZiBPYnNlcnZlcikge1xuICAgIG9iID0gdmFsdWUuX19vYl9fO1xuICB9IGVsc2UgaWYgKFxuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCAmJlxuICAgICFpc1NlcnZlclJlbmRlcmluZygpICYmXG4gICAgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUpKSAmJlxuICAgIE9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpICYmXG4gICAgIXZhbHVlLl9pc1Z1ZVxuICApIHtcbiAgICBvYiA9IG5ldyBPYnNlcnZlcih2YWx1ZSk7XG4gIH1cbiAgaWYgKGFzUm9vdERhdGEgJiYgb2IpIHtcbiAgICBvYi52bUNvdW50Kys7XG4gIH1cbiAgcmV0dXJuIG9iXG59XG5cbi8qKlxuICogRGVmaW5lIGEgcmVhY3RpdmUgcHJvcGVydHkgb24gYW4gT2JqZWN0LlxuICovXG5mdW5jdGlvbiBkZWZpbmVSZWFjdGl2ZSQkMSAoXG4gIG9iaixcbiAga2V5LFxuICB2YWwsXG4gIGN1c3RvbVNldHRlcixcbiAgc2hhbGxvd1xuKSB7XG4gIHZhciBkZXAgPSBuZXcgRGVwKCk7XG5cbiAgdmFyIHByb3BlcnR5ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XG4gIGlmIChwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5jb25maWd1cmFibGUgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBjYXRlciBmb3IgcHJlLWRlZmluZWQgZ2V0dGVyL3NldHRlcnNcbiAgdmFyIGdldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LmdldDtcbiAgdmFyIHNldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LnNldDtcblxuICB2YXIgY2hpbGRPYiA9ICFzaGFsbG93ICYmIG9ic2VydmUodmFsKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiByZWFjdGl2ZUdldHRlciAoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgZGVwLmRlcGVuZCgpO1xuICAgICAgICBpZiAoY2hpbGRPYikge1xuICAgICAgICAgIGNoaWxkT2IuZGVwLmRlcGVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIGRlcGVuZEFycmF5KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlU2V0dGVyIChuZXdWYWwpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChuZXdWYWwgPT09IHZhbHVlIHx8IChuZXdWYWwgIT09IG5ld1ZhbCAmJiB2YWx1ZSAhPT0gdmFsdWUpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBjdXN0b21TZXR0ZXIpIHtcbiAgICAgICAgY3VzdG9tU2V0dGVyKCk7XG4gICAgICB9XG4gICAgICBpZiAoc2V0dGVyKSB7XG4gICAgICAgIHNldHRlci5jYWxsKG9iaiwgbmV3VmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IG5ld1ZhbDtcbiAgICAgIH1cbiAgICAgIGNoaWxkT2IgPSAhc2hhbGxvdyAmJiBvYnNlcnZlKG5ld1ZhbCk7XG4gICAgICBkZXAubm90aWZ5KCk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBTZXQgYSBwcm9wZXJ0eSBvbiBhbiBvYmplY3QuIEFkZHMgdGhlIG5ldyBwcm9wZXJ0eSBhbmRcbiAqIHRyaWdnZXJzIGNoYW5nZSBub3RpZmljYXRpb24gaWYgdGhlIHByb3BlcnR5IGRvZXNuJ3RcbiAqIGFscmVhZHkgZXhpc3QuXG4gKi9cbmZ1bmN0aW9uIHNldCAodGFyZ2V0LCBrZXksIHZhbCkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIGlzVmFsaWRBcnJheUluZGV4KGtleSkpIHtcbiAgICB0YXJnZXQubGVuZ3RoID0gTWF0aC5tYXgodGFyZ2V0Lmxlbmd0aCwga2V5KTtcbiAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSwgdmFsKTtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgaWYgKGhhc093bih0YXJnZXQsIGtleSkpIHtcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgdmFyIG9iID0gKHRhcmdldCkuX19vYl9fO1xuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ0F2b2lkIGFkZGluZyByZWFjdGl2ZSBwcm9wZXJ0aWVzIHRvIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJ2F0IHJ1bnRpbWUgLSBkZWNsYXJlIGl0IHVwZnJvbnQgaW4gdGhlIGRhdGEgb3B0aW9uLidcbiAgICApO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBpZiAoIW9iKSB7XG4gICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGRlZmluZVJlYWN0aXZlJCQxKG9iLnZhbHVlLCBrZXksIHZhbCk7XG4gIG9iLmRlcC5ub3RpZnkoKTtcbiAgcmV0dXJuIHZhbFxufVxuXG4vKipcbiAqIERlbGV0ZSBhIHByb3BlcnR5IGFuZCB0cmlnZ2VyIGNoYW5nZSBpZiBuZWNlc3NhcnkuXG4gKi9cbmZ1bmN0aW9uIGRlbCAodGFyZ2V0LCBrZXkpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiBpc1ZhbGlkQXJyYXlJbmRleChrZXkpKSB7XG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEpO1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvYiA9ICh0YXJnZXQpLl9fb2JfXztcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdBdm9pZCBkZWxldGluZyBwcm9wZXJ0aWVzIG9uIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJy0ganVzdCBzZXQgaXQgdG8gbnVsbC4nXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoIWhhc093bih0YXJnZXQsIGtleSkpIHtcbiAgICByZXR1cm5cbiAgfVxuICBkZWxldGUgdGFyZ2V0W2tleV07XG4gIGlmICghb2IpIHtcbiAgICByZXR1cm5cbiAgfVxuICBvYi5kZXAubm90aWZ5KCk7XG59XG5cbi8qKlxuICogQ29sbGVjdCBkZXBlbmRlbmNpZXMgb24gYXJyYXkgZWxlbWVudHMgd2hlbiB0aGUgYXJyYXkgaXMgdG91Y2hlZCwgc2luY2VcbiAqIHdlIGNhbm5vdCBpbnRlcmNlcHQgYXJyYXkgZWxlbWVudCBhY2Nlc3MgbGlrZSBwcm9wZXJ0eSBnZXR0ZXJzLlxuICovXG5mdW5jdGlvbiBkZXBlbmRBcnJheSAodmFsdWUpIHtcbiAgZm9yICh2YXIgZSA9ICh2b2lkIDApLCBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGUgPSB2YWx1ZVtpXTtcbiAgICBlICYmIGUuX19vYl9fICYmIGUuX19vYl9fLmRlcC5kZXBlbmQoKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlKSkge1xuICAgICAgZGVwZW5kQXJyYXkoZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIE9wdGlvbiBvdmVyd3JpdGluZyBzdHJhdGVnaWVzIGFyZSBmdW5jdGlvbnMgdGhhdCBoYW5kbGVcbiAqIGhvdyB0byBtZXJnZSBhIHBhcmVudCBvcHRpb24gdmFsdWUgYW5kIGEgY2hpbGQgb3B0aW9uXG4gKiB2YWx1ZSBpbnRvIHRoZSBmaW5hbCB2YWx1ZS5cbiAqL1xudmFyIHN0cmF0cyA9IGNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXM7XG5cbi8qKlxuICogT3B0aW9ucyB3aXRoIHJlc3RyaWN0aW9uc1xuICovXG57XG4gIHN0cmF0cy5lbCA9IHN0cmF0cy5wcm9wc0RhdGEgPSBmdW5jdGlvbiAocGFyZW50LCBjaGlsZCwgdm0sIGtleSkge1xuICAgIGlmICghdm0pIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwib3B0aW9uIFxcXCJcIiArIGtleSArIFwiXFxcIiBjYW4gb25seSBiZSB1c2VkIGR1cmluZyBpbnN0YW5jZSBcIiArXG4gICAgICAgICdjcmVhdGlvbiB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkLidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0U3RyYXQocGFyZW50LCBjaGlsZClcbiAgfTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdGhhdCByZWN1cnNpdmVseSBtZXJnZXMgdHdvIGRhdGEgb2JqZWN0cyB0b2dldGhlci5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VEYXRhICh0bywgZnJvbSkge1xuICBpZiAoIWZyb20pIHsgcmV0dXJuIHRvIH1cbiAgdmFyIGtleSwgdG9WYWwsIGZyb21WYWw7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJvbSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgdG9WYWwgPSB0b1trZXldO1xuICAgIGZyb21WYWwgPSBmcm9tW2tleV07XG4gICAgaWYgKCFoYXNPd24odG8sIGtleSkpIHtcbiAgICAgIHNldCh0bywga2V5LCBmcm9tVmFsKTtcbiAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodG9WYWwpICYmIGlzUGxhaW5PYmplY3QoZnJvbVZhbCkpIHtcbiAgICAgIG1lcmdlRGF0YSh0b1ZhbCwgZnJvbVZhbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0b1xufVxuXG4vKipcbiAqIERhdGFcbiAqL1xuZnVuY3Rpb24gbWVyZ2VEYXRhT3JGbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtXG4pIHtcbiAgaWYgKCF2bSkge1xuICAgIC8vIGluIGEgVnVlLmV4dGVuZCBtZXJnZSwgYm90aCBzaG91bGQgYmUgZnVuY3Rpb25zXG4gICAgaWYgKCFjaGlsZFZhbCkge1xuICAgICAgcmV0dXJuIHBhcmVudFZhbFxuICAgIH1cbiAgICBpZiAoIXBhcmVudFZhbCkge1xuICAgICAgcmV0dXJuIGNoaWxkVmFsXG4gICAgfVxuICAgIC8vIHdoZW4gcGFyZW50VmFsICYgY2hpbGRWYWwgYXJlIGJvdGggcHJlc2VudCxcbiAgICAvLyB3ZSBuZWVkIHRvIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcbiAgICAvLyBtZXJnZWQgcmVzdWx0IG9mIGJvdGggZnVuY3Rpb25zLi4uIG5vIG5lZWQgdG9cbiAgICAvLyBjaGVjayBpZiBwYXJlbnRWYWwgaXMgYSBmdW5jdGlvbiBoZXJlIGJlY2F1c2VcbiAgICAvLyBpdCBoYXMgdG8gYmUgYSBmdW5jdGlvbiB0byBwYXNzIHByZXZpb3VzIG1lcmdlcy5cbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkRGF0YUZuICgpIHtcbiAgICAgIHJldHVybiBtZXJnZURhdGEoXG4gICAgICAgIHR5cGVvZiBjaGlsZFZhbCA9PT0gJ2Z1bmN0aW9uJyA/IGNoaWxkVmFsLmNhbGwodGhpcykgOiBjaGlsZFZhbCxcbiAgICAgICAgcGFyZW50VmFsLmNhbGwodGhpcylcbiAgICAgIClcbiAgICB9XG4gIH0gZWxzZSBpZiAocGFyZW50VmFsIHx8IGNoaWxkVmFsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZEluc3RhbmNlRGF0YUZuICgpIHtcbiAgICAgIC8vIGluc3RhbmNlIG1lcmdlXG4gICAgICB2YXIgaW5zdGFuY2VEYXRhID0gdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gY2hpbGRWYWwuY2FsbCh2bSlcbiAgICAgICAgOiBjaGlsZFZhbDtcbiAgICAgIHZhciBkZWZhdWx0RGF0YSA9IHR5cGVvZiBwYXJlbnRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBwYXJlbnRWYWwuY2FsbCh2bSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAoaW5zdGFuY2VEYXRhKSB7XG4gICAgICAgIHJldHVybiBtZXJnZURhdGEoaW5zdGFuY2VEYXRhLCBkZWZhdWx0RGF0YSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0RGF0YVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5zdHJhdHMuZGF0YSA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm1cbikge1xuICBpZiAoIXZtKSB7XG4gICAgaWYgKGNoaWxkVmFsICYmIHR5cGVvZiBjaGlsZFZhbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ1RoZSBcImRhdGFcIiBvcHRpb24gc2hvdWxkIGJlIGEgZnVuY3Rpb24gJyArXG4gICAgICAgICd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgK1xuICAgICAgICAnZGVmaW5pdGlvbnMuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlRGF0YU9yRm4uY2FsbCh0aGlzLCBwYXJlbnRWYWwsIGNoaWxkVmFsKVxuICB9XG5cbiAgcmV0dXJuIG1lcmdlRGF0YU9yRm4ocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pXG59O1xuXG4vKipcbiAqIEhvb2tzIGFuZCBwcm9wcyBhcmUgbWVyZ2VkIGFzIGFycmF5cy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VIb29rIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbFxuKSB7XG4gIHJldHVybiBjaGlsZFZhbFxuICAgID8gcGFyZW50VmFsXG4gICAgICA/IHBhcmVudFZhbC5jb25jYXQoY2hpbGRWYWwpXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRWYWwpXG4gICAgICAgID8gY2hpbGRWYWxcbiAgICAgICAgOiBbY2hpbGRWYWxdXG4gICAgOiBwYXJlbnRWYWxcbn1cblxuTElGRUNZQ0xFX0hPT0tTLmZvckVhY2goZnVuY3Rpb24gKGhvb2spIHtcbiAgc3RyYXRzW2hvb2tdID0gbWVyZ2VIb29rO1xufSk7XG5cbi8qKlxuICogQXNzZXRzXG4gKlxuICogV2hlbiBhIHZtIGlzIHByZXNlbnQgKGluc3RhbmNlIGNyZWF0aW9uKSwgd2UgbmVlZCB0byBkb1xuICogYSB0aHJlZS13YXkgbWVyZ2UgYmV0d2VlbiBjb25zdHJ1Y3RvciBvcHRpb25zLCBpbnN0YW5jZVxuICogb3B0aW9ucyBhbmQgcGFyZW50IG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlQXNzZXRzIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKTtcbiAgcmV0dXJuIGNoaWxkVmFsXG4gICAgPyBleHRlbmQocmVzLCBjaGlsZFZhbClcbiAgICA6IHJlc1xufVxuXG5BU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gIHN0cmF0c1t0eXBlICsgJ3MnXSA9IG1lcmdlQXNzZXRzO1xufSk7XG5cbi8qKlxuICogV2F0Y2hlcnMuXG4gKlxuICogV2F0Y2hlcnMgaGFzaGVzIHNob3VsZCBub3Qgb3ZlcndyaXRlIG9uZVxuICogYW5vdGhlciwgc28gd2UgbWVyZ2UgdGhlbSBhcyBhcnJheXMuXG4gKi9cbnN0cmF0cy53YXRjaCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIC8vIHdvcmsgYXJvdW5kIEZpcmVmb3gncyBPYmplY3QucHJvdG90eXBlLndhdGNoLi4uXG4gIGlmIChwYXJlbnRWYWwgPT09IG5hdGl2ZVdhdGNoKSB7IHBhcmVudFZhbCA9IHVuZGVmaW5lZDsgfVxuICBpZiAoY2hpbGRWYWwgPT09IG5hdGl2ZVdhdGNoKSB7IGNoaWxkVmFsID0gdW5kZWZpbmVkOyB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNoaWxkVmFsKSB7IHJldHVybiBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKSB9XG4gIGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XG4gIHZhciByZXQgPSB7fTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgZm9yICh2YXIga2V5IGluIGNoaWxkVmFsKSB7XG4gICAgdmFyIHBhcmVudCA9IHJldFtrZXldO1xuICAgIHZhciBjaGlsZCA9IGNoaWxkVmFsW2tleV07XG4gICAgaWYgKHBhcmVudCAmJiAhQXJyYXkuaXNBcnJheShwYXJlbnQpKSB7XG4gICAgICBwYXJlbnQgPSBbcGFyZW50XTtcbiAgICB9XG4gICAgcmV0W2tleV0gPSBwYXJlbnRcbiAgICAgID8gcGFyZW50LmNvbmNhdChjaGlsZClcbiAgICAgIDogQXJyYXkuaXNBcnJheShjaGlsZCkgPyBjaGlsZCA6IFtjaGlsZF07XG4gIH1cbiAgcmV0dXJuIHJldFxufTtcblxuLyoqXG4gKiBPdGhlciBvYmplY3QgaGFzaGVzLlxuICovXG5zdHJhdHMucHJvcHMgPVxuc3RyYXRzLm1ldGhvZHMgPVxuc3RyYXRzLmluamVjdCA9XG5zdHJhdHMuY29tcHV0ZWQgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICBpZiAoIWNoaWxkVmFsKSB7IHJldHVybiBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKSB9XG4gIGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XG4gIHZhciByZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICBleHRlbmQocmV0LCBjaGlsZFZhbCk7XG4gIHJldHVybiByZXRcbn07XG5zdHJhdHMucHJvdmlkZSA9IG1lcmdlRGF0YU9yRm47XG5cbi8qKlxuICogRGVmYXVsdCBzdHJhdGVneS5cbiAqL1xudmFyIGRlZmF1bHRTdHJhdCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIHJldHVybiBjaGlsZFZhbCA9PT0gdW5kZWZpbmVkXG4gICAgPyBwYXJlbnRWYWxcbiAgICA6IGNoaWxkVmFsXG59O1xuXG4vKipcbiAqIFZhbGlkYXRlIGNvbXBvbmVudCBuYW1lc1xuICovXG5mdW5jdGlvbiBjaGVja0NvbXBvbmVudHMgKG9wdGlvbnMpIHtcbiAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMuY29tcG9uZW50cykge1xuICAgIHZhciBsb3dlciA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChpc0J1aWx0SW5UYWcobG93ZXIpIHx8IGNvbmZpZy5pc1Jlc2VydmVkVGFnKGxvd2VyKSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0RvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgJyArXG4gICAgICAgICdpZDogJyArIGtleVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBFbnN1cmUgYWxsIHByb3BzIG9wdGlvbiBzeW50YXggYXJlIG5vcm1hbGl6ZWQgaW50byB0aGVcbiAqIE9iamVjdC1iYXNlZCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzIChvcHRpb25zKSB7XG4gIHZhciBwcm9wcyA9IG9wdGlvbnMucHJvcHM7XG4gIGlmICghcHJvcHMpIHsgcmV0dXJuIH1cbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgaSwgdmFsLCBuYW1lO1xuICBpZiAoQXJyYXkuaXNBcnJheShwcm9wcykpIHtcbiAgICBpID0gcHJvcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhbCA9IHByb3BzW2ldO1xuICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG5hbWUgPSBjYW1lbGl6ZSh2YWwpO1xuICAgICAgICByZXNbbmFtZV0gPSB7IHR5cGU6IG51bGwgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4oJ3Byb3BzIG11c3QgYmUgc3RyaW5ncyB3aGVuIHVzaW5nIGFycmF5IHN5bnRheC4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChwcm9wcykpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIHZhbCA9IHByb3BzW2tleV07XG4gICAgICBuYW1lID0gY2FtZWxpemUoa2V5KTtcbiAgICAgIHJlc1tuYW1lXSA9IGlzUGxhaW5PYmplY3QodmFsKVxuICAgICAgICA/IHZhbFxuICAgICAgICA6IHsgdHlwZTogdmFsIH07XG4gICAgfVxuICB9XG4gIG9wdGlvbnMucHJvcHMgPSByZXM7XG59XG5cbi8qKlxuICogTm9ybWFsaXplIGFsbCBpbmplY3Rpb25zIGludG8gT2JqZWN0LWJhc2VkIGZvcm1hdFxuICovXG5mdW5jdGlvbiBub3JtYWxpemVJbmplY3QgKG9wdGlvbnMpIHtcbiAgdmFyIGluamVjdCA9IG9wdGlvbnMuaW5qZWN0O1xuICBpZiAoQXJyYXkuaXNBcnJheShpbmplY3QpKSB7XG4gICAgdmFyIG5vcm1hbGl6ZWQgPSBvcHRpb25zLmluamVjdCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5qZWN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBub3JtYWxpemVkW2luamVjdFtpXV0gPSBpbmplY3RbaV07XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogTm9ybWFsaXplIHJhdyBmdW5jdGlvbiBkaXJlY3RpdmVzIGludG8gb2JqZWN0IGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyAob3B0aW9ucykge1xuICB2YXIgZGlycyA9IG9wdGlvbnMuZGlyZWN0aXZlcztcbiAgaWYgKGRpcnMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZGlycykge1xuICAgICAgdmFyIGRlZiA9IGRpcnNba2V5XTtcbiAgICAgIGlmICh0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGRpcnNba2V5XSA9IHsgYmluZDogZGVmLCB1cGRhdGU6IGRlZiB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIE1lcmdlIHR3byBvcHRpb24gb2JqZWN0cyBpbnRvIGEgbmV3IG9uZS5cbiAqIENvcmUgdXRpbGl0eSB1c2VkIGluIGJvdGggaW5zdGFudGlhdGlvbiBhbmQgaW5oZXJpdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyAoXG4gIHBhcmVudCxcbiAgY2hpbGQsXG4gIHZtXG4pIHtcbiAge1xuICAgIGNoZWNrQ29tcG9uZW50cyhjaGlsZCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGNoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2hpbGQgPSBjaGlsZC5vcHRpb25zO1xuICB9XG5cbiAgbm9ybWFsaXplUHJvcHMoY2hpbGQpO1xuICBub3JtYWxpemVJbmplY3QoY2hpbGQpO1xuICBub3JtYWxpemVEaXJlY3RpdmVzKGNoaWxkKTtcbiAgdmFyIGV4dGVuZHNGcm9tID0gY2hpbGQuZXh0ZW5kcztcbiAgaWYgKGV4dGVuZHNGcm9tKSB7XG4gICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgZXh0ZW5kc0Zyb20sIHZtKTtcbiAgfVxuICBpZiAoY2hpbGQubWl4aW5zKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZC5taXhpbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZC5taXhpbnNbaV0sIHZtKTtcbiAgICB9XG4gIH1cbiAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gcGFyZW50KSB7XG4gICAgbWVyZ2VGaWVsZChrZXkpO1xuICB9XG4gIGZvciAoa2V5IGluIGNoaWxkKSB7XG4gICAgaWYgKCFoYXNPd24ocGFyZW50LCBrZXkpKSB7XG4gICAgICBtZXJnZUZpZWxkKGtleSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1lcmdlRmllbGQgKGtleSkge1xuICAgIHZhciBzdHJhdCA9IHN0cmF0c1trZXldIHx8IGRlZmF1bHRTdHJhdDtcbiAgICBvcHRpb25zW2tleV0gPSBzdHJhdChwYXJlbnRba2V5XSwgY2hpbGRba2V5XSwgdm0sIGtleSk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGFuIGFzc2V0LlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJlY2F1c2UgY2hpbGQgaW5zdGFuY2VzIG5lZWQgYWNjZXNzXG4gKiB0byBhc3NldHMgZGVmaW5lZCBpbiBpdHMgYW5jZXN0b3IgY2hhaW4uXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVBc3NldCAoXG4gIG9wdGlvbnMsXG4gIHR5cGUsXG4gIGlkLFxuICB3YXJuTWlzc2luZ1xuKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBhc3NldHMgPSBvcHRpb25zW3R5cGVdO1xuICAvLyBjaGVjayBsb2NhbCByZWdpc3RyYXRpb24gdmFyaWF0aW9ucyBmaXJzdFxuICBpZiAoaGFzT3duKGFzc2V0cywgaWQpKSB7IHJldHVybiBhc3NldHNbaWRdIH1cbiAgdmFyIGNhbWVsaXplZElkID0gY2FtZWxpemUoaWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgY2FtZWxpemVkSWQpKSB7IHJldHVybiBhc3NldHNbY2FtZWxpemVkSWRdIH1cbiAgdmFyIFBhc2NhbENhc2VJZCA9IGNhcGl0YWxpemUoY2FtZWxpemVkSWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgUGFzY2FsQ2FzZUlkKSkgeyByZXR1cm4gYXNzZXRzW1Bhc2NhbENhc2VJZF0gfVxuICAvLyBmYWxsYmFjayB0byBwcm90b3R5cGUgY2hhaW5cbiAgdmFyIHJlcyA9IGFzc2V0c1tpZF0gfHwgYXNzZXRzW2NhbWVsaXplZElkXSB8fCBhc3NldHNbUGFzY2FsQ2FzZUlkXTtcbiAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm5NaXNzaW5nICYmICFyZXMpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ZhaWxlZCB0byByZXNvbHZlICcgKyB0eXBlLnNsaWNlKDAsIC0xKSArICc6ICcgKyBpZCxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcCAoXG4gIGtleSxcbiAgcHJvcE9wdGlvbnMsXG4gIHByb3BzRGF0YSxcbiAgdm1cbikge1xuICB2YXIgcHJvcCA9IHByb3BPcHRpb25zW2tleV07XG4gIHZhciBhYnNlbnQgPSAhaGFzT3duKHByb3BzRGF0YSwga2V5KTtcbiAgdmFyIHZhbHVlID0gcHJvcHNEYXRhW2tleV07XG4gIC8vIGhhbmRsZSBib29sZWFuIHByb3BzXG4gIGlmIChpc1R5cGUoQm9vbGVhbiwgcHJvcC50eXBlKSkge1xuICAgIGlmIChhYnNlbnQgJiYgIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoIWlzVHlwZShTdHJpbmcsIHByb3AudHlwZSkgJiYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gaHlwaGVuYXRlKGtleSkpKSB7XG4gICAgICB2YWx1ZSA9IHRydWU7XG4gICAgfVxuICB9XG4gIC8vIGNoZWNrIGRlZmF1bHQgdmFsdWVcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICB2YWx1ZSA9IGdldFByb3BEZWZhdWx0VmFsdWUodm0sIHByb3AsIGtleSk7XG4gICAgLy8gc2luY2UgdGhlIGRlZmF1bHQgdmFsdWUgaXMgYSBmcmVzaCBjb3B5LFxuICAgIC8vIG1ha2Ugc3VyZSB0byBvYnNlcnZlIGl0LlxuICAgIHZhciBwcmV2U2hvdWxkQ29udmVydCA9IG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydDtcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xuICAgIG9ic2VydmUodmFsdWUpO1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHByZXZTaG91bGRDb252ZXJ0O1xuICB9XG4gIHtcbiAgICBhc3NlcnRQcm9wKHByb3AsIGtleSwgdmFsdWUsIHZtLCBhYnNlbnQpO1xuICB9XG4gIHJldHVybiB2YWx1ZVxufVxuXG4vKipcbiAqIEdldCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBhIHByb3AuXG4gKi9cbmZ1bmN0aW9uIGdldFByb3BEZWZhdWx0VmFsdWUgKHZtLCBwcm9wLCBrZXkpIHtcbiAgLy8gbm8gZGVmYXVsdCwgcmV0dXJuIHVuZGVmaW5lZFxuICBpZiAoIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG4gIHZhciBkZWYgPSBwcm9wLmRlZmF1bHQ7XG4gIC8vIHdhcm4gYWdhaW5zdCBub24tZmFjdG9yeSBkZWZhdWx0cyBmb3IgT2JqZWN0ICYgQXJyYXlcbiAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzT2JqZWN0KGRlZikpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ludmFsaWQgZGVmYXVsdCB2YWx1ZSBmb3IgcHJvcCBcIicgKyBrZXkgKyAnXCI6ICcgK1xuICAgICAgJ1Byb3BzIHdpdGggdHlwZSBPYmplY3QvQXJyYXkgbXVzdCB1c2UgYSBmYWN0b3J5IGZ1bmN0aW9uICcgK1xuICAgICAgJ3RvIHJldHVybiB0aGUgZGVmYXVsdCB2YWx1ZS4nLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIC8vIHRoZSByYXcgcHJvcCB2YWx1ZSB3YXMgYWxzbyB1bmRlZmluZWQgZnJvbSBwcmV2aW91cyByZW5kZXIsXG4gIC8vIHJldHVybiBwcmV2aW91cyBkZWZhdWx0IHZhbHVlIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHdhdGNoZXIgdHJpZ2dlclxuICBpZiAodm0gJiYgdm0uJG9wdGlvbnMucHJvcHNEYXRhICYmXG4gICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhW2tleV0gPT09IHVuZGVmaW5lZCAmJlxuICAgIHZtLl9wcm9wc1trZXldICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgcmV0dXJuIHZtLl9wcm9wc1trZXldXG4gIH1cbiAgLy8gY2FsbCBmYWN0b3J5IGZ1bmN0aW9uIGZvciBub24tRnVuY3Rpb24gdHlwZXNcbiAgLy8gYSB2YWx1ZSBpcyBGdW5jdGlvbiBpZiBpdHMgcHJvdG90eXBlIGlzIGZ1bmN0aW9uIGV2ZW4gYWNyb3NzIGRpZmZlcmVudCBleGVjdXRpb24gY29udGV4dFxuICByZXR1cm4gdHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBnZXRUeXBlKHByb3AudHlwZSkgIT09ICdGdW5jdGlvbidcbiAgICA/IGRlZi5jYWxsKHZtKVxuICAgIDogZGVmXG59XG5cbi8qKlxuICogQXNzZXJ0IHdoZXRoZXIgYSBwcm9wIGlzIHZhbGlkLlxuICovXG5mdW5jdGlvbiBhc3NlcnRQcm9wIChcbiAgcHJvcCxcbiAgbmFtZSxcbiAgdmFsdWUsXG4gIHZtLFxuICBhYnNlbnRcbikge1xuICBpZiAocHJvcC5yZXF1aXJlZCAmJiBhYnNlbnQpIHtcbiAgICB3YXJuKFxuICAgICAgJ01pc3NpbmcgcmVxdWlyZWQgcHJvcDogXCInICsgbmFtZSArICdcIicsXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgJiYgIXByb3AucmVxdWlyZWQpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdHlwZSA9IHByb3AudHlwZTtcbiAgdmFyIHZhbGlkID0gIXR5cGUgfHwgdHlwZSA9PT0gdHJ1ZTtcbiAgdmFyIGV4cGVjdGVkVHlwZXMgPSBbXTtcbiAgaWYgKHR5cGUpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgIHR5cGUgPSBbdHlwZV07XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZS5sZW5ndGggJiYgIXZhbGlkOyBpKyspIHtcbiAgICAgIHZhciBhc3NlcnRlZFR5cGUgPSBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlW2ldKTtcbiAgICAgIGV4cGVjdGVkVHlwZXMucHVzaChhc3NlcnRlZFR5cGUuZXhwZWN0ZWRUeXBlIHx8ICcnKTtcbiAgICAgIHZhbGlkID0gYXNzZXJ0ZWRUeXBlLnZhbGlkO1xuICAgIH1cbiAgfVxuICBpZiAoIXZhbGlkKSB7XG4gICAgd2FybihcbiAgICAgICdJbnZhbGlkIHByb3A6IHR5cGUgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIG5hbWUgKyAnXCIuJyArXG4gICAgICAnIEV4cGVjdGVkICcgKyBleHBlY3RlZFR5cGVzLm1hcChjYXBpdGFsaXplKS5qb2luKCcsICcpICtcbiAgICAgICcsIGdvdCAnICsgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSkgKyAnLicsXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHZhbGlkYXRvciA9IHByb3AudmFsaWRhdG9yO1xuICBpZiAodmFsaWRhdG9yKSB7XG4gICAgaWYgKCF2YWxpZGF0b3IodmFsdWUpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnSW52YWxpZCBwcm9wOiBjdXN0b20gdmFsaWRhdG9yIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG52YXIgc2ltcGxlQ2hlY2tSRSA9IC9eKFN0cmluZ3xOdW1iZXJ8Qm9vbGVhbnxGdW5jdGlvbnxTeW1ib2wpJC87XG5cbmZ1bmN0aW9uIGFzc2VydFR5cGUgKHZhbHVlLCB0eXBlKSB7XG4gIHZhciB2YWxpZDtcbiAgdmFyIGV4cGVjdGVkVHlwZSA9IGdldFR5cGUodHlwZSk7XG4gIGlmIChzaW1wbGVDaGVja1JFLnRlc3QoZXhwZWN0ZWRUeXBlKSkge1xuICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSBleHBlY3RlZFR5cGUudG9Mb3dlckNhc2UoKTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdPYmplY3QnKSB7XG4gICAgdmFsaWQgPSBpc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdBcnJheScpIHtcbiAgICB2YWxpZCA9IEFycmF5LmlzQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICB9XG4gIHJldHVybiB7XG4gICAgdmFsaWQ6IHZhbGlkLFxuICAgIGV4cGVjdGVkVHlwZTogZXhwZWN0ZWRUeXBlXG4gIH1cbn1cblxuLyoqXG4gKiBVc2UgZnVuY3Rpb24gc3RyaW5nIG5hbWUgdG8gY2hlY2sgYnVpbHQtaW4gdHlwZXMsXG4gKiBiZWNhdXNlIGEgc2ltcGxlIGVxdWFsaXR5IGNoZWNrIHdpbGwgZmFpbCB3aGVuIHJ1bm5pbmdcbiAqIGFjcm9zcyBkaWZmZXJlbnQgdm1zIC8gaWZyYW1lcy5cbiAqL1xuZnVuY3Rpb24gZ2V0VHlwZSAoZm4pIHtcbiAgdmFyIG1hdGNoID0gZm4gJiYgZm4udG9TdHJpbmcoKS5tYXRjaCgvXlxccypmdW5jdGlvbiAoXFx3KykvKTtcbiAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiAnJ1xufVxuXG5mdW5jdGlvbiBpc1R5cGUgKHR5cGUsIGZuKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShmbikpIHtcbiAgICByZXR1cm4gZ2V0VHlwZShmbikgPT09IGdldFR5cGUodHlwZSlcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gZm4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZ2V0VHlwZShmbltpXSkgPT09IGdldFR5cGUodHlwZSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiBmYWxzZVxufVxuXG4vKiAgKi9cblxudmFyIG1hcms7XG52YXIgbWVhc3VyZTtcblxue1xuICB2YXIgcGVyZiA9IGluQnJvd3NlciAmJiB3aW5kb3cucGVyZm9ybWFuY2U7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoXG4gICAgcGVyZiAmJlxuICAgIHBlcmYubWFyayAmJlxuICAgIHBlcmYubWVhc3VyZSAmJlxuICAgIHBlcmYuY2xlYXJNYXJrcyAmJlxuICAgIHBlcmYuY2xlYXJNZWFzdXJlc1xuICApIHtcbiAgICBtYXJrID0gZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gcGVyZi5tYXJrKHRhZyk7IH07XG4gICAgbWVhc3VyZSA9IGZ1bmN0aW9uIChuYW1lLCBzdGFydFRhZywgZW5kVGFnKSB7XG4gICAgICBwZXJmLm1lYXN1cmUobmFtZSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWFya3Moc3RhcnRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1hcmtzKGVuZFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWVhc3VyZXMobmFtZSk7XG4gICAgfTtcbiAgfVxufVxuXG4vKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGggUHJveHkgKi9cblxudmFyIGluaXRQcm94eTtcblxue1xuICB2YXIgYWxsb3dlZEdsb2JhbHMgPSBtYWtlTWFwKFxuICAgICdJbmZpbml0eSx1bmRlZmluZWQsTmFOLGlzRmluaXRlLGlzTmFOLCcgK1xuICAgICdwYXJzZUZsb2F0LHBhcnNlSW50LGRlY29kZVVSSSxkZWNvZGVVUklDb21wb25lbnQsZW5jb2RlVVJJLGVuY29kZVVSSUNvbXBvbmVudCwnICtcbiAgICAnTWF0aCxOdW1iZXIsRGF0ZSxBcnJheSxPYmplY3QsQm9vbGVhbixTdHJpbmcsUmVnRXhwLE1hcCxTZXQsSlNPTixJbnRsLCcgK1xuICAgICdyZXF1aXJlJyAvLyBmb3IgV2VicGFjay9Ccm93c2VyaWZ5XG4gICk7XG5cbiAgdmFyIHdhcm5Ob25QcmVzZW50ID0gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XG4gICAgd2FybihcbiAgICAgIFwiUHJvcGVydHkgb3IgbWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBub3QgZGVmaW5lZCBvbiB0aGUgaW5zdGFuY2UgYnV0IFwiICtcbiAgICAgIFwicmVmZXJlbmNlZCBkdXJpbmcgcmVuZGVyLiBNYWtlIHN1cmUgdG8gZGVjbGFyZSByZWFjdGl2ZSBkYXRhIFwiICtcbiAgICAgIFwicHJvcGVydGllcyBpbiB0aGUgZGF0YSBvcHRpb24uXCIsXG4gICAgICB0YXJnZXRcbiAgICApO1xuICB9O1xuXG4gIHZhciBoYXNQcm94eSA9XG4gICAgdHlwZW9mIFByb3h5ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIFByb3h5LnRvU3RyaW5nKCkubWF0Y2goL25hdGl2ZSBjb2RlLyk7XG5cbiAgaWYgKGhhc1Byb3h5KSB7XG4gICAgdmFyIGlzQnVpbHRJbk1vZGlmaWVyID0gbWFrZU1hcCgnc3RvcCxwcmV2ZW50LHNlbGYsY3RybCxzaGlmdCxhbHQsbWV0YScpO1xuICAgIGNvbmZpZy5rZXlDb2RlcyA9IG5ldyBQcm94eShjb25maWcua2V5Q29kZXMsIHtcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGlzQnVpbHRJbk1vZGlmaWVyKGtleSkpIHtcbiAgICAgICAgICB3YXJuKChcIkF2b2lkIG92ZXJ3cml0aW5nIGJ1aWx0LWluIG1vZGlmaWVyIGluIGNvbmZpZy5rZXlDb2RlczogLlwiICsga2V5KSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB2YXIgaGFzSGFuZGxlciA9IHtcbiAgICBoYXM6IGZ1bmN0aW9uIGhhcyAodGFyZ2V0LCBrZXkpIHtcbiAgICAgIHZhciBoYXMgPSBrZXkgaW4gdGFyZ2V0O1xuICAgICAgdmFyIGlzQWxsb3dlZCA9IGFsbG93ZWRHbG9iYWxzKGtleSkgfHwga2V5LmNoYXJBdCgwKSA9PT0gJ18nO1xuICAgICAgaWYgKCFoYXMgJiYgIWlzQWxsb3dlZCkge1xuICAgICAgICB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzIHx8ICFpc0FsbG93ZWRcbiAgICB9XG4gIH07XG5cbiAgdmFyIGdldEhhbmRsZXIgPSB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQgKHRhcmdldCwga2V5KSB7XG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYgIShrZXkgaW4gdGFyZ2V0KSkge1xuICAgICAgICB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0W2tleV1cbiAgICB9XG4gIH07XG5cbiAgaW5pdFByb3h5ID0gZnVuY3Rpb24gaW5pdFByb3h5ICh2bSkge1xuICAgIGlmIChoYXNQcm94eSkge1xuICAgICAgLy8gZGV0ZXJtaW5lIHdoaWNoIHByb3h5IGhhbmRsZXIgdG8gdXNlXG4gICAgICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuICAgICAgdmFyIGhhbmRsZXJzID0gb3B0aW9ucy5yZW5kZXIgJiYgb3B0aW9ucy5yZW5kZXIuX3dpdGhTdHJpcHBlZFxuICAgICAgICA/IGdldEhhbmRsZXJcbiAgICAgICAgOiBoYXNIYW5kbGVyO1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gbmV3IFByb3h5KHZtLCBoYW5kbGVycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IHZtO1xuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cbnZhciBWTm9kZSA9IGZ1bmN0aW9uIFZOb2RlIChcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgdGV4dCxcbiAgZWxtLFxuICBjb250ZXh0LFxuICBjb21wb25lbnRPcHRpb25zLFxuICBhc3luY0ZhY3Rvcnlcbikge1xuICB0aGlzLnRhZyA9IHRhZztcbiAgdGhpcy5kYXRhID0gZGF0YTtcbiAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB0aGlzLnRleHQgPSB0ZXh0O1xuICB0aGlzLmVsbSA9IGVsbTtcbiAgdGhpcy5ucyA9IHVuZGVmaW5lZDtcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5mdW5jdGlvbmFsQ29udGV4dCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5rZXkgPSBkYXRhICYmIGRhdGEua2V5O1xuICB0aGlzLmNvbXBvbmVudE9wdGlvbnMgPSBjb21wb25lbnRPcHRpb25zO1xuICB0aGlzLmNvbXBvbmVudEluc3RhbmNlID0gdW5kZWZpbmVkO1xuICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5yYXcgPSBmYWxzZTtcbiAgdGhpcy5pc1N0YXRpYyA9IGZhbHNlO1xuICB0aGlzLmlzUm9vdEluc2VydCA9IHRydWU7XG4gIHRoaXMuaXNDb21tZW50ID0gZmFsc2U7XG4gIHRoaXMuaXNDbG9uZWQgPSBmYWxzZTtcbiAgdGhpcy5pc09uY2UgPSBmYWxzZTtcbiAgdGhpcy5hc3luY0ZhY3RvcnkgPSBhc3luY0ZhY3Rvcnk7XG4gIHRoaXMuYXN5bmNNZXRhID0gdW5kZWZpbmVkO1xuICB0aGlzLmlzQXN5bmNQbGFjZWhvbGRlciA9IGZhbHNlO1xufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgY2hpbGQ6IHt9IH07XG5cbi8vIERFUFJFQ0FURUQ6IGFsaWFzIGZvciBjb21wb25lbnRJbnN0YW5jZSBmb3IgYmFja3dhcmRzIGNvbXBhdC5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5wcm90b3R5cGVBY2Nlc3NvcnMuY2hpbGQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jb21wb25lbnRJbnN0YW5jZVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFZOb2RlLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbnZhciBjcmVhdGVFbXB0eVZOb2RlID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgaWYgKCB0ZXh0ID09PSB2b2lkIDAgKSB0ZXh0ID0gJyc7XG5cbiAgdmFyIG5vZGUgPSBuZXcgVk5vZGUoKTtcbiAgbm9kZS50ZXh0ID0gdGV4dDtcbiAgbm9kZS5pc0NvbW1lbnQgPSB0cnVlO1xuICByZXR1cm4gbm9kZVxufTtcblxuZnVuY3Rpb24gY3JlYXRlVGV4dFZOb2RlICh2YWwpIHtcbiAgcmV0dXJuIG5ldyBWTm9kZSh1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBTdHJpbmcodmFsKSlcbn1cblxuLy8gb3B0aW1pemVkIHNoYWxsb3cgY2xvbmVcbi8vIHVzZWQgZm9yIHN0YXRpYyBub2RlcyBhbmQgc2xvdCBub2RlcyBiZWNhdXNlIHRoZXkgbWF5IGJlIHJldXNlZCBhY3Jvc3Ncbi8vIG11bHRpcGxlIHJlbmRlcnMsIGNsb25pbmcgdGhlbSBhdm9pZHMgZXJyb3JzIHdoZW4gRE9NIG1hbmlwdWxhdGlvbnMgcmVseVxuLy8gb24gdGhlaXIgZWxtIHJlZmVyZW5jZS5cbmZ1bmN0aW9uIGNsb25lVk5vZGUgKHZub2RlKSB7XG4gIHZhciBjbG9uZWQgPSBuZXcgVk5vZGUoXG4gICAgdm5vZGUudGFnLFxuICAgIHZub2RlLmRhdGEsXG4gICAgdm5vZGUuY2hpbGRyZW4sXG4gICAgdm5vZGUudGV4dCxcbiAgICB2bm9kZS5lbG0sXG4gICAgdm5vZGUuY29udGV4dCxcbiAgICB2bm9kZS5jb21wb25lbnRPcHRpb25zLFxuICAgIHZub2RlLmFzeW5jRmFjdG9yeVxuICApO1xuICBjbG9uZWQubnMgPSB2bm9kZS5ucztcbiAgY2xvbmVkLmlzU3RhdGljID0gdm5vZGUuaXNTdGF0aWM7XG4gIGNsb25lZC5rZXkgPSB2bm9kZS5rZXk7XG4gIGNsb25lZC5pc0NvbW1lbnQgPSB2bm9kZS5pc0NvbW1lbnQ7XG4gIGNsb25lZC5pc0Nsb25lZCA9IHRydWU7XG4gIHJldHVybiBjbG9uZWRcbn1cblxuZnVuY3Rpb24gY2xvbmVWTm9kZXMgKHZub2Rlcykge1xuICB2YXIgbGVuID0gdm5vZGVzLmxlbmd0aDtcbiAgdmFyIHJlcyA9IG5ldyBBcnJheShsZW4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcmVzW2ldID0gY2xvbmVWTm9kZSh2bm9kZXNbaV0pO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBub3JtYWxpemVFdmVudCA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgcGFzc2l2ZSA9IG5hbWUuY2hhckF0KDApID09PSAnJic7XG4gIG5hbWUgPSBwYXNzaXZlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHZhciBvbmNlJCQxID0gbmFtZS5jaGFyQXQoMCkgPT09ICd+JzsgLy8gUHJlZml4ZWQgbGFzdCwgY2hlY2tlZCBmaXJzdFxuICBuYW1lID0gb25jZSQkMSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICB2YXIgY2FwdHVyZSA9IG5hbWUuY2hhckF0KDApID09PSAnISc7XG4gIG5hbWUgPSBjYXB0dXJlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHJldHVybiB7XG4gICAgbmFtZTogbmFtZSxcbiAgICBvbmNlOiBvbmNlJCQxLFxuICAgIGNhcHR1cmU6IGNhcHR1cmUsXG4gICAgcGFzc2l2ZTogcGFzc2l2ZVxuICB9XG59KTtcblxuZnVuY3Rpb24gY3JlYXRlRm5JbnZva2VyIChmbnMpIHtcbiAgZnVuY3Rpb24gaW52b2tlciAoKSB7XG4gICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXG4gICAgdmFyIGZucyA9IGludm9rZXIuZm5zO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZucykpIHtcbiAgICAgIHZhciBjbG9uZWQgPSBmbnMuc2xpY2UoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xvbmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNsb25lZFtpXS5hcHBseShudWxsLCBhcmd1bWVudHMkMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJldHVybiBoYW5kbGVyIHJldHVybiB2YWx1ZSBmb3Igc2luZ2xlIGhhbmRsZXJzXG4gICAgICByZXR1cm4gZm5zLmFwcGx5KG51bGwsIGFyZ3VtZW50cylcbiAgICB9XG4gIH1cbiAgaW52b2tlci5mbnMgPSBmbnM7XG4gIHJldHVybiBpbnZva2VyXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpc3RlbmVycyAoXG4gIG9uLFxuICBvbGRPbixcbiAgYWRkLFxuICByZW1vdmUkJDEsXG4gIHZtXG4pIHtcbiAgdmFyIG5hbWUsIGN1ciwgb2xkLCBldmVudDtcbiAgZm9yIChuYW1lIGluIG9uKSB7XG4gICAgY3VyID0gb25bbmFtZV07XG4gICAgb2xkID0gb2xkT25bbmFtZV07XG4gICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICBpZiAoaXNVbmRlZihjdXIpKSB7XG4gICAgICBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkludmFsaWQgaGFuZGxlciBmb3IgZXZlbnQgXFxcIlwiICsgKGV2ZW50Lm5hbWUpICsgXCJcXFwiOiBnb3QgXCIgKyBTdHJpbmcoY3VyKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZCkpIHtcbiAgICAgIGlmIChpc1VuZGVmKGN1ci5mbnMpKSB7XG4gICAgICAgIGN1ciA9IG9uW25hbWVdID0gY3JlYXRlRm5JbnZva2VyKGN1cik7XG4gICAgICB9XG4gICAgICBhZGQoZXZlbnQubmFtZSwgY3VyLCBldmVudC5vbmNlLCBldmVudC5jYXB0dXJlLCBldmVudC5wYXNzaXZlKTtcbiAgICB9IGVsc2UgaWYgKGN1ciAhPT0gb2xkKSB7XG4gICAgICBvbGQuZm5zID0gY3VyO1xuICAgICAgb25bbmFtZV0gPSBvbGQ7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBvbGRPbikge1xuICAgIGlmIChpc1VuZGVmKG9uW25hbWVdKSkge1xuICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICAgIHJlbW92ZSQkMShldmVudC5uYW1lLCBvbGRPbltuYW1lXSwgZXZlbnQuY2FwdHVyZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBtZXJnZVZOb2RlSG9vayAoZGVmLCBob29rS2V5LCBob29rKSB7XG4gIHZhciBpbnZva2VyO1xuICB2YXIgb2xkSG9vayA9IGRlZltob29rS2V5XTtcblxuICBmdW5jdGlvbiB3cmFwcGVkSG9vayAoKSB7XG4gICAgaG9vay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIC8vIGltcG9ydGFudDogcmVtb3ZlIG1lcmdlZCBob29rIHRvIGVuc3VyZSBpdCdzIGNhbGxlZCBvbmx5IG9uY2VcbiAgICAvLyBhbmQgcHJldmVudCBtZW1vcnkgbGVha1xuICAgIHJlbW92ZShpbnZva2VyLmZucywgd3JhcHBlZEhvb2spO1xuICB9XG5cbiAgaWYgKGlzVW5kZWYob2xkSG9vaykpIHtcbiAgICAvLyBubyBleGlzdGluZyBob29rXG4gICAgaW52b2tlciA9IGNyZWF0ZUZuSW52b2tlcihbd3JhcHBlZEhvb2tdKTtcbiAgfSBlbHNlIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNEZWYob2xkSG9vay5mbnMpICYmIGlzVHJ1ZShvbGRIb29rLm1lcmdlZCkpIHtcbiAgICAgIC8vIGFscmVhZHkgYSBtZXJnZWQgaW52b2tlclxuICAgICAgaW52b2tlciA9IG9sZEhvb2s7XG4gICAgICBpbnZva2VyLmZucy5wdXNoKHdyYXBwZWRIb29rKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXhpc3RpbmcgcGxhaW4gaG9va1xuICAgICAgaW52b2tlciA9IGNyZWF0ZUZuSW52b2tlcihbb2xkSG9vaywgd3JhcHBlZEhvb2tdKTtcbiAgICB9XG4gIH1cblxuICBpbnZva2VyLm1lcmdlZCA9IHRydWU7XG4gIGRlZltob29rS2V5XSA9IGludm9rZXI7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhIChcbiAgZGF0YSxcbiAgQ3RvcixcbiAgdGFnXG4pIHtcbiAgLy8gd2UgYXJlIG9ubHkgZXh0cmFjdGluZyByYXcgdmFsdWVzIGhlcmUuXG4gIC8vIHZhbGlkYXRpb24gYW5kIGRlZmF1bHQgdmFsdWVzIGFyZSBoYW5kbGVkIGluIHRoZSBjaGlsZFxuICAvLyBjb21wb25lbnQgaXRzZWxmLlxuICB2YXIgcHJvcE9wdGlvbnMgPSBDdG9yLm9wdGlvbnMucHJvcHM7XG4gIGlmIChpc1VuZGVmKHByb3BPcHRpb25zKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGF0dHJzID0gZGF0YS5hdHRycztcbiAgdmFyIHByb3BzID0gZGF0YS5wcm9wcztcbiAgaWYgKGlzRGVmKGF0dHJzKSB8fCBpc0RlZihwcm9wcykpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcE9wdGlvbnMpIHtcbiAgICAgIHZhciBhbHRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgIHtcbiAgICAgICAgdmFyIGtleUluTG93ZXJDYXNlID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBrZXkgIT09IGtleUluTG93ZXJDYXNlICYmXG4gICAgICAgICAgYXR0cnMgJiYgaGFzT3duKGF0dHJzLCBrZXlJbkxvd2VyQ2FzZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGlwKFxuICAgICAgICAgICAgXCJQcm9wIFxcXCJcIiArIGtleUluTG93ZXJDYXNlICsgXCJcXFwiIGlzIHBhc3NlZCB0byBjb21wb25lbnQgXCIgK1xuICAgICAgICAgICAgKGZvcm1hdENvbXBvbmVudE5hbWUodGFnIHx8IEN0b3IpKSArIFwiLCBidXQgdGhlIGRlY2xhcmVkIHByb3AgbmFtZSBpc1wiICtcbiAgICAgICAgICAgIFwiIFxcXCJcIiArIGtleSArIFwiXFxcIi4gXCIgK1xuICAgICAgICAgICAgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCBjYW1lbENhc2VkIFwiICtcbiAgICAgICAgICAgIFwicHJvcHMgbmVlZCB0byB1c2UgdGhlaXIga2ViYWItY2FzZSBlcXVpdmFsZW50cyB3aGVuIHVzaW5nIGluLURPTSBcIiArXG4gICAgICAgICAgICBcInRlbXBsYXRlcy4gWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgYWx0S2V5ICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2hlY2tQcm9wKHJlcywgcHJvcHMsIGtleSwgYWx0S2V5LCB0cnVlKSB8fFxuICAgICAgY2hlY2tQcm9wKHJlcywgYXR0cnMsIGtleSwgYWx0S2V5LCBmYWxzZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wIChcbiAgcmVzLFxuICBoYXNoLFxuICBrZXksXG4gIGFsdEtleSxcbiAgcHJlc2VydmVcbikge1xuICBpZiAoaXNEZWYoaGFzaCkpIHtcbiAgICBpZiAoaGFzT3duKGhhc2gsIGtleSkpIHtcbiAgICAgIHJlc1trZXldID0gaGFzaFtrZXldO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICBkZWxldGUgaGFzaFtrZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2UgaWYgKGhhc093bihoYXNoLCBhbHRLZXkpKSB7XG4gICAgICByZXNba2V5XSA9IGhhc2hbYWx0S2V5XTtcbiAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgZGVsZXRlIGhhc2hbYWx0S2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vKiAgKi9cblxuLy8gVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGF0dGVtcHRzIHRvIG1pbmltaXplIHRoZSBuZWVkIGZvciBub3JtYWxpemF0aW9uIGJ5XG4vLyBzdGF0aWNhbGx5IGFuYWx5emluZyB0aGUgdGVtcGxhdGUgYXQgY29tcGlsZSB0aW1lLlxuLy9cbi8vIEZvciBwbGFpbiBIVE1MIG1hcmt1cCwgbm9ybWFsaXphdGlvbiBjYW4gYmUgY29tcGxldGVseSBza2lwcGVkIGJlY2F1c2UgdGhlXG4vLyBnZW5lcmF0ZWQgcmVuZGVyIGZ1bmN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gcmV0dXJuIEFycmF5PFZOb2RlPi4gVGhlcmUgYXJlXG4vLyB0d28gY2FzZXMgd2hlcmUgZXh0cmEgbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQ6XG5cbi8vIDEuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbXBvbmVudHMgLSBiZWNhdXNlIGEgZnVuY3Rpb25hbCBjb21wb25lbnRcbi8vIG1heSByZXR1cm4gYW4gQXJyYXkgaW5zdGVhZCBvZiBhIHNpbmdsZSByb290LiBJbiB0aGlzIGNhc2UsIGp1c3QgYSBzaW1wbGVcbi8vIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkIC0gaWYgYW55IGNoaWxkIGlzIGFuIEFycmF5LCB3ZSBmbGF0dGVuIHRoZSB3aG9sZVxuLy8gdGhpbmcgd2l0aCBBcnJheS5wcm90b3R5cGUuY29uY2F0LiBJdCBpcyBndWFyYW50ZWVkIHRvIGJlIG9ubHkgMS1sZXZlbCBkZWVwXG4vLyBiZWNhdXNlIGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhbHJlYWR5IG5vcm1hbGl6ZSB0aGVpciBvd24gY2hpbGRyZW4uXG5mdW5jdGlvbiBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuW2ldKSkge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGNoaWxkcmVuKVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2hpbGRyZW5cbn1cblxuLy8gMi4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29uc3RydWN0cyB0aGF0IGFsd2F5cyBnZW5lcmF0ZWQgbmVzdGVkIEFycmF5cyxcbi8vIGUuZy4gPHRlbXBsYXRlPiwgPHNsb3Q+LCB2LWZvciwgb3Igd2hlbiB0aGUgY2hpbGRyZW4gaXMgcHJvdmlkZWQgYnkgdXNlclxuLy8gd2l0aCBoYW5kLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucyAvIEpTWC4gSW4gc3VjaCBjYXNlcyBhIGZ1bGwgbm9ybWFsaXphdGlvblxuLy8gaXMgbmVlZGVkIHRvIGNhdGVyIHRvIGFsbCBwb3NzaWJsZSB0eXBlcyBvZiBjaGlsZHJlbiB2YWx1ZXMuXG5mdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIGlzUHJpbWl0aXZlKGNoaWxkcmVuKVxuICAgID8gW2NyZWF0ZVRleHRWTm9kZShjaGlsZHJlbildXG4gICAgOiBBcnJheS5pc0FycmF5KGNoaWxkcmVuKVxuICAgICAgPyBub3JtYWxpemVBcnJheUNoaWxkcmVuKGNoaWxkcmVuKVxuICAgICAgOiB1bmRlZmluZWRcbn1cblxuZnVuY3Rpb24gaXNUZXh0Tm9kZSAobm9kZSkge1xuICByZXR1cm4gaXNEZWYobm9kZSkgJiYgaXNEZWYobm9kZS50ZXh0KSAmJiBpc0ZhbHNlKG5vZGUuaXNDb21tZW50KVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheUNoaWxkcmVuIChjaGlsZHJlbiwgbmVzdGVkSW5kZXgpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICB2YXIgaSwgYywgbGFzdDtcbiAgZm9yIChpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgYyA9IGNoaWxkcmVuW2ldO1xuICAgIGlmIChpc1VuZGVmKGMpIHx8IHR5cGVvZiBjID09PSAnYm9vbGVhbicpIHsgY29udGludWUgfVxuICAgIGxhc3QgPSByZXNbcmVzLmxlbmd0aCAtIDFdO1xuICAgIC8vICBuZXN0ZWRcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjKSkge1xuICAgICAgcmVzLnB1c2guYXBwbHkocmVzLCBub3JtYWxpemVBcnJheUNoaWxkcmVuKGMsICgobmVzdGVkSW5kZXggfHwgJycpICsgXCJfXCIgKyBpKSkpO1xuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUoYykpIHtcbiAgICAgIGlmIChpc1RleHROb2RlKGxhc3QpKSB7XG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgLy8gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIFNTUiBoeWRyYXRpb24gYmVjYXVzZSB0ZXh0IG5vZGVzIGFyZVxuICAgICAgICAvLyBlc3NlbnRpYWxseSBtZXJnZWQgd2hlbiByZW5kZXJlZCB0byBIVE1MIHN0cmluZ3NcbiAgICAgICAgKGxhc3QpLnRleHQgKz0gU3RyaW5nKGMpO1xuICAgICAgfSBlbHNlIGlmIChjICE9PSAnJykge1xuICAgICAgICAvLyBjb252ZXJ0IHByaW1pdGl2ZSB0byB2bm9kZVxuICAgICAgICByZXMucHVzaChjcmVhdGVUZXh0Vk5vZGUoYykpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNUZXh0Tm9kZShjKSAmJiBpc1RleHROb2RlKGxhc3QpKSB7XG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgcmVzW3Jlcy5sZW5ndGggLSAxXSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyBjLnRleHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZGVmYXVsdCBrZXkgZm9yIG5lc3RlZCBhcnJheSBjaGlsZHJlbiAobGlrZWx5IGdlbmVyYXRlZCBieSB2LWZvcilcbiAgICAgICAgaWYgKGlzVHJ1ZShjaGlsZHJlbi5faXNWTGlzdCkgJiZcbiAgICAgICAgICBpc0RlZihjLnRhZykgJiZcbiAgICAgICAgICBpc1VuZGVmKGMua2V5KSAmJlxuICAgICAgICAgIGlzRGVmKG5lc3RlZEluZGV4KSkge1xuICAgICAgICAgIGMua2V5ID0gXCJfX3ZsaXN0XCIgKyBuZXN0ZWRJbmRleCArIFwiX1wiICsgaSArIFwiX19cIjtcbiAgICAgICAgfVxuICAgICAgICByZXMucHVzaChjKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZW5zdXJlQ3RvciAoY29tcCwgYmFzZSkge1xuICBpZiAoY29tcC5fX2VzTW9kdWxlICYmIGNvbXAuZGVmYXVsdCkge1xuICAgIGNvbXAgPSBjb21wLmRlZmF1bHQ7XG4gIH1cbiAgcmV0dXJuIGlzT2JqZWN0KGNvbXApXG4gICAgPyBiYXNlLmV4dGVuZChjb21wKVxuICAgIDogY29tcFxufVxuXG5mdW5jdGlvbiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyIChcbiAgZmFjdG9yeSxcbiAgZGF0YSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW4sXG4gIHRhZ1xuKSB7XG4gIHZhciBub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICBub2RlLmFzeW5jRmFjdG9yeSA9IGZhY3Rvcnk7XG4gIG5vZGUuYXN5bmNNZXRhID0geyBkYXRhOiBkYXRhLCBjb250ZXh0OiBjb250ZXh0LCBjaGlsZHJlbjogY2hpbGRyZW4sIHRhZzogdGFnIH07XG4gIHJldHVybiBub2RlXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVBc3luY0NvbXBvbmVudCAoXG4gIGZhY3RvcnksXG4gIGJhc2VDdG9yLFxuICBjb250ZXh0XG4pIHtcbiAgaWYgKGlzVHJ1ZShmYWN0b3J5LmVycm9yKSAmJiBpc0RlZihmYWN0b3J5LmVycm9yQ29tcCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5lcnJvckNvbXBcbiAgfVxuXG4gIGlmIChpc0RlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgIHJldHVybiBmYWN0b3J5LnJlc29sdmVkXG4gIH1cblxuICBpZiAoaXNUcnVlKGZhY3RvcnkubG9hZGluZykgJiYgaXNEZWYoZmFjdG9yeS5sb2FkaW5nQ29tcCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nQ29tcFxuICB9XG5cbiAgaWYgKGlzRGVmKGZhY3RvcnkuY29udGV4dHMpKSB7XG4gICAgLy8gYWxyZWFkeSBwZW5kaW5nXG4gICAgZmFjdG9yeS5jb250ZXh0cy5wdXNoKGNvbnRleHQpO1xuICB9IGVsc2Uge1xuICAgIHZhciBjb250ZXh0cyA9IGZhY3RvcnkuY29udGV4dHMgPSBbY29udGV4dF07XG4gICAgdmFyIHN5bmMgPSB0cnVlO1xuXG4gICAgdmFyIGZvcmNlUmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjb250ZXh0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY29udGV4dHNbaV0uJGZvcmNlVXBkYXRlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciByZXNvbHZlID0gb25jZShmdW5jdGlvbiAocmVzKSB7XG4gICAgICAvLyBjYWNoZSByZXNvbHZlZFxuICAgICAgZmFjdG9yeS5yZXNvbHZlZCA9IGVuc3VyZUN0b3IocmVzLCBiYXNlQ3Rvcik7XG4gICAgICAvLyBpbnZva2UgY2FsbGJhY2tzIG9ubHkgaWYgdGhpcyBpcyBub3QgYSBzeW5jaHJvbm91cyByZXNvbHZlXG4gICAgICAvLyAoYXN5bmMgcmVzb2x2ZXMgYXJlIHNoaW1tZWQgYXMgc3luY2hyb25vdXMgZHVyaW5nIFNTUilcbiAgICAgIGlmICghc3luYykge1xuICAgICAgICBmb3JjZVJlbmRlcigpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHJlamVjdCA9IG9uY2UoZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJGYWlsZWQgdG8gcmVzb2x2ZSBhc3luYyBjb21wb25lbnQ6IFwiICsgKFN0cmluZyhmYWN0b3J5KSkgK1xuICAgICAgICAocmVhc29uID8gKFwiXFxuUmVhc29uOiBcIiArIHJlYXNvbikgOiAnJylcbiAgICAgICk7XG4gICAgICBpZiAoaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgICAgIGZhY3RvcnkuZXJyb3IgPSB0cnVlO1xuICAgICAgICBmb3JjZVJlbmRlcigpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHJlcyA9IGZhY3RvcnkocmVzb2x2ZSwgcmVqZWN0KTtcblxuICAgIGlmIChpc09iamVjdChyZXMpKSB7XG4gICAgICBpZiAodHlwZW9mIHJlcy50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vICgpID0+IFByb21pc2VcbiAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICByZXMudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKHJlcy5jb21wb25lbnQpICYmIHR5cGVvZiByZXMuY29tcG9uZW50LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmVzLmNvbXBvbmVudC50aGVuKHJlc29sdmUsIHJlamVjdCk7XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy5lcnJvcikpIHtcbiAgICAgICAgICBmYWN0b3J5LmVycm9yQ29tcCA9IGVuc3VyZUN0b3IocmVzLmVycm9yLCBiYXNlQ3Rvcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWYocmVzLmxvYWRpbmcpKSB7XG4gICAgICAgICAgZmFjdG9yeS5sb2FkaW5nQ29tcCA9IGVuc3VyZUN0b3IocmVzLmxvYWRpbmcsIGJhc2VDdG9yKTtcbiAgICAgICAgICBpZiAocmVzLmRlbGF5ID09PSAwKSB7XG4gICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkgJiYgaXNVbmRlZihmYWN0b3J5LmVycm9yKSkge1xuICAgICAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm9yY2VSZW5kZXIoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgcmVzLmRlbGF5IHx8IDIwMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy50aW1lb3V0KSkge1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICAgIFwidGltZW91dCAoXCIgKyAocmVzLnRpbWVvdXQpICsgXCJtcylcIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHJlcy50aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHN5bmMgPSBmYWxzZTtcbiAgICAvLyByZXR1cm4gaW4gY2FzZSByZXNvbHZlZCBzeW5jaHJvbm91c2x5XG4gICAgcmV0dXJuIGZhY3RvcnkubG9hZGluZ1xuICAgICAgPyBmYWN0b3J5LmxvYWRpbmdDb21wXG4gICAgICA6IGZhY3RvcnkucmVzb2x2ZWRcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCAoY2hpbGRyZW4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSBjaGlsZHJlbltpXTtcbiAgICAgIGlmIChpc0RlZihjKSAmJiBpc0RlZihjLmNvbXBvbmVudE9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiBjXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV2ZW50cyAodm0pIHtcbiAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZtLl9oYXNIb29rRXZlbnQgPSBmYWxzZTtcbiAgLy8gaW5pdCBwYXJlbnQgYXR0YWNoZWQgZXZlbnRzXG4gIHZhciBsaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBpZiAobGlzdGVuZXJzKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMpO1xuICB9XG59XG5cbnZhciB0YXJnZXQ7XG5cbmZ1bmN0aW9uIGFkZCAoZXZlbnQsIGZuLCBvbmNlJCQxKSB7XG4gIGlmIChvbmNlJCQxKSB7XG4gICAgdGFyZ2V0LiRvbmNlKGV2ZW50LCBmbik7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0LiRvbihldmVudCwgZm4pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSQxIChldmVudCwgZm4pIHtcbiAgdGFyZ2V0LiRvZmYoZXZlbnQsIGZuKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzIChcbiAgdm0sXG4gIGxpc3RlbmVycyxcbiAgb2xkTGlzdGVuZXJzXG4pIHtcbiAgdGFyZ2V0ID0gdm07XG4gIHVwZGF0ZUxpc3RlbmVycyhsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyB8fCB7fSwgYWRkLCByZW1vdmUkMSwgdm0pO1xufVxuXG5mdW5jdGlvbiBldmVudHNNaXhpbiAoVnVlKSB7XG4gIHZhciBob29rUkUgPSAvXmhvb2s6LztcbiAgVnVlLnByb3RvdHlwZS4kb24gPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcyQxLiRvbihldmVudFtpXSwgZm4pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAodm0uX2V2ZW50c1tldmVudF0gfHwgKHZtLl9ldmVudHNbZXZlbnRdID0gW10pKS5wdXNoKGZuKTtcbiAgICAgIC8vIG9wdGltaXplIGhvb2s6ZXZlbnQgY29zdCBieSB1c2luZyBhIGJvb2xlYW4gZmxhZyBtYXJrZWQgYXQgcmVnaXN0cmF0aW9uXG4gICAgICAvLyBpbnN0ZWFkIG9mIGEgaGFzaCBsb29rdXBcbiAgICAgIGlmIChob29rUkUudGVzdChldmVudCkpIHtcbiAgICAgICAgdm0uX2hhc0hvb2tFdmVudCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG9uY2UgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBmdW5jdGlvbiBvbiAoKSB7XG4gICAgICB2bS4kb2ZmKGV2ZW50LCBvbik7XG4gICAgICBmbi5hcHBseSh2bSwgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgb24uZm4gPSBmbjtcbiAgICB2bS4kb24oZXZlbnQsIG9uKTtcbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvZmYgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIGFsbFxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gYXJyYXkgb2YgZXZlbnRzXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICBmb3IgKHZhciBpJDEgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpJDEgPCBsOyBpJDErKykge1xuICAgICAgICB0aGlzJDEuJG9mZihldmVudFtpJDFdLCBmbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgICB2YXIgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XG4gICAgaWYgKCFjYnMpIHtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdm0uX2V2ZW50c1tldmVudF0gPSBudWxsO1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIHNwZWNpZmljIGhhbmRsZXJcbiAgICB2YXIgY2I7XG4gICAgdmFyIGkgPSBjYnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGNiID0gY2JzW2ldO1xuICAgICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgICAgY2JzLnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAge1xuICAgICAgdmFyIGxvd2VyQ2FzZUV2ZW50ID0gZXZlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChsb3dlckNhc2VFdmVudCAhPT0gZXZlbnQgJiYgdm0uX2V2ZW50c1tsb3dlckNhc2VFdmVudF0pIHtcbiAgICAgICAgdGlwKFxuICAgICAgICAgIFwiRXZlbnQgXFxcIlwiICsgbG93ZXJDYXNlRXZlbnQgKyBcIlxcXCIgaXMgZW1pdHRlZCBpbiBjb21wb25lbnQgXCIgK1xuICAgICAgICAgIChmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgKyBcIiBidXQgdGhlIGhhbmRsZXIgaXMgcmVnaXN0ZXJlZCBmb3IgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuIFwiICtcbiAgICAgICAgICBcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIHlvdSBjYW5ub3QgdXNlIFwiICtcbiAgICAgICAgICBcInYtb24gdG8gbGlzdGVuIHRvIGNhbWVsQ2FzZSBldmVudHMgd2hlbiB1c2luZyBpbi1ET00gdGVtcGxhdGVzLiBcIiArXG4gICAgICAgICAgXCJZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcXFwiXCIgKyAoaHlwaGVuYXRlKGV2ZW50KSkgKyBcIlxcXCIgaW5zdGVhZCBvZiBcXFwiXCIgKyBldmVudCArIFwiXFxcIi5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XG4gICAgaWYgKGNicykge1xuICAgICAgY2JzID0gY2JzLmxlbmd0aCA+IDEgPyB0b0FycmF5KGNicykgOiBjYnM7XG4gICAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNic1tpXS5hcHBseSh2bSwgYXJncyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKFwiZXZlbnQgaGFuZGxlciBmb3IgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCJcIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIHJhdyBjaGlsZHJlbiBWTm9kZXMgaW50byBhIHNsb3Qgb2JqZWN0LlxuICovXG5mdW5jdGlvbiByZXNvbHZlU2xvdHMgKFxuICBjaGlsZHJlbixcbiAgY29udGV4dFxuKSB7XG4gIHZhciBzbG90cyA9IHt9O1xuICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgcmV0dXJuIHNsb3RzXG4gIH1cbiAgdmFyIGRlZmF1bHRTbG90ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgLy8gbmFtZWQgc2xvdHMgc2hvdWxkIG9ubHkgYmUgcmVzcGVjdGVkIGlmIHRoZSB2bm9kZSB3YXMgcmVuZGVyZWQgaW4gdGhlXG4gICAgLy8gc2FtZSBjb250ZXh0LlxuICAgIGlmICgoY2hpbGQuY29udGV4dCA9PT0gY29udGV4dCB8fCBjaGlsZC5mdW5jdGlvbmFsQ29udGV4dCA9PT0gY29udGV4dCkgJiZcbiAgICAgIGNoaWxkLmRhdGEgJiYgY2hpbGQuZGF0YS5zbG90ICE9IG51bGxcbiAgICApIHtcbiAgICAgIHZhciBuYW1lID0gY2hpbGQuZGF0YS5zbG90O1xuICAgICAgdmFyIHNsb3QgPSAoc2xvdHNbbmFtZV0gfHwgKHNsb3RzW25hbWVdID0gW10pKTtcbiAgICAgIGlmIChjaGlsZC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgc2xvdC5wdXNoLmFwcGx5KHNsb3QsIGNoaWxkLmNoaWxkcmVuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNsb3QucHVzaChjaGlsZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZmF1bHRTbG90LnB1c2goY2hpbGQpO1xuICAgIH1cbiAgfVxuICAvLyBpZ25vcmUgd2hpdGVzcGFjZVxuICBpZiAoIWRlZmF1bHRTbG90LmV2ZXJ5KGlzV2hpdGVzcGFjZSkpIHtcbiAgICBzbG90cy5kZWZhdWx0ID0gZGVmYXVsdFNsb3Q7XG4gIH1cbiAgcmV0dXJuIHNsb3RzXG59XG5cbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS5pc0NvbW1lbnQgfHwgbm9kZS50ZXh0ID09PSAnICdcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVNjb3BlZFNsb3RzIChcbiAgZm5zLCAvLyBzZWUgZmxvdy92bm9kZVxuICByZXNcbikge1xuICByZXMgPSByZXMgfHwge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZm5zW2ldKSkge1xuICAgICAgcmVzb2x2ZVNjb3BlZFNsb3RzKGZuc1tpXSwgcmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzW2Zuc1tpXS5rZXldID0gZm5zW2ldLmZuO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgYWN0aXZlSW5zdGFuY2UgPSBudWxsO1xudmFyIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBpbml0TGlmZWN5Y2xlICh2bSkge1xuICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuXG4gIC8vIGxvY2F0ZSBmaXJzdCBub24tYWJzdHJhY3QgcGFyZW50XG4gIHZhciBwYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgaWYgKHBhcmVudCAmJiAhb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIHdoaWxlIChwYXJlbnQuJG9wdGlvbnMuYWJzdHJhY3QgJiYgcGFyZW50LiRwYXJlbnQpIHtcbiAgICAgIHBhcmVudCA9IHBhcmVudC4kcGFyZW50O1xuICAgIH1cbiAgICBwYXJlbnQuJGNoaWxkcmVuLnB1c2godm0pO1xuICB9XG5cbiAgdm0uJHBhcmVudCA9IHBhcmVudDtcbiAgdm0uJHJvb3QgPSBwYXJlbnQgPyBwYXJlbnQuJHJvb3QgOiB2bTtcblxuICB2bS4kY2hpbGRyZW4gPSBbXTtcbiAgdm0uJHJlZnMgPSB7fTtcblxuICB2bS5fd2F0Y2hlciA9IG51bGw7XG4gIHZtLl9pbmFjdGl2ZSA9IG51bGw7XG4gIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICB2bS5faXNNb3VudGVkID0gZmFsc2U7XG4gIHZtLl9pc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBsaWZlY3ljbGVNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICh2bm9kZSwgaHlkcmF0aW5nKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX2lzTW91bnRlZCkge1xuICAgICAgY2FsbEhvb2sodm0sICdiZWZvcmVVcGRhdGUnKTtcbiAgICB9XG4gICAgdmFyIHByZXZFbCA9IHZtLiRlbDtcbiAgICB2YXIgcHJldlZub2RlID0gdm0uX3Zub2RlO1xuICAgIHZhciBwcmV2QWN0aXZlSW5zdGFuY2UgPSBhY3RpdmVJbnN0YW5jZTtcbiAgICBhY3RpdmVJbnN0YW5jZSA9IHZtO1xuICAgIHZtLl92bm9kZSA9IHZub2RlO1xuICAgIC8vIFZ1ZS5wcm90b3R5cGUuX19wYXRjaF9fIGlzIGluamVjdGVkIGluIGVudHJ5IHBvaW50c1xuICAgIC8vIGJhc2VkIG9uIHRoZSByZW5kZXJpbmcgYmFja2VuZCB1c2VkLlxuICAgIGlmICghcHJldlZub2RlKSB7XG4gICAgICAvLyBpbml0aWFsIHJlbmRlclxuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKFxuICAgICAgICB2bS4kZWwsIHZub2RlLCBoeWRyYXRpbmcsIGZhbHNlIC8qIHJlbW92ZU9ubHkgKi8sXG4gICAgICAgIHZtLiRvcHRpb25zLl9wYXJlbnRFbG0sXG4gICAgICAgIHZtLiRvcHRpb25zLl9yZWZFbG1cbiAgICAgICk7XG4gICAgICAvLyBubyBuZWVkIGZvciB0aGUgcmVmIG5vZGVzIGFmdGVyIGluaXRpYWwgcGF0Y2hcbiAgICAgIC8vIHRoaXMgcHJldmVudHMga2VlcGluZyBhIGRldGFjaGVkIERPTSB0cmVlIGluIG1lbW9yeSAoIzU4NTEpXG4gICAgICB2bS4kb3B0aW9ucy5fcGFyZW50RWxtID0gdm0uJG9wdGlvbnMuX3JlZkVsbSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVwZGF0ZXNcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhwcmV2Vm5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgYWN0aXZlSW5zdGFuY2UgPSBwcmV2QWN0aXZlSW5zdGFuY2U7XG4gICAgLy8gdXBkYXRlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHByZXZFbCkge1xuICAgICAgcHJldkVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICBpZiAodm0uJGVsKSB7XG4gICAgICB2bS4kZWwuX192dWVfXyA9IHZtO1xuICAgIH1cbiAgICAvLyBpZiBwYXJlbnQgaXMgYW4gSE9DLCB1cGRhdGUgaXRzICRlbCBhcyB3ZWxsXG4gICAgaWYgKHZtLiR2bm9kZSAmJiB2bS4kcGFyZW50ICYmIHZtLiR2bm9kZSA9PT0gdm0uJHBhcmVudC5fdm5vZGUpIHtcbiAgICAgIHZtLiRwYXJlbnQuJGVsID0gdm0uJGVsO1xuICAgIH1cbiAgICAvLyB1cGRhdGVkIGhvb2sgaXMgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIgdG8gZW5zdXJlIHRoYXQgY2hpbGRyZW4gYXJlXG4gICAgLy8gdXBkYXRlZCBpbiBhIHBhcmVudCdzIHVwZGF0ZWQgaG9vay5cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRmb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudXBkYXRlKCk7XG4gICAgfVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZURlc3Ryb3knKTtcbiAgICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSBwYXJlbnRcbiAgICB2YXIgcGFyZW50ID0gdm0uJHBhcmVudDtcbiAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuX2lzQmVpbmdEZXN0cm95ZWQgJiYgIXZtLiRvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgICByZW1vdmUocGFyZW50LiRjaGlsZHJlbiwgdm0pO1xuICAgIH1cbiAgICAvLyB0ZWFyZG93biB3YXRjaGVyc1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gICAgdmFyIGkgPSB2bS5fd2F0Y2hlcnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZtLl93YXRjaGVyc1tpXS50ZWFyZG93bigpO1xuICAgIH1cbiAgICAvLyByZW1vdmUgcmVmZXJlbmNlIGZyb20gZGF0YSBvYlxuICAgIC8vIGZyb3plbiBvYmplY3QgbWF5IG5vdCBoYXZlIG9ic2VydmVyLlxuICAgIGlmICh2bS5fZGF0YS5fX29iX18pIHtcbiAgICAgIHZtLl9kYXRhLl9fb2JfXy52bUNvdW50LS07XG4gICAgfVxuICAgIC8vIGNhbGwgdGhlIGxhc3QgaG9vay4uLlxuICAgIHZtLl9pc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gaW52b2tlIGRlc3Ryb3kgaG9va3Mgb24gY3VycmVudCByZW5kZXJlZCB0cmVlXG4gICAgdm0uX19wYXRjaF9fKHZtLl92bm9kZSwgbnVsbCk7XG4gICAgLy8gZmlyZSBkZXN0cm95ZWQgaG9va1xuICAgIGNhbGxIb29rKHZtLCAnZGVzdHJveWVkJyk7XG4gICAgLy8gdHVybiBvZmYgYWxsIGluc3RhbmNlIGxpc3RlbmVycy5cbiAgICB2bS4kb2ZmKCk7XG4gICAgLy8gcmVtb3ZlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHZtLiRlbCkge1xuICAgICAgdm0uJGVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gbW91bnRDb21wb25lbnQgKFxuICB2bSxcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIHZtLiRlbCA9IGVsO1xuICBpZiAoIXZtLiRvcHRpb25zLnJlbmRlcikge1xuICAgIHZtLiRvcHRpb25zLnJlbmRlciA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gICAge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoKHZtLiRvcHRpb25zLnRlbXBsYXRlICYmIHZtLiRvcHRpb25zLnRlbXBsYXRlLmNoYXJBdCgwKSAhPT0gJyMnKSB8fFxuICAgICAgICB2bS4kb3B0aW9ucy5lbCB8fCBlbCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdZb3UgYXJlIHVzaW5nIHRoZSBydW50aW1lLW9ubHkgYnVpbGQgb2YgVnVlIHdoZXJlIHRoZSB0ZW1wbGF0ZSAnICtcbiAgICAgICAgICAnY29tcGlsZXIgaXMgbm90IGF2YWlsYWJsZS4gRWl0aGVyIHByZS1jb21waWxlIHRoZSB0ZW1wbGF0ZXMgaW50byAnICtcbiAgICAgICAgICAncmVuZGVyIGZ1bmN0aW9ucywgb3IgdXNlIHRoZSBjb21waWxlci1pbmNsdWRlZCBidWlsZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdGYWlsZWQgdG8gbW91bnQgY29tcG9uZW50OiB0ZW1wbGF0ZSBvciByZW5kZXIgZnVuY3Rpb24gbm90IGRlZmluZWQuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjYWxsSG9vayh2bSwgJ2JlZm9yZU1vdW50Jyk7XG5cbiAgdmFyIHVwZGF0ZUNvbXBvbmVudDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBuYW1lID0gdm0uX25hbWU7XG4gICAgICB2YXIgaWQgPSB2bS5fdWlkO1xuICAgICAgdmFyIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIiArIGlkO1xuICAgICAgdmFyIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgaWQ7XG5cbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgdmFyIHZub2RlID0gdm0uX3JlbmRlcigpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgobmFtZSArIFwiIHJlbmRlclwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG5cbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgdm0uX3VwZGF0ZSh2bm9kZSwgaHlkcmF0aW5nKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKG5hbWUgKyBcIiBwYXRjaFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB1cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2bS5fdXBkYXRlKHZtLl9yZW5kZXIoKSwgaHlkcmF0aW5nKTtcbiAgICB9O1xuICB9XG5cbiAgdm0uX3dhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgdXBkYXRlQ29tcG9uZW50LCBub29wKTtcbiAgaHlkcmF0aW5nID0gZmFsc2U7XG5cbiAgLy8gbWFudWFsbHkgbW91bnRlZCBpbnN0YW5jZSwgY2FsbCBtb3VudGVkIG9uIHNlbGZcbiAgLy8gbW91bnRlZCBpcyBjYWxsZWQgZm9yIHJlbmRlci1jcmVhdGVkIGNoaWxkIGNvbXBvbmVudHMgaW4gaXRzIGluc2VydGVkIGhvb2tcbiAgaWYgKHZtLiR2bm9kZSA9PSBudWxsKSB7XG4gICAgdm0uX2lzTW91bnRlZCA9IHRydWU7XG4gICAgY2FsbEhvb2sodm0sICdtb3VudGVkJyk7XG4gIH1cbiAgcmV0dXJuIHZtXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNoaWxkQ29tcG9uZW50IChcbiAgdm0sXG4gIHByb3BzRGF0YSxcbiAgbGlzdGVuZXJzLFxuICBwYXJlbnRWbm9kZSxcbiAgcmVuZGVyQ2hpbGRyZW5cbikge1xuICB7XG4gICAgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGRldGVybWluZSB3aGV0aGVyIGNvbXBvbmVudCBoYXMgc2xvdCBjaGlsZHJlblxuICAvLyB3ZSBuZWVkIHRvIGRvIHRoaXMgYmVmb3JlIG92ZXJ3cml0aW5nICRvcHRpb25zLl9yZW5kZXJDaGlsZHJlblxuICB2YXIgaGFzQ2hpbGRyZW4gPSAhIShcbiAgICByZW5kZXJDaGlsZHJlbiB8fCAgICAgICAgICAgICAgIC8vIGhhcyBuZXcgc3RhdGljIHNsb3RzXG4gICAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuIHx8ICAvLyBoYXMgb2xkIHN0YXRpYyBzbG90c1xuICAgIHBhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHMgfHwgLy8gaGFzIG5ldyBzY29wZWQgc2xvdHNcbiAgICB2bS4kc2NvcGVkU2xvdHMgIT09IGVtcHR5T2JqZWN0IC8vIGhhcyBvbGQgc2NvcGVkIHNsb3RzXG4gICk7XG5cbiAgdm0uJG9wdGlvbnMuX3BhcmVudFZub2RlID0gcGFyZW50Vm5vZGU7XG4gIHZtLiR2bm9kZSA9IHBhcmVudFZub2RlOyAvLyB1cGRhdGUgdm0ncyBwbGFjZWhvbGRlciBub2RlIHdpdGhvdXQgcmUtcmVuZGVyXG5cbiAgaWYgKHZtLl92bm9kZSkgeyAvLyB1cGRhdGUgY2hpbGQgdHJlZSdzIHBhcmVudFxuICAgIHZtLl92bm9kZS5wYXJlbnQgPSBwYXJlbnRWbm9kZTtcbiAgfVxuICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gPSByZW5kZXJDaGlsZHJlbjtcblxuICAvLyB1cGRhdGUgJGF0dHJzIGFuZCAkbGlzdGVuc2VycyBoYXNoXG4gIC8vIHRoZXNlIGFyZSBhbHNvIHJlYWN0aXZlIHNvIHRoZXkgbWF5IHRyaWdnZXIgY2hpbGQgdXBkYXRlIGlmIHRoZSBjaGlsZFxuICAvLyB1c2VkIHRoZW0gZHVyaW5nIHJlbmRlclxuICB2bS4kYXR0cnMgPSBwYXJlbnRWbm9kZS5kYXRhICYmIHBhcmVudFZub2RlLmRhdGEuYXR0cnM7XG4gIHZtLiRsaXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG5cbiAgLy8gdXBkYXRlIHByb3BzXG4gIGlmIChwcm9wc0RhdGEgJiYgdm0uJG9wdGlvbnMucHJvcHMpIHtcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSBmYWxzZTtcbiAgICB2YXIgcHJvcHMgPSB2bS5fcHJvcHM7XG4gICAgdmFyIHByb3BLZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzIHx8IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wS2V5c1tpXTtcbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCB2bS4kb3B0aW9ucy5wcm9wcywgcHJvcHNEYXRhLCB2bSk7XG4gICAgfVxuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHRydWU7XG4gICAgLy8ga2VlcCBhIGNvcHkgb2YgcmF3IHByb3BzRGF0YVxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YSA9IHByb3BzRGF0YTtcbiAgfVxuXG4gIC8vIHVwZGF0ZSBsaXN0ZW5lcnNcbiAgaWYgKGxpc3RlbmVycykge1xuICAgIHZhciBvbGRMaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICAgIHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyk7XG4gIH1cbiAgLy8gcmVzb2x2ZSBzbG90cyArIGZvcmNlIHVwZGF0ZSBpZiBoYXMgY2hpbGRyZW5cbiAgaWYgKGhhc0NoaWxkcmVuKSB7XG4gICAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKHJlbmRlckNoaWxkcmVuLCBwYXJlbnRWbm9kZS5jb250ZXh0KTtcbiAgICB2bS4kZm9yY2VVcGRhdGUoKTtcbiAgfVxuXG4gIHtcbiAgICBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0luSW5hY3RpdmVUcmVlICh2bSkge1xuICB3aGlsZSAodm0gJiYgKHZtID0gdm0uJHBhcmVudCkpIHtcbiAgICBpZiAodm0uX2luYWN0aXZlKSB7IHJldHVybiB0cnVlIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gYWN0aXZhdGVDaGlsZENvbXBvbmVudCAodm0sIGRpcmVjdCkge1xuICBpZiAoZGlyZWN0KSB7XG4gICAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XG4gICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH0gZWxzZSBpZiAodm0uX2RpcmVjdEluYWN0aXZlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZtLl9pbmFjdGl2ZSB8fCB2bS5faW5hY3RpdmUgPT09IG51bGwpIHtcbiAgICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2FjdGl2YXRlZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCAodm0sIGRpcmVjdCkge1xuICBpZiAoZGlyZWN0KSB7XG4gICAgdm0uX2RpcmVjdEluYWN0aXZlID0gdHJ1ZTtcbiAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuICBpZiAoIXZtLl9pbmFjdGl2ZSkge1xuICAgIHZtLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2RlYWN0aXZhdGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbEhvb2sgKHZtLCBob29rKSB7XG4gIHZhciBoYW5kbGVycyA9IHZtLiRvcHRpb25zW2hvb2tdO1xuICBpZiAoaGFuZGxlcnMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaGFuZGxlcnNbaV0uY2FsbCh2bSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCAoaG9vayArIFwiIGhvb2tcIikpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAodm0uX2hhc0hvb2tFdmVudCkge1xuICAgIHZtLiRlbWl0KCdob29rOicgKyBob29rKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuXG52YXIgTUFYX1VQREFURV9DT1VOVCA9IDEwMDtcblxudmFyIHF1ZXVlID0gW107XG52YXIgYWN0aXZhdGVkQ2hpbGRyZW4gPSBbXTtcbnZhciBoYXMgPSB7fTtcbnZhciBjaXJjdWxhciA9IHt9O1xudmFyIHdhaXRpbmcgPSBmYWxzZTtcbnZhciBmbHVzaGluZyA9IGZhbHNlO1xudmFyIGluZGV4ID0gMDtcblxuLyoqXG4gKiBSZXNldCB0aGUgc2NoZWR1bGVyJ3Mgc3RhdGUuXG4gKi9cbmZ1bmN0aW9uIHJlc2V0U2NoZWR1bGVyU3RhdGUgKCkge1xuICBpbmRleCA9IHF1ZXVlLmxlbmd0aCA9IGFjdGl2YXRlZENoaWxkcmVuLmxlbmd0aCA9IDA7XG4gIGhhcyA9IHt9O1xuICB7XG4gICAgY2lyY3VsYXIgPSB7fTtcbiAgfVxuICB3YWl0aW5nID0gZmx1c2hpbmcgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBGbHVzaCBib3RoIHF1ZXVlcyBhbmQgcnVuIHRoZSB3YXRjaGVycy5cbiAqL1xuZnVuY3Rpb24gZmx1c2hTY2hlZHVsZXJRdWV1ZSAoKSB7XG4gIGZsdXNoaW5nID0gdHJ1ZTtcbiAgdmFyIHdhdGNoZXIsIGlkO1xuXG4gIC8vIFNvcnQgcXVldWUgYmVmb3JlIGZsdXNoLlxuICAvLyBUaGlzIGVuc3VyZXMgdGhhdDpcbiAgLy8gMS4gQ29tcG9uZW50cyBhcmUgdXBkYXRlZCBmcm9tIHBhcmVudCB0byBjaGlsZC4gKGJlY2F1c2UgcGFyZW50IGlzIGFsd2F5c1xuICAvLyAgICBjcmVhdGVkIGJlZm9yZSB0aGUgY2hpbGQpXG4gIC8vIDIuIEEgY29tcG9uZW50J3MgdXNlciB3YXRjaGVycyBhcmUgcnVuIGJlZm9yZSBpdHMgcmVuZGVyIHdhdGNoZXIgKGJlY2F1c2VcbiAgLy8gICAgdXNlciB3YXRjaGVycyBhcmUgY3JlYXRlZCBiZWZvcmUgdGhlIHJlbmRlciB3YXRjaGVyKVxuICAvLyAzLiBJZiBhIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgZHVyaW5nIGEgcGFyZW50IGNvbXBvbmVudCdzIHdhdGNoZXIgcnVuLFxuICAvLyAgICBpdHMgd2F0Y2hlcnMgY2FuIGJlIHNraXBwZWQuXG4gIHF1ZXVlLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuaWQgLSBiLmlkOyB9KTtcblxuICAvLyBkbyBub3QgY2FjaGUgbGVuZ3RoIGJlY2F1c2UgbW9yZSB3YXRjaGVycyBtaWdodCBiZSBwdXNoZWRcbiAgLy8gYXMgd2UgcnVuIGV4aXN0aW5nIHdhdGNoZXJzXG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHF1ZXVlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIHdhdGNoZXIgPSBxdWV1ZVtpbmRleF07XG4gICAgaWQgPSB3YXRjaGVyLmlkO1xuICAgIGhhc1tpZF0gPSBudWxsO1xuICAgIHdhdGNoZXIucnVuKCk7XG4gICAgLy8gaW4gZGV2IGJ1aWxkLCBjaGVjayBhbmQgc3RvcCBjaXJjdWxhciB1cGRhdGVzLlxuICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBoYXNbaWRdICE9IG51bGwpIHtcbiAgICAgIGNpcmN1bGFyW2lkXSA9IChjaXJjdWxhcltpZF0gfHwgMCkgKyAxO1xuICAgICAgaWYgKGNpcmN1bGFyW2lkXSA+IE1BWF9VUERBVEVfQ09VTlQpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnWW91IG1heSBoYXZlIGFuIGluZmluaXRlIHVwZGF0ZSBsb29wICcgKyAoXG4gICAgICAgICAgICB3YXRjaGVyLnVzZXJcbiAgICAgICAgICAgICAgPyAoXCJpbiB3YXRjaGVyIHdpdGggZXhwcmVzc2lvbiBcXFwiXCIgKyAod2F0Y2hlci5leHByZXNzaW9uKSArIFwiXFxcIlwiKVxuICAgICAgICAgICAgICA6IFwiaW4gYSBjb21wb25lbnQgcmVuZGVyIGZ1bmN0aW9uLlwiXG4gICAgICAgICAgKSxcbiAgICAgICAgICB3YXRjaGVyLnZtXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8ga2VlcCBjb3BpZXMgb2YgcG9zdCBxdWV1ZXMgYmVmb3JlIHJlc2V0dGluZyBzdGF0ZVxuICB2YXIgYWN0aXZhdGVkUXVldWUgPSBhY3RpdmF0ZWRDaGlsZHJlbi5zbGljZSgpO1xuICB2YXIgdXBkYXRlZFF1ZXVlID0gcXVldWUuc2xpY2UoKTtcblxuICByZXNldFNjaGVkdWxlclN0YXRlKCk7XG5cbiAgLy8gY2FsbCBjb21wb25lbnQgdXBkYXRlZCBhbmQgYWN0aXZhdGVkIGhvb2tzXG4gIGNhbGxBY3RpdmF0ZWRIb29rcyhhY3RpdmF0ZWRRdWV1ZSk7XG4gIGNhbGxVcGRhdGVkSG9va3ModXBkYXRlZFF1ZXVlKTtcblxuICAvLyBkZXZ0b29sIGhvb2tcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChkZXZ0b29scyAmJiBjb25maWcuZGV2dG9vbHMpIHtcbiAgICBkZXZ0b29scy5lbWl0KCdmbHVzaCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxVcGRhdGVkSG9va3MgKHF1ZXVlKSB7XG4gIHZhciBpID0gcXVldWUubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIHdhdGNoZXIgPSBxdWV1ZVtpXTtcbiAgICB2YXIgdm0gPSB3YXRjaGVyLnZtO1xuICAgIGlmICh2bS5fd2F0Y2hlciA9PT0gd2F0Y2hlciAmJiB2bS5faXNNb3VudGVkKSB7XG4gICAgICBjYWxsSG9vayh2bSwgJ3VwZGF0ZWQnKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBRdWV1ZSBhIGtlcHQtYWxpdmUgY29tcG9uZW50IHRoYXQgd2FzIGFjdGl2YXRlZCBkdXJpbmcgcGF0Y2guXG4gKiBUaGUgcXVldWUgd2lsbCBiZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIGVudGlyZSB0cmVlIGhhcyBiZWVuIHBhdGNoZWQuXG4gKi9cbmZ1bmN0aW9uIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50ICh2bSkge1xuICAvLyBzZXR0aW5nIF9pbmFjdGl2ZSB0byBmYWxzZSBoZXJlIHNvIHRoYXQgYSByZW5kZXIgZnVuY3Rpb24gY2FuXG4gIC8vIHJlbHkgb24gY2hlY2tpbmcgd2hldGhlciBpdCdzIGluIGFuIGluYWN0aXZlIHRyZWUgKGUuZy4gcm91dGVyLXZpZXcpXG4gIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICBhY3RpdmF0ZWRDaGlsZHJlbi5wdXNoKHZtKTtcbn1cblxuZnVuY3Rpb24gY2FsbEFjdGl2YXRlZEhvb2tzIChxdWV1ZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgcXVldWVbaV0uX2luYWN0aXZlID0gdHJ1ZTtcbiAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHF1ZXVlW2ldLCB0cnVlIC8qIHRydWUgKi8pO1xuICB9XG59XG5cbi8qKlxuICogUHVzaCBhIHdhdGNoZXIgaW50byB0aGUgd2F0Y2hlciBxdWV1ZS5cbiAqIEpvYnMgd2l0aCBkdXBsaWNhdGUgSURzIHdpbGwgYmUgc2tpcHBlZCB1bmxlc3MgaXQnc1xuICogcHVzaGVkIHdoZW4gdGhlIHF1ZXVlIGlzIGJlaW5nIGZsdXNoZWQuXG4gKi9cbmZ1bmN0aW9uIHF1ZXVlV2F0Y2hlciAod2F0Y2hlcikge1xuICB2YXIgaWQgPSB3YXRjaGVyLmlkO1xuICBpZiAoaGFzW2lkXSA9PSBudWxsKSB7XG4gICAgaGFzW2lkXSA9IHRydWU7XG4gICAgaWYgKCFmbHVzaGluZykge1xuICAgICAgcXVldWUucHVzaCh3YXRjaGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgYWxyZWFkeSBmbHVzaGluZywgc3BsaWNlIHRoZSB3YXRjaGVyIGJhc2VkIG9uIGl0cyBpZFxuICAgICAgLy8gaWYgYWxyZWFkeSBwYXN0IGl0cyBpZCwgaXQgd2lsbCBiZSBydW4gbmV4dCBpbW1lZGlhdGVseS5cbiAgICAgIHZhciBpID0gcXVldWUubGVuZ3RoIC0gMTtcbiAgICAgIHdoaWxlIChpID4gaW5kZXggJiYgcXVldWVbaV0uaWQgPiB3YXRjaGVyLmlkKSB7XG4gICAgICAgIGktLTtcbiAgICAgIH1cbiAgICAgIHF1ZXVlLnNwbGljZShpICsgMSwgMCwgd2F0Y2hlcik7XG4gICAgfVxuICAgIC8vIHF1ZXVlIHRoZSBmbHVzaFxuICAgIGlmICghd2FpdGluZykge1xuICAgICAgd2FpdGluZyA9IHRydWU7XG4gICAgICBuZXh0VGljayhmbHVzaFNjaGVkdWxlclF1ZXVlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciB1aWQkMiA9IDA7XG5cbi8qKlxuICogQSB3YXRjaGVyIHBhcnNlcyBhbiBleHByZXNzaW9uLCBjb2xsZWN0cyBkZXBlbmRlbmNpZXMsXG4gKiBhbmQgZmlyZXMgY2FsbGJhY2sgd2hlbiB0aGUgZXhwcmVzc2lvbiB2YWx1ZSBjaGFuZ2VzLlxuICogVGhpcyBpcyB1c2VkIGZvciBib3RoIHRoZSAkd2F0Y2goKSBhcGkgYW5kIGRpcmVjdGl2ZXMuXG4gKi9cbnZhciBXYXRjaGVyID0gZnVuY3Rpb24gV2F0Y2hlciAoXG4gIHZtLFxuICBleHBPckZuLFxuICBjYixcbiAgb3B0aW9uc1xuKSB7XG4gIHRoaXMudm0gPSB2bTtcbiAgdm0uX3dhdGNoZXJzLnB1c2godGhpcyk7XG4gIC8vIG9wdGlvbnNcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICB0aGlzLmRlZXAgPSAhIW9wdGlvbnMuZGVlcDtcbiAgICB0aGlzLnVzZXIgPSAhIW9wdGlvbnMudXNlcjtcbiAgICB0aGlzLmxhenkgPSAhIW9wdGlvbnMubGF6eTtcbiAgICB0aGlzLnN5bmMgPSAhIW9wdGlvbnMuc3luYztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmRlZXAgPSB0aGlzLnVzZXIgPSB0aGlzLmxhenkgPSB0aGlzLnN5bmMgPSBmYWxzZTtcbiAgfVxuICB0aGlzLmNiID0gY2I7XG4gIHRoaXMuaWQgPSArK3VpZCQyOyAvLyB1aWQgZm9yIGJhdGNoaW5nXG4gIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgdGhpcy5kaXJ0eSA9IHRoaXMubGF6eTsgLy8gZm9yIGxhenkgd2F0Y2hlcnNcbiAgdGhpcy5kZXBzID0gW107XG4gIHRoaXMubmV3RGVwcyA9IFtdO1xuICB0aGlzLmRlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMubmV3RGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgdGhpcy5leHByZXNzaW9uID0gZXhwT3JGbi50b1N0cmluZygpO1xuICAvLyBwYXJzZSBleHByZXNzaW9uIGZvciBnZXR0ZXJcbiAgaWYgKHR5cGVvZiBleHBPckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5nZXR0ZXIgPSBleHBPckZuO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZ2V0dGVyID0gcGFyc2VQYXRoKGV4cE9yRm4pO1xuICAgIGlmICghdGhpcy5nZXR0ZXIpIHtcbiAgICAgIHRoaXMuZ2V0dGVyID0gZnVuY3Rpb24gKCkge307XG4gICAgICBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkZhaWxlZCB3YXRjaGluZyBwYXRoOiBcXFwiXCIgKyBleHBPckZuICsgXCJcXFwiIFwiICtcbiAgICAgICAgJ1dhdGNoZXIgb25seSBhY2NlcHRzIHNpbXBsZSBkb3QtZGVsaW1pdGVkIHBhdGhzLiAnICtcbiAgICAgICAgJ0ZvciBmdWxsIGNvbnRyb2wsIHVzZSBhIGZ1bmN0aW9uIGluc3RlYWQuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHRoaXMudmFsdWUgPSB0aGlzLmxhenlcbiAgICA/IHVuZGVmaW5lZFxuICAgIDogdGhpcy5nZXQoKTtcbn07XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIGdldHRlciwgYW5kIHJlLWNvbGxlY3QgZGVwZW5kZW5jaWVzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKCkge1xuICBwdXNoVGFyZ2V0KHRoaXMpO1xuICB2YXIgdmFsdWU7XG4gIHZhciB2bSA9IHRoaXMudm07XG4gIHRyeSB7XG4gICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHZtLCB2bSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKFwiZ2V0dGVyIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICAvLyBcInRvdWNoXCIgZXZlcnkgcHJvcGVydHkgc28gdGhleSBhcmUgYWxsIHRyYWNrZWQgYXNcbiAgICAvLyBkZXBlbmRlbmNpZXMgZm9yIGRlZXAgd2F0Y2hpbmdcbiAgICBpZiAodGhpcy5kZWVwKSB7XG4gICAgICB0cmF2ZXJzZSh2YWx1ZSk7XG4gICAgfVxuICAgIHBvcFRhcmdldCgpO1xuICAgIHRoaXMuY2xlYW51cERlcHMoKTtcbiAgfVxuICByZXR1cm4gdmFsdWVcbn07XG5cbi8qKlxuICogQWRkIGEgZGVwZW5kZW5jeSB0byB0aGlzIGRpcmVjdGl2ZS5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuYWRkRGVwID0gZnVuY3Rpb24gYWRkRGVwIChkZXApIHtcbiAgdmFyIGlkID0gZGVwLmlkO1xuICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhpZCkpIHtcbiAgICB0aGlzLm5ld0RlcElkcy5hZGQoaWQpO1xuICAgIHRoaXMubmV3RGVwcy5wdXNoKGRlcCk7XG4gICAgaWYgKCF0aGlzLmRlcElkcy5oYXMoaWQpKSB7XG4gICAgICBkZXAuYWRkU3ViKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhbiB1cCBmb3IgZGVwZW5kZW5jeSBjb2xsZWN0aW9uLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5jbGVhbnVwRGVwcyA9IGZ1bmN0aW9uIGNsZWFudXBEZXBzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgZGVwID0gdGhpcyQxLmRlcHNbaV07XG4gICAgaWYgKCF0aGlzJDEubmV3RGVwSWRzLmhhcyhkZXAuaWQpKSB7XG4gICAgICBkZXAucmVtb3ZlU3ViKHRoaXMkMSk7XG4gICAgfVxuICB9XG4gIHZhciB0bXAgPSB0aGlzLmRlcElkcztcbiAgdGhpcy5kZXBJZHMgPSB0aGlzLm5ld0RlcElkcztcbiAgdGhpcy5uZXdEZXBJZHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwSWRzLmNsZWFyKCk7XG4gIHRtcCA9IHRoaXMuZGVwcztcbiAgdGhpcy5kZXBzID0gdGhpcy5uZXdEZXBzO1xuICB0aGlzLm5ld0RlcHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwcy5sZW5ndGggPSAwO1xufTtcblxuLyoqXG4gKiBTdWJzY3JpYmVyIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIHdoZW4gYSBkZXBlbmRlbmN5IGNoYW5nZXMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0aGlzLmxhenkpIHtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0aGlzLnN5bmMpIHtcbiAgICB0aGlzLnJ1bigpO1xuICB9IGVsc2Uge1xuICAgIHF1ZXVlV2F0Y2hlcih0aGlzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTY2hlZHVsZXIgam9iIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIHJ1biAoKSB7XG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gICAgaWYgKFxuICAgICAgdmFsdWUgIT09IHRoaXMudmFsdWUgfHxcbiAgICAgIC8vIERlZXAgd2F0Y2hlcnMgYW5kIHdhdGNoZXJzIG9uIE9iamVjdC9BcnJheXMgc2hvdWxkIGZpcmUgZXZlblxuICAgICAgLy8gd2hlbiB0aGUgdmFsdWUgaXMgdGhlIHNhbWUsIGJlY2F1c2UgdGhlIHZhbHVlIG1heVxuICAgICAgLy8gaGF2ZSBtdXRhdGVkLlxuICAgICAgaXNPYmplY3QodmFsdWUpIHx8XG4gICAgICB0aGlzLmRlZXBcbiAgICApIHtcbiAgICAgIC8vIHNldCBuZXcgdmFsdWVcbiAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCB0aGlzLnZtLCAoXCJjYWxsYmFjayBmb3Igd2F0Y2hlciBcXFwiXCIgKyAodGhpcy5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgdmFsdWUgb2YgdGhlIHdhdGNoZXIuXG4gKiBUaGlzIG9ubHkgZ2V0cyBjYWxsZWQgZm9yIGxhenkgd2F0Y2hlcnMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUgKCkge1xuICB0aGlzLnZhbHVlID0gdGhpcy5nZXQoKTtcbiAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBEZXBlbmQgb24gYWxsIGRlcHMgY29sbGVjdGVkIGJ5IHRoaXMgd2F0Y2hlci5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB0aGlzJDEuZGVwc1tpXS5kZXBlbmQoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgc2VsZiBmcm9tIGFsbCBkZXBlbmRlbmNpZXMnIHN1YnNjcmliZXIgbGlzdC5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUudGVhcmRvd24gPSBmdW5jdGlvbiB0ZWFyZG93biAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSB2bSdzIHdhdGNoZXIgbGlzdFxuICAgIC8vIHRoaXMgaXMgYSBzb21ld2hhdCBleHBlbnNpdmUgb3BlcmF0aW9uIHNvIHdlIHNraXAgaXRcbiAgICAvLyBpZiB0aGUgdm0gaXMgYmVpbmcgZGVzdHJveWVkLlxuICAgIGlmICghdGhpcy52bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgcmVtb3ZlKHRoaXMudm0uX3dhdGNoZXJzLCB0aGlzKTtcbiAgICB9XG4gICAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMkMS5kZXBzW2ldLnJlbW92ZVN1Yih0aGlzJDEpO1xuICAgIH1cbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICB9XG59O1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIGFuIG9iamVjdCB0byBldm9rZSBhbGwgY29udmVydGVkXG4gKiBnZXR0ZXJzLCBzbyB0aGF0IGV2ZXJ5IG5lc3RlZCBwcm9wZXJ0eSBpbnNpZGUgdGhlIG9iamVjdFxuICogaXMgY29sbGVjdGVkIGFzIGEgXCJkZWVwXCIgZGVwZW5kZW5jeS5cbiAqL1xudmFyIHNlZW5PYmplY3RzID0gbmV3IF9TZXQoKTtcbmZ1bmN0aW9uIHRyYXZlcnNlICh2YWwpIHtcbiAgc2Vlbk9iamVjdHMuY2xlYXIoKTtcbiAgX3RyYXZlcnNlKHZhbCwgc2Vlbk9iamVjdHMpO1xufVxuXG5mdW5jdGlvbiBfdHJhdmVyc2UgKHZhbCwgc2Vlbikge1xuICB2YXIgaSwga2V5cztcbiAgdmFyIGlzQSA9IEFycmF5LmlzQXJyYXkodmFsKTtcbiAgaWYgKCghaXNBICYmICFpc09iamVjdCh2YWwpKSB8fCAhT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWwpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZhbC5fX29iX18pIHtcbiAgICB2YXIgZGVwSWQgPSB2YWwuX19vYl9fLmRlcC5pZDtcbiAgICBpZiAoc2Vlbi5oYXMoZGVwSWQpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgc2Vlbi5hZGQoZGVwSWQpO1xuICB9XG4gIGlmIChpc0EpIHtcbiAgICBpID0gdmFsLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxbaV0sIHNlZW4pOyB9XG4gIH0gZWxzZSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgaSA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHsgX3RyYXZlcnNlKHZhbFtrZXlzW2ldXSwgc2Vlbik7IH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbiA9IHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IG5vb3AsXG4gIHNldDogbm9vcFxufTtcblxuZnVuY3Rpb24gcHJveHkgKHRhcmdldCwgc291cmNlS2V5LCBrZXkpIHtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IGZ1bmN0aW9uIHByb3h5R2V0dGVyICgpIHtcbiAgICByZXR1cm4gdGhpc1tzb3VyY2VLZXldW2tleV1cbiAgfTtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uIHByb3h5U2V0dGVyICh2YWwpIHtcbiAgICB0aGlzW3NvdXJjZUtleV1ba2V5XSA9IHZhbDtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xufVxuXG5mdW5jdGlvbiBpbml0U3RhdGUgKHZtKSB7XG4gIHZtLl93YXRjaGVycyA9IFtdO1xuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zO1xuICBpZiAob3B0cy5wcm9wcykgeyBpbml0UHJvcHModm0sIG9wdHMucHJvcHMpOyB9XG4gIGlmIChvcHRzLm1ldGhvZHMpIHsgaW5pdE1ldGhvZHModm0sIG9wdHMubWV0aG9kcyk7IH1cbiAgaWYgKG9wdHMuZGF0YSkge1xuICAgIGluaXREYXRhKHZtKTtcbiAgfSBlbHNlIHtcbiAgICBvYnNlcnZlKHZtLl9kYXRhID0ge30sIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG4gIH1cbiAgaWYgKG9wdHMuY29tcHV0ZWQpIHsgaW5pdENvbXB1dGVkKHZtLCBvcHRzLmNvbXB1dGVkKTsgfVxuICBpZiAob3B0cy53YXRjaCAmJiBvcHRzLndhdGNoICE9PSBuYXRpdmVXYXRjaCkge1xuICAgIGluaXRXYXRjaCh2bSwgb3B0cy53YXRjaCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tPcHRpb25UeXBlICh2bSwgbmFtZSkge1xuICB2YXIgb3B0aW9uID0gdm0uJG9wdGlvbnNbbmFtZV07XG4gIGlmICghaXNQbGFpbk9iamVjdChvcHRpb24pKSB7XG4gICAgd2FybihcbiAgICAgIChcImNvbXBvbmVudCBvcHRpb24gXFxcIlwiICsgbmFtZSArIFwiXFxcIiBzaG91bGQgYmUgYW4gb2JqZWN0LlwiKSxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0UHJvcHMgKHZtLCBwcm9wc09wdGlvbnMpIHtcbiAgdmFyIHByb3BzRGF0YSA9IHZtLiRvcHRpb25zLnByb3BzRGF0YSB8fCB7fTtcbiAgdmFyIHByb3BzID0gdm0uX3Byb3BzID0ge307XG4gIC8vIGNhY2hlIHByb3Aga2V5cyBzbyB0aGF0IGZ1dHVyZSBwcm9wcyB1cGRhdGVzIGNhbiBpdGVyYXRlIHVzaW5nIEFycmF5XG4gIC8vIGluc3RlYWQgb2YgZHluYW1pYyBvYmplY3Qga2V5IGVudW1lcmF0aW9uLlxuICB2YXIga2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyA9IFtdO1xuICB2YXIgaXNSb290ID0gIXZtLiRwYXJlbnQ7XG4gIC8vIHJvb3QgaW5zdGFuY2UgcHJvcHMgc2hvdWxkIGJlIGNvbnZlcnRlZFxuICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSBpc1Jvb3Q7XG4gIHZhciBsb29wID0gZnVuY3Rpb24gKCBrZXkgKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gICAgdmFyIHZhbHVlID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcHNPcHRpb25zLCBwcm9wc0RhdGEsIHZtKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIHtcbiAgICAgIGlmIChpc1Jlc2VydmVkQXR0cmlidXRlKGtleSkgfHwgY29uZmlnLmlzUmVzZXJ2ZWRBdHRyKGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUgYW5kIGNhbm5vdCBiZSB1c2VkIGFzIGNvbXBvbmVudCBwcm9wLlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZGVmaW5lUmVhY3RpdmUkJDEocHJvcHMsIGtleSwgdmFsdWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHZtLiRwYXJlbnQgJiYgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBcIkF2b2lkIG11dGF0aW5nIGEgcHJvcCBkaXJlY3RseSBzaW5jZSB0aGUgdmFsdWUgd2lsbCBiZSBcIiArXG4gICAgICAgICAgICBcIm92ZXJ3cml0dGVuIHdoZW5ldmVyIHRoZSBwYXJlbnQgY29tcG9uZW50IHJlLXJlbmRlcnMuIFwiICtcbiAgICAgICAgICAgIFwiSW5zdGVhZCwgdXNlIGEgZGF0YSBvciBjb21wdXRlZCBwcm9wZXJ0eSBiYXNlZCBvbiB0aGUgcHJvcCdzIFwiICtcbiAgICAgICAgICAgIFwidmFsdWUuIFByb3AgYmVpbmcgbXV0YXRlZDogXFxcIlwiICsga2V5ICsgXCJcXFwiXCIsXG4gICAgICAgICAgICB2bVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBzdGF0aWMgcHJvcHMgYXJlIGFscmVhZHkgcHJveGllZCBvbiB0aGUgY29tcG9uZW50J3MgcHJvdG90eXBlXG4gICAgLy8gZHVyaW5nIFZ1ZS5leHRlbmQoKS4gV2Ugb25seSBuZWVkIHRvIHByb3h5IHByb3BzIGRlZmluZWQgYXRcbiAgICAvLyBpbnN0YW50aWF0aW9uIGhlcmUuXG4gICAgaWYgKCEoa2V5IGluIHZtKSkge1xuICAgICAgcHJveHkodm0sIFwiX3Byb3BzXCIsIGtleSk7XG4gICAgfVxuICB9O1xuXG4gIGZvciAodmFyIGtleSBpbiBwcm9wc09wdGlvbnMpIGxvb3AoIGtleSApO1xuICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBpbml0RGF0YSAodm0pIHtcbiAgdmFyIGRhdGEgPSB2bS4kb3B0aW9ucy5kYXRhO1xuICBkYXRhID0gdm0uX2RhdGEgPSB0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gZ2V0RGF0YShkYXRhLCB2bSlcbiAgICA6IGRhdGEgfHwge307XG4gIGlmICghaXNQbGFpbk9iamVjdChkYXRhKSkge1xuICAgIGRhdGEgPSB7fTtcbiAgICBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ2RhdGEgZnVuY3Rpb25zIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0OlxcbicgK1xuICAgICAgJ2h0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL2NvbXBvbmVudHMuaHRtbCNkYXRhLU11c3QtQmUtYS1GdW5jdGlvbicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gcHJveHkgZGF0YSBvbiBpbnN0YW5jZVxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgdmFyIG1ldGhvZHMgPSB2bS4kb3B0aW9ucy5tZXRob2RzO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAge1xuICAgICAgaWYgKG1ldGhvZHMgJiYgaGFzT3duKG1ldGhvZHMsIGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJtZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBhcyBhIGRhdGEgcHJvcGVydHkuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleSkpIHtcbiAgICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiVGhlIGRhdGEgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVjbGFyZWQgYXMgYSBwcm9wLiBcIiArXG4gICAgICAgIFwiVXNlIHByb3AgZGVmYXVsdCB2YWx1ZSBpbnN0ZWFkLlwiLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKCFpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9kYXRhXCIsIGtleSk7XG4gICAgfVxuICB9XG4gIC8vIG9ic2VydmUgZGF0YVxuICBvYnNlcnZlKGRhdGEsIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG59XG5cbmZ1bmN0aW9uIGdldERhdGEgKGRhdGEsIHZtKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRhdGEuY2FsbCh2bSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcImRhdGEoKVwiKTtcbiAgICByZXR1cm4ge31cbiAgfVxufVxuXG52YXIgY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyA9IHsgbGF6eTogdHJ1ZSB9O1xuXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQgKHZtLCBjb21wdXRlZCkge1xuICBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBjaGVja09wdGlvblR5cGUodm0sICdjb21wdXRlZCcpO1xuICB2YXIgd2F0Y2hlcnMgPSB2bS5fY29tcHV0ZWRXYXRjaGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgdmFyIHVzZXJEZWYgPSBjb21wdXRlZFtrZXldO1xuICAgIHZhciBnZXR0ZXIgPSB0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJyA/IHVzZXJEZWYgOiB1c2VyRGVmLmdldDtcbiAgICB7XG4gICAgICBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJObyBnZXR0ZXIgZnVuY3Rpb24gaGFzIGJlZW4gZGVmaW5lZCBmb3IgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgICBnZXR0ZXIgPSBub29wO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBjcmVhdGUgaW50ZXJuYWwgd2F0Y2hlciBmb3IgdGhlIGNvbXB1dGVkIHByb3BlcnR5LlxuICAgIHdhdGNoZXJzW2tleV0gPSBuZXcgV2F0Y2hlcih2bSwgZ2V0dGVyLCBub29wLCBjb21wdXRlZFdhdGNoZXJPcHRpb25zKTtcblxuICAgIC8vIGNvbXBvbmVudC1kZWZpbmVkIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGFscmVhZHkgZGVmaW5lZCBvbiB0aGVcbiAgICAvLyBjb21wb25lbnQgcHJvdG90eXBlLiBXZSBvbmx5IG5lZWQgdG8gZGVmaW5lIGNvbXB1dGVkIHByb3BlcnRpZXMgZGVmaW5lZFxuICAgIC8vIGF0IGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICBpZiAoIShrZXkgaW4gdm0pKSB7XG4gICAgICBkZWZpbmVDb21wdXRlZCh2bSwga2V5LCB1c2VyRGVmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGtleSBpbiB2bS4kZGF0YSkge1xuICAgICAgICB3YXJuKChcIlRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWZpbmVkIGluIGRhdGEuXCIpLCB2bSk7XG4gICAgICB9IGVsc2UgaWYgKHZtLiRvcHRpb25zLnByb3BzICYmIGtleSBpbiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgICAgICB3YXJuKChcIlRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWZpbmVkIGFzIGEgcHJvcC5cIiksIHZtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lQ29tcHV0ZWQgKHRhcmdldCwga2V5LCB1c2VyRGVmKSB7XG4gIGlmICh0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBub29wO1xuICB9IGVsc2Uge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSB1c2VyRGVmLmdldFxuICAgICAgPyB1c2VyRGVmLmNhY2hlICE9PSBmYWxzZVxuICAgICAgICA/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcbiAgICAgICAgOiB1c2VyRGVmLmdldFxuICAgICAgOiBub29wO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSB1c2VyRGVmLnNldFxuICAgICAgPyB1c2VyRGVmLnNldFxuICAgICAgOiBub29wO1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIgKGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIgKCkge1xuICAgIHZhciB3YXRjaGVyID0gdGhpcy5fY29tcHV0ZWRXYXRjaGVycyAmJiB0aGlzLl9jb21wdXRlZFdhdGNoZXJzW2tleV07XG4gICAgaWYgKHdhdGNoZXIpIHtcbiAgICAgIGlmICh3YXRjaGVyLmRpcnR5KSB7XG4gICAgICAgIHdhdGNoZXIuZXZhbHVhdGUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIHdhdGNoZXIuZGVwZW5kKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2F0Y2hlci52YWx1ZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0TWV0aG9kcyAodm0sIG1ldGhvZHMpIHtcbiAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgY2hlY2tPcHRpb25UeXBlKHZtLCAnbWV0aG9kcycpO1xuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgZm9yICh2YXIga2V5IGluIG1ldGhvZHMpIHtcbiAgICB2bVtrZXldID0gbWV0aG9kc1trZXldID09IG51bGwgPyBub29wIDogYmluZChtZXRob2RzW2tleV0sIHZtKTtcbiAgICB7XG4gICAgICBpZiAobWV0aG9kc1trZXldID09IG51bGwpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIm1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFuIHVuZGVmaW5lZCB2YWx1ZSBpbiB0aGUgY29tcG9uZW50IGRlZmluaXRpb24uIFwiICtcbiAgICAgICAgICBcIkRpZCB5b3UgcmVmZXJlbmNlIHRoZSBmdW5jdGlvbiBjb3JyZWN0bHk/XCIsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJtZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBhcyBhIHByb3AuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRXYXRjaCAodm0sIHdhdGNoKSB7XG4gIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoZWNrT3B0aW9uVHlwZSh2bSwgJ3dhdGNoJyk7XG4gIGZvciAodmFyIGtleSBpbiB3YXRjaCkge1xuICAgIHZhciBoYW5kbGVyID0gd2F0Y2hba2V5XTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcltpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdhdGNoZXIgKFxuICB2bSxcbiAga2V5T3JGbixcbiAgaGFuZGxlcixcbiAgb3B0aW9uc1xuKSB7XG4gIGlmIChpc1BsYWluT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgb3B0aW9ucyA9IGhhbmRsZXI7XG4gICAgaGFuZGxlciA9IGhhbmRsZXIuaGFuZGxlcjtcbiAgfVxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgaGFuZGxlciA9IHZtW2hhbmRsZXJdO1xuICB9XG4gIHJldHVybiB2bS4kd2F0Y2goa2V5T3JGbiwgaGFuZGxlciwgb3B0aW9ucylcbn1cblxuZnVuY3Rpb24gc3RhdGVNaXhpbiAoVnVlKSB7XG4gIC8vIGZsb3cgc29tZWhvdyBoYXMgcHJvYmxlbXMgd2l0aCBkaXJlY3RseSBkZWNsYXJlZCBkZWZpbml0aW9uIG9iamVjdFxuICAvLyB3aGVuIHVzaW5nIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgc28gd2UgaGF2ZSB0byBwcm9jZWR1cmFsbHkgYnVpbGQgdXBcbiAgLy8gdGhlIG9iamVjdCBoZXJlLlxuICB2YXIgZGF0YURlZiA9IHt9O1xuICBkYXRhRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RhdGEgfTtcbiAgdmFyIHByb3BzRGVmID0ge307XG4gIHByb3BzRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Byb3BzIH07XG4gIHtcbiAgICBkYXRhRGVmLnNldCA9IGZ1bmN0aW9uIChuZXdEYXRhKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnQXZvaWQgcmVwbGFjaW5nIGluc3RhbmNlIHJvb3QgJGRhdGEuICcgK1xuICAgICAgICAnVXNlIG5lc3RlZCBkYXRhIHByb3BlcnRpZXMgaW5zdGVhZC4nLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH07XG4gICAgcHJvcHNEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcIiRwcm9wcyBpcyByZWFkb25seS5cIiwgdGhpcyk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRkYXRhJywgZGF0YURlZik7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHByb3BzJywgcHJvcHNEZWYpO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHNldCA9IHNldDtcbiAgVnVlLnByb3RvdHlwZS4kZGVsZXRlID0gZGVsO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHdhdGNoID0gZnVuY3Rpb24gKFxuICAgIGV4cE9yRm4sXG4gICAgY2IsXG4gICAgb3B0aW9uc1xuICApIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChpc1BsYWluT2JqZWN0KGNiKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKVxuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLnVzZXIgPSB0cnVlO1xuICAgIHZhciB3YXRjaGVyID0gbmV3IFdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5pbW1lZGlhdGUpIHtcbiAgICAgIGNiLmNhbGwodm0sIHdhdGNoZXIudmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gdW53YXRjaEZuICgpIHtcbiAgICAgIHdhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0UHJvdmlkZSAodm0pIHtcbiAgdmFyIHByb3ZpZGUgPSB2bS4kb3B0aW9ucy5wcm92aWRlO1xuICBpZiAocHJvdmlkZSkge1xuICAgIHZtLl9wcm92aWRlZCA9IHR5cGVvZiBwcm92aWRlID09PSAnZnVuY3Rpb24nXG4gICAgICA/IHByb3ZpZGUuY2FsbCh2bSlcbiAgICAgIDogcHJvdmlkZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0SW5qZWN0aW9ucyAodm0pIHtcbiAgdmFyIHJlc3VsdCA9IHJlc29sdmVJbmplY3Qodm0uJG9wdGlvbnMuaW5qZWN0LCB2bSk7XG4gIGlmIChyZXN1bHQpIHtcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSBmYWxzZTtcbiAgICBPYmplY3Qua2V5cyhyZXN1bHQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIHtcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sIGtleSwgcmVzdWx0W2tleV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhbiBpbmplY3RlZCB2YWx1ZSBkaXJlY3RseSBzaW5jZSB0aGUgY2hhbmdlcyB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHByb3ZpZGVkIGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICBcImluamVjdGlvbiBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlSW5qZWN0IChpbmplY3QsIHZtKSB7XG4gIGlmIChpbmplY3QpIHtcbiAgICAvLyBpbmplY3QgaXMgOmFueSBiZWNhdXNlIGZsb3cgaXMgbm90IHNtYXJ0IGVub3VnaCB0byBmaWd1cmUgb3V0IGNhY2hlZFxuICAgIHZhciByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBrZXlzID0gaGFzU3ltYm9sXG4gICAgICAgID8gUmVmbGVjdC5vd25LZXlzKGluamVjdClcbiAgICAgICAgOiBPYmplY3Qua2V5cyhpbmplY3QpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIHZhciBwcm92aWRlS2V5ID0gaW5qZWN0W2tleV07XG4gICAgICB2YXIgc291cmNlID0gdm07XG4gICAgICB3aGlsZSAoc291cmNlKSB7XG4gICAgICAgIGlmIChzb3VyY2UuX3Byb3ZpZGVkICYmIHByb3ZpZGVLZXkgaW4gc291cmNlLl9wcm92aWRlZCkge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gc291cmNlLl9wcm92aWRlZFtwcm92aWRlS2V5XTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZSA9IHNvdXJjZS4kcGFyZW50O1xuICAgICAgfVxuICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmICFoYXNPd24ocmVzdWx0LCBrZXkpKSB7XG4gICAgICAgIHdhcm4oKFwiSW5qZWN0aW9uIFxcXCJcIiArIGtleSArIFwiXFxcIiBub3QgZm91bmRcIiksIHZtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgcHJvcHNEYXRhLFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlblxuKSB7XG4gIHZhciBwcm9wcyA9IHt9O1xuICB2YXIgcHJvcE9wdGlvbnMgPSBDdG9yLm9wdGlvbnMucHJvcHM7XG4gIGlmIChpc0RlZihwcm9wT3B0aW9ucykpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcE9wdGlvbnMpIHtcbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wT3B0aW9ucywgcHJvcHNEYXRhIHx8IHt9KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzRGVmKGRhdGEuYXR0cnMpKSB7IG1lcmdlUHJvcHMocHJvcHMsIGRhdGEuYXR0cnMpOyB9XG4gICAgaWYgKGlzRGVmKGRhdGEucHJvcHMpKSB7IG1lcmdlUHJvcHMocHJvcHMsIGRhdGEucHJvcHMpOyB9XG4gIH1cbiAgLy8gZW5zdXJlIHRoZSBjcmVhdGVFbGVtZW50IGZ1bmN0aW9uIGluIGZ1bmN0aW9uYWwgY29tcG9uZW50c1xuICAvLyBnZXRzIGEgdW5pcXVlIGNvbnRleHQgLSB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgY29ycmVjdCBuYW1lZCBzbG90IGNoZWNrXG4gIHZhciBfY29udGV4dCA9IE9iamVjdC5jcmVhdGUoY29udGV4dCk7XG4gIHZhciBoID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoX2NvbnRleHQsIGEsIGIsIGMsIGQsIHRydWUpOyB9O1xuICB2YXIgdm5vZGUgPSBDdG9yLm9wdGlvbnMucmVuZGVyLmNhbGwobnVsbCwgaCwge1xuICAgIGRhdGE6IGRhdGEsXG4gICAgcHJvcHM6IHByb3BzLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBwYXJlbnQ6IGNvbnRleHQsXG4gICAgbGlzdGVuZXJzOiBkYXRhLm9uIHx8IHt9LFxuICAgIGluamVjdGlvbnM6IHJlc29sdmVJbmplY3QoQ3Rvci5vcHRpb25zLmluamVjdCwgY29udGV4dCksXG4gICAgc2xvdHM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc29sdmVTbG90cyhjaGlsZHJlbiwgY29udGV4dCk7IH1cbiAgfSk7XG4gIGlmICh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgdm5vZGUuZnVuY3Rpb25hbENvbnRleHQgPSBjb250ZXh0O1xuICAgIHZub2RlLmZ1bmN0aW9uYWxPcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICAgIGlmIChkYXRhLnNsb3QpIHtcbiAgICAgICh2bm9kZS5kYXRhIHx8ICh2bm9kZS5kYXRhID0ge30pKS5zbG90ID0gZGF0YS5zbG90O1xuICAgIH1cbiAgfVxuICByZXR1cm4gdm5vZGVcbn1cblxuZnVuY3Rpb24gbWVyZ2VQcm9wcyAodG8sIGZyb20pIHtcbiAgZm9yICh2YXIga2V5IGluIGZyb20pIHtcbiAgICB0b1tjYW1lbGl6ZShrZXkpXSA9IGZyb21ba2V5XTtcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gaG9va3MgdG8gYmUgaW52b2tlZCBvbiBjb21wb25lbnQgVk5vZGVzIGR1cmluZyBwYXRjaFxudmFyIGNvbXBvbmVudFZOb2RlSG9va3MgPSB7XG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQgKFxuICAgIHZub2RlLFxuICAgIGh5ZHJhdGluZyxcbiAgICBwYXJlbnRFbG0sXG4gICAgcmVmRWxtXG4gICkge1xuICAgIGlmICghdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgfHwgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUoXG4gICAgICAgIHZub2RlLFxuICAgICAgICBhY3RpdmVJbnN0YW5jZSxcbiAgICAgICAgcGFyZW50RWxtLFxuICAgICAgICByZWZFbG1cbiAgICAgICk7XG4gICAgICBjaGlsZC4kbW91bnQoaHlkcmF0aW5nID8gdm5vZGUuZWxtIDogdW5kZWZpbmVkLCBoeWRyYXRpbmcpO1xuICAgIH0gZWxzZSBpZiAodm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgIC8vIGtlcHQtYWxpdmUgY29tcG9uZW50cywgdHJlYXQgYXMgYSBwYXRjaFxuICAgICAgdmFyIG1vdW50ZWROb2RlID0gdm5vZGU7IC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICAgIGNvbXBvbmVudFZOb2RlSG9va3MucHJlcGF0Y2gobW91bnRlZE5vZGUsIG1vdW50ZWROb2RlKTtcbiAgICB9XG4gIH0sXG5cbiAgcHJlcGF0Y2g6IGZ1bmN0aW9uIHByZXBhdGNoIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICB1cGRhdGVDaGlsZENvbXBvbmVudChcbiAgICAgIGNoaWxkLFxuICAgICAgb3B0aW9ucy5wcm9wc0RhdGEsIC8vIHVwZGF0ZWQgcHJvcHNcbiAgICAgIG9wdGlvbnMubGlzdGVuZXJzLCAvLyB1cGRhdGVkIGxpc3RlbmVyc1xuICAgICAgdm5vZGUsIC8vIG5ldyBwYXJlbnQgdm5vZGVcbiAgICAgIG9wdGlvbnMuY2hpbGRyZW4gLy8gbmV3IGNoaWxkcmVuXG4gICAgKTtcbiAgfSxcblxuICBpbnNlcnQ6IGZ1bmN0aW9uIGluc2VydCAodm5vZGUpIHtcbiAgICB2YXIgY29udGV4dCA9IHZub2RlLmNvbnRleHQ7XG4gICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgaWYgKCFjb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkKSB7XG4gICAgICBjb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICAgIGNhbGxIb29rKGNvbXBvbmVudEluc3RhbmNlLCAnbW91bnRlZCcpO1xuICAgIH1cbiAgICBpZiAodm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgIGlmIChjb250ZXh0Ll9pc01vdW50ZWQpIHtcbiAgICAgICAgLy8gdnVlLXJvdXRlciMxMjEyXG4gICAgICAgIC8vIER1cmluZyB1cGRhdGVzLCBhIGtlcHQtYWxpdmUgY29tcG9uZW50J3MgY2hpbGQgY29tcG9uZW50cyBtYXlcbiAgICAgICAgLy8gY2hhbmdlLCBzbyBkaXJlY3RseSB3YWxraW5nIHRoZSB0cmVlIGhlcmUgbWF5IGNhbGwgYWN0aXZhdGVkIGhvb2tzXG4gICAgICAgIC8vIG9uIGluY29ycmVjdCBjaGlsZHJlbi4gSW5zdGVhZCB3ZSBwdXNoIHRoZW0gaW50byBhIHF1ZXVlIHdoaWNoIHdpbGxcbiAgICAgICAgLy8gYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSB3aG9sZSBwYXRjaCBwcm9jZXNzIGVuZGVkLlxuICAgICAgICBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XG4gICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgaWYgKCFjb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQpIHtcbiAgICAgIGlmICghdm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgICAgY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIGhvb2tzVG9NZXJnZSA9IE9iamVjdC5rZXlzKGNvbXBvbmVudFZOb2RlSG9va3MpO1xuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKFxuICBDdG9yLFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlbixcbiAgdGFnXG4pIHtcbiAgaWYgKGlzVW5kZWYoQ3RvcikpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBiYXNlQ3RvciA9IGNvbnRleHQuJG9wdGlvbnMuX2Jhc2U7XG5cbiAgLy8gcGxhaW4gb3B0aW9ucyBvYmplY3Q6IHR1cm4gaXQgaW50byBhIGNvbnN0cnVjdG9yXG4gIGlmIChpc09iamVjdChDdG9yKSkge1xuICAgIEN0b3IgPSBiYXNlQ3Rvci5leHRlbmQoQ3Rvcik7XG4gIH1cblxuICAvLyBpZiBhdCB0aGlzIHN0YWdlIGl0J3Mgbm90IGEgY29uc3RydWN0b3Igb3IgYW4gYXN5bmMgY29tcG9uZW50IGZhY3RvcnksXG4gIC8vIHJlamVjdC5cbiAgaWYgKHR5cGVvZiBDdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgd2FybigoXCJJbnZhbGlkIENvbXBvbmVudCBkZWZpbml0aW9uOiBcIiArIChTdHJpbmcoQ3RvcikpKSwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gYXN5bmMgY29tcG9uZW50XG4gIHZhciBhc3luY0ZhY3Rvcnk7XG4gIGlmIChpc1VuZGVmKEN0b3IuY2lkKSkge1xuICAgIGFzeW5jRmFjdG9yeSA9IEN0b3I7XG4gICAgQ3RvciA9IHJlc29sdmVBc3luY0NvbXBvbmVudChhc3luY0ZhY3RvcnksIGJhc2VDdG9yLCBjb250ZXh0KTtcbiAgICBpZiAoQ3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciBub2RlIGZvciBhc3luYyBjb21wb25lbnQsIHdoaWNoIGlzIHJlbmRlcmVkXG4gICAgICAvLyBhcyBhIGNvbW1lbnQgbm9kZSBidXQgcHJlc2VydmVzIGFsbCB0aGUgcmF3IGluZm9ybWF0aW9uIGZvciB0aGUgbm9kZS5cbiAgICAgIC8vIHRoZSBpbmZvcm1hdGlvbiB3aWxsIGJlIHVzZWQgZm9yIGFzeW5jIHNlcnZlci1yZW5kZXJpbmcgYW5kIGh5ZHJhdGlvbi5cbiAgICAgIHJldHVybiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyKFxuICAgICAgICBhc3luY0ZhY3RvcnksXG4gICAgICAgIGRhdGEsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICB0YWdcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICBkYXRhID0gZGF0YSB8fCB7fTtcblxuICAvLyByZXNvbHZlIGNvbnN0cnVjdG9yIG9wdGlvbnMgaW4gY2FzZSBnbG9iYWwgbWl4aW5zIGFyZSBhcHBsaWVkIGFmdGVyXG4gIC8vIGNvbXBvbmVudCBjb25zdHJ1Y3RvciBjcmVhdGlvblxuICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3IpO1xuXG4gIC8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBkYXRhIGludG8gcHJvcHMgJiBldmVudHNcbiAgaWYgKGlzRGVmKGRhdGEubW9kZWwpKSB7XG4gICAgdHJhbnNmb3JtTW9kZWwoQ3Rvci5vcHRpb25zLCBkYXRhKTtcbiAgfVxuXG4gIC8vIGV4dHJhY3QgcHJvcHNcbiAgdmFyIHByb3BzRGF0YSA9IGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEoZGF0YSwgQ3RvciwgdGFnKTtcblxuICAvLyBmdW5jdGlvbmFsIGNvbXBvbmVudFxuICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5mdW5jdGlvbmFsKSkge1xuICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50KEN0b3IsIHByb3BzRGF0YSwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pXG4gIH1cblxuICAvLyBrZWVwIGxpc3RlbmVyc1xuICB2YXIgbGlzdGVuZXJzID0gZGF0YS5vbjtcblxuICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5hYnN0cmFjdCkpIHtcbiAgICAvLyBhYnN0cmFjdCBjb21wb25lbnRzIGRvIG5vdCBrZWVwIGFueXRoaW5nXG4gICAgLy8gb3RoZXIgdGhhbiBwcm9wcyAmIGxpc3RlbmVycyAmIHNsb3RcblxuICAgIC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICB2YXIgc2xvdCA9IGRhdGEuc2xvdDtcbiAgICBkYXRhID0ge307XG4gICAgaWYgKHNsb3QpIHtcbiAgICAgIGRhdGEuc2xvdCA9IHNsb3Q7XG4gICAgfVxuICB9XG5cbiAgLy8gbWVyZ2UgY29tcG9uZW50IG1hbmFnZW1lbnQgaG9va3Mgb250byB0aGUgcGxhY2Vob2xkZXIgbm9kZVxuICBtZXJnZUhvb2tzKGRhdGEpO1xuXG4gIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIHZub2RlXG4gIHZhciBuYW1lID0gQ3Rvci5vcHRpb25zLm5hbWUgfHwgdGFnO1xuICB2YXIgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgKFwidnVlLWNvbXBvbmVudC1cIiArIChDdG9yLmNpZCkgKyAobmFtZSA/IChcIi1cIiArIG5hbWUpIDogJycpKSxcbiAgICBkYXRhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0LFxuICAgIHsgQ3RvcjogQ3RvciwgcHJvcHNEYXRhOiBwcm9wc0RhdGEsIGxpc3RlbmVyczogbGlzdGVuZXJzLCB0YWc6IHRhZywgY2hpbGRyZW46IGNoaWxkcmVuIH0sXG4gICAgYXN5bmNGYWN0b3J5XG4gICk7XG4gIHJldHVybiB2bm9kZVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlIChcbiAgdm5vZGUsIC8vIHdlIGtub3cgaXQncyBNb3VudGVkQ29tcG9uZW50Vk5vZGUgYnV0IGZsb3cgZG9lc24ndFxuICBwYXJlbnQsIC8vIGFjdGl2ZUluc3RhbmNlIGluIGxpZmVjeWNsZSBzdGF0ZVxuICBwYXJlbnRFbG0sXG4gIHJlZkVsbVxuKSB7XG4gIHZhciB2bm9kZUNvbXBvbmVudE9wdGlvbnMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICB2YXIgb3B0aW9ucyA9IHtcbiAgICBfaXNDb21wb25lbnQ6IHRydWUsXG4gICAgcGFyZW50OiBwYXJlbnQsXG4gICAgcHJvcHNEYXRhOiB2bm9kZUNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhLFxuICAgIF9jb21wb25lbnRUYWc6IHZub2RlQ29tcG9uZW50T3B0aW9ucy50YWcsXG4gICAgX3BhcmVudFZub2RlOiB2bm9kZSxcbiAgICBfcGFyZW50TGlzdGVuZXJzOiB2bm9kZUNvbXBvbmVudE9wdGlvbnMubGlzdGVuZXJzLFxuICAgIF9yZW5kZXJDaGlsZHJlbjogdm5vZGVDb21wb25lbnRPcHRpb25zLmNoaWxkcmVuLFxuICAgIF9wYXJlbnRFbG06IHBhcmVudEVsbSB8fCBudWxsLFxuICAgIF9yZWZFbG06IHJlZkVsbSB8fCBudWxsXG4gIH07XG4gIC8vIGNoZWNrIGlubGluZS10ZW1wbGF0ZSByZW5kZXIgZnVuY3Rpb25zXG4gIHZhciBpbmxpbmVUZW1wbGF0ZSA9IHZub2RlLmRhdGEuaW5saW5lVGVtcGxhdGU7XG4gIGlmIChpc0RlZihpbmxpbmVUZW1wbGF0ZSkpIHtcbiAgICBvcHRpb25zLnJlbmRlciA9IGlubGluZVRlbXBsYXRlLnJlbmRlcjtcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGlubGluZVRlbXBsYXRlLnN0YXRpY1JlbmRlckZucztcbiAgfVxuICByZXR1cm4gbmV3IHZub2RlQ29tcG9uZW50T3B0aW9ucy5DdG9yKG9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIG1lcmdlSG9va3MgKGRhdGEpIHtcbiAgaWYgKCFkYXRhLmhvb2spIHtcbiAgICBkYXRhLmhvb2sgPSB7fTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzVG9NZXJnZS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBob29rc1RvTWVyZ2VbaV07XG4gICAgdmFyIGZyb21QYXJlbnQgPSBkYXRhLmhvb2tba2V5XTtcbiAgICB2YXIgb3VycyA9IGNvbXBvbmVudFZOb2RlSG9va3Nba2V5XTtcbiAgICBkYXRhLmhvb2tba2V5XSA9IGZyb21QYXJlbnQgPyBtZXJnZUhvb2skMShvdXJzLCBmcm9tUGFyZW50KSA6IG91cnM7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWVyZ2VIb29rJDEgKG9uZSwgdHdvKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xuICAgIG9uZShhLCBiLCBjLCBkKTtcbiAgICB0d28oYSwgYiwgYywgZCk7XG4gIH1cbn1cblxuLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGluZm8gKHZhbHVlIGFuZCBjYWxsYmFjaykgaW50b1xuLy8gcHJvcCBhbmQgZXZlbnQgaGFuZGxlciByZXNwZWN0aXZlbHkuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Nb2RlbCAob3B0aW9ucywgZGF0YSkge1xuICB2YXIgcHJvcCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwucHJvcCkgfHwgJ3ZhbHVlJztcbiAgdmFyIGV2ZW50ID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5ldmVudCkgfHwgJ2lucHV0JzsoZGF0YS5wcm9wcyB8fCAoZGF0YS5wcm9wcyA9IHt9KSlbcHJvcF0gPSBkYXRhLm1vZGVsLnZhbHVlO1xuICB2YXIgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xuICBpZiAoaXNEZWYob25bZXZlbnRdKSkge1xuICAgIG9uW2V2ZW50XSA9IFtkYXRhLm1vZGVsLmNhbGxiYWNrXS5jb25jYXQob25bZXZlbnRdKTtcbiAgfSBlbHNlIHtcbiAgICBvbltldmVudF0gPSBkYXRhLm1vZGVsLmNhbGxiYWNrO1xuICB9XG59XG5cbi8qICAqL1xuXG52YXIgU0lNUExFX05PUk1BTElaRSA9IDE7XG52YXIgQUxXQVlTX05PUk1BTElaRSA9IDI7XG5cbi8vIHdyYXBwZXIgZnVuY3Rpb24gZm9yIHByb3ZpZGluZyBhIG1vcmUgZmxleGlibGUgaW50ZXJmYWNlXG4vLyB3aXRob3V0IGdldHRpbmcgeWVsbGVkIGF0IGJ5IGZsb3dcbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQgKFxuICBjb250ZXh0LFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICBub3JtYWxpemF0aW9uVHlwZSxcbiAgYWx3YXlzTm9ybWFsaXplXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkgfHwgaXNQcmltaXRpdmUoZGF0YSkpIHtcbiAgICBub3JtYWxpemF0aW9uVHlwZSA9IGNoaWxkcmVuO1xuICAgIGNoaWxkcmVuID0gZGF0YTtcbiAgICBkYXRhID0gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChpc1RydWUoYWx3YXlzTm9ybWFsaXplKSkge1xuICAgIG5vcm1hbGl6YXRpb25UeXBlID0gQUxXQVlTX05PUk1BTElaRTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUVsZW1lbnQoY29udGV4dCwgdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUpXG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGVcbikge1xuICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoKGRhdGEpLl9fb2JfXykpIHtcbiAgICBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgXCJBdm9pZCB1c2luZyBvYnNlcnZlZCBkYXRhIG9iamVjdCBhcyB2bm9kZSBkYXRhOiBcIiArIChKU09OLnN0cmluZ2lmeShkYXRhKSkgKyBcIlxcblwiICtcbiAgICAgICdBbHdheXMgY3JlYXRlIGZyZXNoIHZub2RlIGRhdGEgb2JqZWN0cyBpbiBlYWNoIHJlbmRlciEnLFxuICAgICAgY29udGV4dFxuICAgICk7XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG4gIC8vIG9iamVjdCBzeW50YXggaW4gdi1iaW5kXG4gIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihkYXRhLmlzKSkge1xuICAgIHRhZyA9IGRhdGEuaXM7XG4gIH1cbiAgaWYgKCF0YWcpIHtcbiAgICAvLyBpbiBjYXNlIG9mIGNvbXBvbmVudCA6aXMgc2V0IHRvIGZhbHN5IHZhbHVlXG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG4gIC8vIHdhcm4gYWdhaW5zdCBub24tcHJpbWl0aXZlIGtleVxuICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICBpc0RlZihkYXRhKSAmJiBpc0RlZihkYXRhLmtleSkgJiYgIWlzUHJpbWl0aXZlKGRhdGEua2V5KVxuICApIHtcbiAgICB3YXJuKFxuICAgICAgJ0F2b2lkIHVzaW5nIG5vbi1wcmltaXRpdmUgdmFsdWUgYXMga2V5LCAnICtcbiAgICAgICd1c2Ugc3RyaW5nL251bWJlciB2YWx1ZSBpbnN0ZWFkLicsXG4gICAgICBjb250ZXh0XG4gICAgKTtcbiAgfVxuICAvLyBzdXBwb3J0IHNpbmdsZSBmdW5jdGlvbiBjaGlsZHJlbiBhcyBkZWZhdWx0IHNjb3BlZCBzbG90XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJlxuICAgIHR5cGVvZiBjaGlsZHJlblswXSA9PT0gJ2Z1bmN0aW9uJ1xuICApIHtcbiAgICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgICBkYXRhLnNjb3BlZFNsb3RzID0geyBkZWZhdWx0OiBjaGlsZHJlblswXSB9O1xuICAgIGNoaWxkcmVuLmxlbmd0aCA9IDA7XG4gIH1cbiAgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBBTFdBWVNfTk9STUFMSVpFKSB7XG4gICAgY2hpbGRyZW4gPSBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gIH0gZWxzZSBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IFNJTVBMRV9OT1JNQUxJWkUpIHtcbiAgICBjaGlsZHJlbiA9IHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgfVxuICB2YXIgdm5vZGUsIG5zO1xuICBpZiAodHlwZW9mIHRhZyA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgQ3RvcjtcbiAgICBucyA9IGNvbmZpZy5nZXRUYWdOYW1lc3BhY2UodGFnKTtcbiAgICBpZiAoY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgICAgLy8gcGxhdGZvcm0gYnVpbHQtaW4gZWxlbWVudHNcbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICBjb25maWcucGFyc2VQbGF0Zm9ybVRhZ05hbWUodGFnKSwgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaXNEZWYoQ3RvciA9IHJlc29sdmVBc3NldChjb250ZXh0LiRvcHRpb25zLCAnY29tcG9uZW50cycsIHRhZykpKSB7XG4gICAgICAvLyBjb21wb25lbnRcbiAgICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KEN0b3IsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuLCB0YWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1bmtub3duIG9yIHVubGlzdGVkIG5hbWVzcGFjZWQgZWxlbWVudHNcbiAgICAgIC8vIGNoZWNrIGF0IHJ1bnRpbWUgYmVjYXVzZSBpdCBtYXkgZ2V0IGFzc2lnbmVkIGEgbmFtZXNwYWNlIHdoZW4gaXRzXG4gICAgICAvLyBwYXJlbnQgbm9ybWFsaXplcyBjaGlsZHJlblxuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgIHRhZywgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBkaXJlY3QgY29tcG9uZW50IG9wdGlvbnMgLyBjb25zdHJ1Y3RvclxuICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KHRhZywgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pO1xuICB9XG4gIGlmIChpc0RlZih2bm9kZSkpIHtcbiAgICBpZiAobnMpIHsgYXBwbHlOUyh2bm9kZSwgbnMpOyB9XG4gICAgcmV0dXJuIHZub2RlXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5TlMgKHZub2RlLCBucykge1xuICB2bm9kZS5ucyA9IG5zO1xuICBpZiAodm5vZGUudGFnID09PSAnZm9yZWlnbk9iamVjdCcpIHtcbiAgICAvLyB1c2UgZGVmYXVsdCBuYW1lc3BhY2UgaW5zaWRlIGZvcmVpZ25PYmplY3RcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoaXNEZWYodm5vZGUuY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IHZub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGlzRGVmKGNoaWxkLnRhZykgJiYgaXNVbmRlZihjaGlsZC5ucykpIHtcbiAgICAgICAgYXBwbHlOUyhjaGlsZCwgbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHYtZm9yIGxpc3RzLlxuICovXG5mdW5jdGlvbiByZW5kZXJMaXN0IChcbiAgdmFsLFxuICByZW5kZXJcbikge1xuICB2YXIgcmV0LCBpLCBsLCBrZXlzLCBrZXk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkgfHwgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgbCA9IHZhbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxbaV0sIGkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHJldCA9IG5ldyBBcnJheSh2YWwpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB2YWw7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVyKGkgKyAxLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIHJldCA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtrZXldLCBrZXksIGkpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNEZWYocmV0KSkge1xuICAgIChyZXQpLl9pc1ZMaXN0ID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgPHNsb3Q+XG4gKi9cbmZ1bmN0aW9uIHJlbmRlclNsb3QgKFxuICBuYW1lLFxuICBmYWxsYmFjayxcbiAgcHJvcHMsXG4gIGJpbmRPYmplY3Rcbikge1xuICB2YXIgc2NvcGVkU2xvdEZuID0gdGhpcy4kc2NvcGVkU2xvdHNbbmFtZV07XG4gIGlmIChzY29wZWRTbG90Rm4pIHsgLy8gc2NvcGVkIHNsb3RcbiAgICBwcm9wcyA9IHByb3BzIHx8IHt9O1xuICAgIGlmIChiaW5kT2JqZWN0KSB7XG4gICAgICBwcm9wcyA9IGV4dGVuZChleHRlbmQoe30sIGJpbmRPYmplY3QpLCBwcm9wcyk7XG4gICAgfVxuICAgIHJldHVybiBzY29wZWRTbG90Rm4ocHJvcHMpIHx8IGZhbGxiYWNrXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsb3ROb2RlcyA9IHRoaXMuJHNsb3RzW25hbWVdO1xuICAgIC8vIHdhcm4gZHVwbGljYXRlIHNsb3QgdXNhZ2VcbiAgICBpZiAoc2xvdE5vZGVzICYmIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBzbG90Tm9kZXMuX3JlbmRlcmVkICYmIHdhcm4oXG4gICAgICAgIFwiRHVwbGljYXRlIHByZXNlbmNlIG9mIHNsb3QgXFxcIlwiICsgbmFtZSArIFwiXFxcIiBmb3VuZCBpbiB0aGUgc2FtZSByZW5kZXIgdHJlZSBcIiArXG4gICAgICAgIFwiLSB0aGlzIHdpbGwgbGlrZWx5IGNhdXNlIHJlbmRlciBlcnJvcnMuXCIsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgICBzbG90Tm9kZXMuX3JlbmRlcmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHNsb3ROb2RlcyB8fCBmYWxsYmFja1xuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgZmlsdGVyc1xuICovXG5mdW5jdGlvbiByZXNvbHZlRmlsdGVyIChpZCkge1xuICByZXR1cm4gcmVzb2x2ZUFzc2V0KHRoaXMuJG9wdGlvbnMsICdmaWx0ZXJzJywgaWQsIHRydWUpIHx8IGlkZW50aXR5XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBjaGVja2luZyBrZXlDb2RlcyBmcm9tIGNvbmZpZy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tLZXlDb2RlcyAoXG4gIGV2ZW50S2V5Q29kZSxcbiAga2V5LFxuICBidWlsdEluQWxpYXNcbikge1xuICB2YXIga2V5Q29kZXMgPSBjb25maWcua2V5Q29kZXNba2V5XSB8fCBidWlsdEluQWxpYXM7XG4gIGlmIChBcnJheS5pc0FycmF5KGtleUNvZGVzKSkge1xuICAgIHJldHVybiBrZXlDb2Rlcy5pbmRleE9mKGV2ZW50S2V5Q29kZSkgPT09IC0xXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGtleUNvZGVzICE9PSBldmVudEtleUNvZGVcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgbWVyZ2luZyB2LWJpbmQ9XCJvYmplY3RcIiBpbnRvIGEgVk5vZGUncyBkYXRhLlxuICovXG5mdW5jdGlvbiBiaW5kT2JqZWN0UHJvcHMgKFxuICBkYXRhLFxuICB0YWcsXG4gIHZhbHVlLFxuICBhc1Byb3AsXG4gIGlzU3luY1xuKSB7XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAndi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3Qgb3IgQXJyYXkgdmFsdWUnLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB0b09iamVjdCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICB2YXIgaGFzaDtcbiAgICAgIHZhciBsb29wID0gZnVuY3Rpb24gKCBrZXkgKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBrZXkgPT09ICdjbGFzcycgfHxcbiAgICAgICAgICBrZXkgPT09ICdzdHlsZScgfHxcbiAgICAgICAgICBpc1Jlc2VydmVkQXR0cmlidXRlKGtleSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgaGFzaCA9IGRhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMudHlwZTtcbiAgICAgICAgICBoYXNoID0gYXNQcm9wIHx8IGNvbmZpZy5tdXN0VXNlUHJvcCh0YWcsIHR5cGUsIGtleSlcbiAgICAgICAgICAgID8gZGF0YS5kb21Qcm9wcyB8fCAoZGF0YS5kb21Qcm9wcyA9IHt9KVxuICAgICAgICAgICAgOiBkYXRhLmF0dHJzIHx8IChkYXRhLmF0dHJzID0ge30pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGtleSBpbiBoYXNoKSkge1xuICAgICAgICAgIGhhc2hba2V5XSA9IHZhbHVlW2tleV07XG5cbiAgICAgICAgICBpZiAoaXNTeW5jKSB7XG4gICAgICAgICAgICB2YXIgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xuICAgICAgICAgICAgb25bKFwidXBkYXRlOlwiICsga2V5KV0gPSBmdW5jdGlvbiAoJGV2ZW50KSB7XG4gICAgICAgICAgICAgIHZhbHVlW2tleV0gPSAkZXZlbnQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSBsb29wKCBrZXkgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyBzdGF0aWMgdHJlZXMuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlclN0YXRpYyAoXG4gIGluZGV4LFxuICBpc0luRm9yXG4pIHtcbiAgdmFyIHRyZWUgPSB0aGlzLl9zdGF0aWNUcmVlc1tpbmRleF07XG4gIC8vIGlmIGhhcyBhbHJlYWR5LXJlbmRlcmVkIHN0YXRpYyB0cmVlIGFuZCBub3QgaW5zaWRlIHYtZm9yLFxuICAvLyB3ZSBjYW4gcmV1c2UgdGhlIHNhbWUgdHJlZSBieSBkb2luZyBhIHNoYWxsb3cgY2xvbmUuXG4gIGlmICh0cmVlICYmICFpc0luRm9yKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodHJlZSlcbiAgICAgID8gY2xvbmVWTm9kZXModHJlZSlcbiAgICAgIDogY2xvbmVWTm9kZSh0cmVlKVxuICB9XG4gIC8vIG90aGVyd2lzZSwgcmVuZGVyIGEgZnJlc2ggdHJlZS5cbiAgdHJlZSA9IHRoaXMuX3N0YXRpY1RyZWVzW2luZGV4XSA9XG4gICAgdGhpcy4kb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnNbaW5kZXhdLmNhbGwodGhpcy5fcmVuZGVyUHJveHkpO1xuICBtYXJrU3RhdGljKHRyZWUsIChcIl9fc3RhdGljX19cIiArIGluZGV4KSwgZmFsc2UpO1xuICByZXR1cm4gdHJlZVxufVxuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciB2LW9uY2UuXG4gKiBFZmZlY3RpdmVseSBpdCBtZWFucyBtYXJraW5nIHRoZSBub2RlIGFzIHN0YXRpYyB3aXRoIGEgdW5pcXVlIGtleS5cbiAqL1xuZnVuY3Rpb24gbWFya09uY2UgKFxuICB0cmVlLFxuICBpbmRleCxcbiAga2V5XG4pIHtcbiAgbWFya1N0YXRpYyh0cmVlLCAoXCJfX29uY2VfX1wiICsgaW5kZXggKyAoa2V5ID8gKFwiX1wiICsga2V5KSA6IFwiXCIpKSwgdHJ1ZSk7XG4gIHJldHVybiB0cmVlXG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWMgKFxuICB0cmVlLFxuICBrZXksXG4gIGlzT25jZVxuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRyZWUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodHJlZVtpXSAmJiB0eXBlb2YgdHJlZVtpXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgbWFya1N0YXRpY05vZGUodHJlZVtpXSwgKGtleSArIFwiX1wiICsgaSksIGlzT25jZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG1hcmtTdGF0aWNOb2RlKHRyZWUsIGtleSwgaXNPbmNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljTm9kZSAobm9kZSwga2V5LCBpc09uY2UpIHtcbiAgbm9kZS5pc1N0YXRpYyA9IHRydWU7XG4gIG5vZGUua2V5ID0ga2V5O1xuICBub2RlLmlzT25jZSA9IGlzT25jZTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGJpbmRPYmplY3RMaXN0ZW5lcnMgKGRhdGEsIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICd2LW9uIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3QgdmFsdWUnLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb24gPSBkYXRhLm9uID0gZGF0YS5vbiA/IGV4dGVuZCh7fSwgZGF0YS5vbikgOiB7fTtcbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICB2YXIgZXhpc3RpbmcgPSBvbltrZXldO1xuICAgICAgICB2YXIgb3VycyA9IHZhbHVlW2tleV07XG4gICAgICAgIG9uW2tleV0gPSBleGlzdGluZyA/IFtdLmNvbmNhdChvdXJzLCBleGlzdGluZykgOiBvdXJzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFJlbmRlciAodm0pIHtcbiAgdm0uX3Zub2RlID0gbnVsbDsgLy8gdGhlIHJvb3Qgb2YgdGhlIGNoaWxkIHRyZWVcbiAgdm0uX3N0YXRpY1RyZWVzID0gbnVsbDtcbiAgdmFyIHBhcmVudFZub2RlID0gdm0uJHZub2RlID0gdm0uJG9wdGlvbnMuX3BhcmVudFZub2RlOyAvLyB0aGUgcGxhY2Vob2xkZXIgbm9kZSBpbiBwYXJlbnQgdHJlZVxuICB2YXIgcmVuZGVyQ29udGV4dCA9IHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmNvbnRleHQ7XG4gIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyh2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4sIHJlbmRlckNvbnRleHQpO1xuICB2bS4kc2NvcGVkU2xvdHMgPSBlbXB0eU9iamVjdDtcbiAgLy8gYmluZCB0aGUgY3JlYXRlRWxlbWVudCBmbiB0byB0aGlzIGluc3RhbmNlXG4gIC8vIHNvIHRoYXQgd2UgZ2V0IHByb3BlciByZW5kZXIgY29udGV4dCBpbnNpZGUgaXQuXG4gIC8vIGFyZ3Mgb3JkZXI6IHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlLCBhbHdheXNOb3JtYWxpemVcbiAgLy8gaW50ZXJuYWwgdmVyc2lvbiBpcyB1c2VkIGJ5IHJlbmRlciBmdW5jdGlvbnMgY29tcGlsZWQgZnJvbSB0ZW1wbGF0ZXNcbiAgdm0uX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgZmFsc2UpOyB9O1xuICAvLyBub3JtYWxpemF0aW9uIGlzIGFsd2F5cyBhcHBsaWVkIGZvciB0aGUgcHVibGljIHZlcnNpb24sIHVzZWQgaW5cbiAgLy8gdXNlci13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMuXG4gIHZtLiRjcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIHRydWUpOyB9O1xuXG4gIC8vICRhdHRycyAmICRsaXN0ZW5lcnMgYXJlIGV4cG9zZWQgZm9yIGVhc2llciBIT0MgY3JlYXRpb24uXG4gIC8vIHRoZXkgbmVlZCB0byBiZSByZWFjdGl2ZSBzbyB0aGF0IEhPQ3MgdXNpbmcgdGhlbSBhcmUgYWx3YXlzIHVwZGF0ZWRcbiAgdmFyIHBhcmVudERhdGEgPSBwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5kYXRhO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICB7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sICckYXR0cnMnLCBwYXJlbnREYXRhICYmIHBhcmVudERhdGEuYXR0cnMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgJiYgd2FybihcIiRhdHRycyBpcyByZWFkb25seS5cIiwgdm0pO1xuICAgIH0sIHRydWUpO1xuICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCAnJGxpc3RlbmVycycsIHBhcmVudERhdGEgJiYgcGFyZW50RGF0YS5vbiwgZnVuY3Rpb24gKCkge1xuICAgICAgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCAmJiB3YXJuKFwiJGxpc3RlbmVycyBpcyByZWFkb25seS5cIiwgdm0pO1xuICAgIH0sIHRydWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlck1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS4kbmV4dFRpY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gbmV4dFRpY2soZm4sIHRoaXMpXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgdmFyIHJlZiA9IHZtLiRvcHRpb25zO1xuICAgIHZhciByZW5kZXIgPSByZWYucmVuZGVyO1xuICAgIHZhciBzdGF0aWNSZW5kZXJGbnMgPSByZWYuc3RhdGljUmVuZGVyRm5zO1xuICAgIHZhciBfcGFyZW50Vm5vZGUgPSByZWYuX3BhcmVudFZub2RlO1xuXG4gICAgaWYgKHZtLl9pc01vdW50ZWQpIHtcbiAgICAgIC8vIGNsb25lIHNsb3Qgbm9kZXMgb24gcmUtcmVuZGVyc1xuICAgICAgZm9yICh2YXIga2V5IGluIHZtLiRzbG90cykge1xuICAgICAgICB2bS4kc2xvdHNba2V5XSA9IGNsb25lVk5vZGVzKHZtLiRzbG90c1trZXldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2bS4kc2NvcGVkU2xvdHMgPSAoX3BhcmVudFZub2RlICYmIF9wYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzKSB8fCBlbXB0eU9iamVjdDtcblxuICAgIGlmIChzdGF0aWNSZW5kZXJGbnMgJiYgIXZtLl9zdGF0aWNUcmVlcykge1xuICAgICAgdm0uX3N0YXRpY1RyZWVzID0gW107XG4gICAgfVxuICAgIC8vIHNldCBwYXJlbnQgdm5vZGUuIHRoaXMgYWxsb3dzIHJlbmRlciBmdW5jdGlvbnMgdG8gaGF2ZSBhY2Nlc3NcbiAgICAvLyB0byB0aGUgZGF0YSBvbiB0aGUgcGxhY2Vob2xkZXIgbm9kZS5cbiAgICB2bS4kdm5vZGUgPSBfcGFyZW50Vm5vZGU7XG4gICAgLy8gcmVuZGVyIHNlbGZcbiAgICB2YXIgdm5vZGU7XG4gICAgdHJ5IHtcbiAgICAgIHZub2RlID0gcmVuZGVyLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwicmVuZGVyIGZ1bmN0aW9uXCIpO1xuICAgICAgLy8gcmV0dXJuIGVycm9yIHJlbmRlciByZXN1bHQsXG4gICAgICAvLyBvciBwcmV2aW91cyB2bm9kZSB0byBwcmV2ZW50IHJlbmRlciBlcnJvciBjYXVzaW5nIGJsYW5rIGNvbXBvbmVudFxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIHtcbiAgICAgICAgdm5vZGUgPSB2bS4kb3B0aW9ucy5yZW5kZXJFcnJvclxuICAgICAgICAgID8gdm0uJG9wdGlvbnMucmVuZGVyRXJyb3IuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50LCBlKVxuICAgICAgICAgIDogdm0uX3Zub2RlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyByZXR1cm4gZW1wdHkgdm5vZGUgaW4gY2FzZSB0aGUgcmVuZGVyIGZ1bmN0aW9uIGVycm9yZWQgb3V0XG4gICAgaWYgKCEodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkpIHtcbiAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdNdWx0aXBsZSByb290IG5vZGVzIHJldHVybmVkIGZyb20gcmVuZGVyIGZ1bmN0aW9uLiBSZW5kZXIgZnVuY3Rpb24gJyArXG4gICAgICAgICAgJ3Nob3VsZCByZXR1cm4gYSBzaW5nbGUgcm9vdCBub2RlLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICAgIH1cbiAgICAvLyBzZXQgcGFyZW50XG4gICAgdm5vZGUucGFyZW50ID0gX3BhcmVudFZub2RlO1xuICAgIHJldHVybiB2bm9kZVxuICB9O1xuXG4gIC8vIGludGVybmFsIHJlbmRlciBoZWxwZXJzLlxuICAvLyB0aGVzZSBhcmUgZXhwb3NlZCBvbiB0aGUgaW5zdGFuY2UgcHJvdG90eXBlIHRvIHJlZHVjZSBnZW5lcmF0ZWQgcmVuZGVyXG4gIC8vIGNvZGUgc2l6ZS5cbiAgVnVlLnByb3RvdHlwZS5fbyA9IG1hcmtPbmNlO1xuICBWdWUucHJvdG90eXBlLl9uID0gdG9OdW1iZXI7XG4gIFZ1ZS5wcm90b3R5cGUuX3MgPSB0b1N0cmluZztcbiAgVnVlLnByb3RvdHlwZS5fbCA9IHJlbmRlckxpc3Q7XG4gIFZ1ZS5wcm90b3R5cGUuX3QgPSByZW5kZXJTbG90O1xuICBWdWUucHJvdG90eXBlLl9xID0gbG9vc2VFcXVhbDtcbiAgVnVlLnByb3RvdHlwZS5faSA9IGxvb3NlSW5kZXhPZjtcbiAgVnVlLnByb3RvdHlwZS5fbSA9IHJlbmRlclN0YXRpYztcbiAgVnVlLnByb3RvdHlwZS5fZiA9IHJlc29sdmVGaWx0ZXI7XG4gIFZ1ZS5wcm90b3R5cGUuX2sgPSBjaGVja0tleUNvZGVzO1xuICBWdWUucHJvdG90eXBlLl9iID0gYmluZE9iamVjdFByb3BzO1xuICBWdWUucHJvdG90eXBlLl92ID0gY3JlYXRlVGV4dFZOb2RlO1xuICBWdWUucHJvdG90eXBlLl9lID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgVnVlLnByb3RvdHlwZS5fdSA9IHJlc29sdmVTY29wZWRTbG90cztcbiAgVnVlLnByb3RvdHlwZS5fZyA9IGJpbmRPYmplY3RMaXN0ZW5lcnM7XG59XG5cbi8qICAqL1xuXG52YXIgdWlkJDEgPSAwO1xuXG5mdW5jdGlvbiBpbml0TWl4aW4gKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIGEgdWlkXG4gICAgdm0uX3VpZCA9IHVpZCQxKys7XG5cbiAgICB2YXIgc3RhcnRUYWcsIGVuZFRhZztcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1pbml0OlwiICsgKHZtLl91aWQpO1xuICAgICAgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyAodm0uX3VpZCk7XG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICB9XG5cbiAgICAvLyBhIGZsYWcgdG8gYXZvaWQgdGhpcyBiZWluZyBvYnNlcnZlZFxuICAgIHZtLl9pc1Z1ZSA9IHRydWU7XG4gICAgLy8gbWVyZ2Ugb3B0aW9uc1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuX2lzQ29tcG9uZW50KSB7XG4gICAgICAvLyBvcHRpbWl6ZSBpbnRlcm5hbCBjb21wb25lbnQgaW5zdGFudGlhdGlvblxuICAgICAgLy8gc2luY2UgZHluYW1pYyBvcHRpb25zIG1lcmdpbmcgaXMgcHJldHR5IHNsb3csIGFuZCBub25lIG9mIHRoZVxuICAgICAgLy8gaW50ZXJuYWwgY29tcG9uZW50IG9wdGlvbnMgbmVlZHMgc3BlY2lhbCB0cmVhdG1lbnQuXG4gICAgICBpbml0SW50ZXJuYWxDb21wb25lbnQodm0sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS4kb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcbiAgICAgICAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyh2bS5jb25zdHJ1Y3RvciksXG4gICAgICAgIG9wdGlvbnMgfHwge30sXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIHtcbiAgICAgIGluaXRQcm94eSh2bSk7XG4gICAgfVxuICAgIC8vIGV4cG9zZSByZWFsIHNlbGZcbiAgICB2bS5fc2VsZiA9IHZtO1xuICAgIGluaXRMaWZlY3ljbGUodm0pO1xuICAgIGluaXRFdmVudHModm0pO1xuICAgIGluaXRSZW5kZXIodm0pO1xuICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlQ3JlYXRlJyk7XG4gICAgaW5pdEluamVjdGlvbnModm0pOyAvLyByZXNvbHZlIGluamVjdGlvbnMgYmVmb3JlIGRhdGEvcHJvcHNcbiAgICBpbml0U3RhdGUodm0pO1xuICAgIGluaXRQcm92aWRlKHZtKTsgLy8gcmVzb2x2ZSBwcm92aWRlIGFmdGVyIGRhdGEvcHJvcHNcbiAgICBjYWxsSG9vayh2bSwgJ2NyZWF0ZWQnKTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgdm0uX25hbWUgPSBmb3JtYXRDb21wb25lbnROYW1lKHZtLCBmYWxzZSk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKCgodm0uX25hbWUpICsgXCIgaW5pdFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgfVxuXG4gICAgaWYgKHZtLiRvcHRpb25zLmVsKSB7XG4gICAgICB2bS4kbW91bnQodm0uJG9wdGlvbnMuZWwpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdEludGVybmFsQ29tcG9uZW50ICh2bSwgb3B0aW9ucykge1xuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh2bS5jb25zdHJ1Y3Rvci5vcHRpb25zKTtcbiAgLy8gZG9pbmcgdGhpcyBiZWNhdXNlIGl0J3MgZmFzdGVyIHRoYW4gZHluYW1pYyBlbnVtZXJhdGlvbi5cbiAgb3B0cy5wYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgb3B0cy5wcm9wc0RhdGEgPSBvcHRpb25zLnByb3BzRGF0YTtcbiAgb3B0cy5fcGFyZW50Vm5vZGUgPSBvcHRpb25zLl9wYXJlbnRWbm9kZTtcbiAgb3B0cy5fcGFyZW50TGlzdGVuZXJzID0gb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBvcHRzLl9yZW5kZXJDaGlsZHJlbiA9IG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuO1xuICBvcHRzLl9jb21wb25lbnRUYWcgPSBvcHRpb25zLl9jb21wb25lbnRUYWc7XG4gIG9wdHMuX3BhcmVudEVsbSA9IG9wdGlvbnMuX3BhcmVudEVsbTtcbiAgb3B0cy5fcmVmRWxtID0gb3B0aW9ucy5fcmVmRWxtO1xuICBpZiAob3B0aW9ucy5yZW5kZXIpIHtcbiAgICBvcHRzLnJlbmRlciA9IG9wdGlvbnMucmVuZGVyO1xuICAgIG9wdHMuc3RhdGljUmVuZGVyRm5zID0gb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnM7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyAoQ3Rvcikge1xuICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgaWYgKEN0b3Iuc3VwZXIpIHtcbiAgICB2YXIgc3VwZXJPcHRpb25zID0gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yLnN1cGVyKTtcbiAgICB2YXIgY2FjaGVkU3VwZXJPcHRpb25zID0gQ3Rvci5zdXBlck9wdGlvbnM7XG4gICAgaWYgKHN1cGVyT3B0aW9ucyAhPT0gY2FjaGVkU3VwZXJPcHRpb25zKSB7XG4gICAgICAvLyBzdXBlciBvcHRpb24gY2hhbmdlZCxcbiAgICAgIC8vIG5lZWQgdG8gcmVzb2x2ZSBuZXcgb3B0aW9ucy5cbiAgICAgIEN0b3Iuc3VwZXJPcHRpb25zID0gc3VwZXJPcHRpb25zO1xuICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgYXJlIGFueSBsYXRlLW1vZGlmaWVkL2F0dGFjaGVkIG9wdGlvbnMgKCM0OTc2KVxuICAgICAgdmFyIG1vZGlmaWVkT3B0aW9ucyA9IHJlc29sdmVNb2RpZmllZE9wdGlvbnMoQ3Rvcik7XG4gICAgICAvLyB1cGRhdGUgYmFzZSBleHRlbmQgb3B0aW9uc1xuICAgICAgaWYgKG1vZGlmaWVkT3B0aW9ucykge1xuICAgICAgICBleHRlbmQoQ3Rvci5leHRlbmRPcHRpb25zLCBtb2RpZmllZE9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhzdXBlck9wdGlvbnMsIEN0b3IuZXh0ZW5kT3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy5uYW1lKSB7XG4gICAgICAgIG9wdGlvbnMuY29tcG9uZW50c1tvcHRpb25zLm5hbWVdID0gQ3RvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyAoQ3Rvcikge1xuICB2YXIgbW9kaWZpZWQ7XG4gIHZhciBsYXRlc3QgPSBDdG9yLm9wdGlvbnM7XG4gIHZhciBleHRlbmRlZCA9IEN0b3IuZXh0ZW5kT3B0aW9ucztcbiAgdmFyIHNlYWxlZCA9IEN0b3Iuc2VhbGVkT3B0aW9ucztcbiAgZm9yICh2YXIga2V5IGluIGxhdGVzdCkge1xuICAgIGlmIChsYXRlc3Rba2V5XSAhPT0gc2VhbGVkW2tleV0pIHtcbiAgICAgIGlmICghbW9kaWZpZWQpIHsgbW9kaWZpZWQgPSB7fTsgfVxuICAgICAgbW9kaWZpZWRba2V5XSA9IGRlZHVwZShsYXRlc3Rba2V5XSwgZXh0ZW5kZWRba2V5XSwgc2VhbGVkW2tleV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbW9kaWZpZWRcbn1cblxuZnVuY3Rpb24gZGVkdXBlIChsYXRlc3QsIGV4dGVuZGVkLCBzZWFsZWQpIHtcbiAgLy8gY29tcGFyZSBsYXRlc3QgYW5kIHNlYWxlZCB0byBlbnN1cmUgbGlmZWN5Y2xlIGhvb2tzIHdvbid0IGJlIGR1cGxpY2F0ZWRcbiAgLy8gYmV0d2VlbiBtZXJnZXNcbiAgaWYgKEFycmF5LmlzQXJyYXkobGF0ZXN0KSkge1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBzZWFsZWQgPSBBcnJheS5pc0FycmF5KHNlYWxlZCkgPyBzZWFsZWQgOiBbc2VhbGVkXTtcbiAgICBleHRlbmRlZCA9IEFycmF5LmlzQXJyYXkoZXh0ZW5kZWQpID8gZXh0ZW5kZWQgOiBbZXh0ZW5kZWRdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF0ZXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBwdXNoIG9yaWdpbmFsIG9wdGlvbnMgYW5kIG5vdCBzZWFsZWQgb3B0aW9ucyB0byBleGNsdWRlIGR1cGxpY2F0ZWQgb3B0aW9uc1xuICAgICAgaWYgKGV4dGVuZGVkLmluZGV4T2YobGF0ZXN0W2ldKSA+PSAwIHx8IHNlYWxlZC5pbmRleE9mKGxhdGVzdFtpXSkgPCAwKSB7XG4gICAgICAgIHJlcy5wdXNoKGxhdGVzdFtpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGF0ZXN0XG4gIH1cbn1cblxuZnVuY3Rpb24gVnVlJDMgKG9wdGlvbnMpIHtcbiAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgISh0aGlzIGluc3RhbmNlb2YgVnVlJDMpXG4gICkge1xuICAgIHdhcm4oJ1Z1ZSBpcyBhIGNvbnN0cnVjdG9yIGFuZCBzaG91bGQgYmUgY2FsbGVkIHdpdGggdGhlIGBuZXdgIGtleXdvcmQnKTtcbiAgfVxuICB0aGlzLl9pbml0KG9wdGlvbnMpO1xufVxuXG5pbml0TWl4aW4oVnVlJDMpO1xuc3RhdGVNaXhpbihWdWUkMyk7XG5ldmVudHNNaXhpbihWdWUkMyk7XG5saWZlY3ljbGVNaXhpbihWdWUkMyk7XG5yZW5kZXJNaXhpbihWdWUkMyk7XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0VXNlIChWdWUpIHtcbiAgVnVlLnVzZSA9IGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICB2YXIgaW5zdGFsbGVkUGx1Z2lucyA9ICh0aGlzLl9pbnN0YWxsZWRQbHVnaW5zIHx8ICh0aGlzLl9pbnN0YWxsZWRQbHVnaW5zID0gW10pKTtcbiAgICBpZiAoaW5zdGFsbGVkUGx1Z2lucy5pbmRleE9mKHBsdWdpbikgPiAtMSkge1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvLyBhZGRpdGlvbmFsIHBhcmFtZXRlcnNcbiAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgaWYgKHR5cGVvZiBwbHVnaW4uaW5zdGFsbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGx1Z2luLmluc3RhbGwuYXBwbHkocGx1Z2luLCBhcmdzKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwbHVnaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9XG4gICAgaW5zdGFsbGVkUGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgcmV0dXJuIHRoaXNcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRNaXhpbiQxIChWdWUpIHtcbiAgVnVlLm1peGluID0gZnVuY3Rpb24gKG1peGluKSB7XG4gICAgdGhpcy5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHRoaXMub3B0aW9ucywgbWl4aW4pO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0RXh0ZW5kIChWdWUpIHtcbiAgLyoqXG4gICAqIEVhY2ggaW5zdGFuY2UgY29uc3RydWN0b3IsIGluY2x1ZGluZyBWdWUsIGhhcyBhIHVuaXF1ZVxuICAgKiBjaWQuIFRoaXMgZW5hYmxlcyB1cyB0byBjcmVhdGUgd3JhcHBlZCBcImNoaWxkXG4gICAqIGNvbnN0cnVjdG9yc1wiIGZvciBwcm90b3R5cGFsIGluaGVyaXRhbmNlIGFuZCBjYWNoZSB0aGVtLlxuICAgKi9cbiAgVnVlLmNpZCA9IDA7XG4gIHZhciBjaWQgPSAxO1xuXG4gIC8qKlxuICAgKiBDbGFzcyBpbmhlcml0YW5jZVxuICAgKi9cbiAgVnVlLmV4dGVuZCA9IGZ1bmN0aW9uIChleHRlbmRPcHRpb25zKSB7XG4gICAgZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnMgfHwge307XG4gICAgdmFyIFN1cGVyID0gdGhpcztcbiAgICB2YXIgU3VwZXJJZCA9IFN1cGVyLmNpZDtcbiAgICB2YXIgY2FjaGVkQ3RvcnMgPSBleHRlbmRPcHRpb25zLl9DdG9yIHx8IChleHRlbmRPcHRpb25zLl9DdG9yID0ge30pO1xuICAgIGlmIChjYWNoZWRDdG9yc1tTdXBlcklkXSkge1xuICAgICAgcmV0dXJuIGNhY2hlZEN0b3JzW1N1cGVySWRdXG4gICAgfVxuXG4gICAgdmFyIG5hbWUgPSBleHRlbmRPcHRpb25zLm5hbWUgfHwgU3VwZXIub3B0aW9ucy5uYW1lO1xuICAgIHtcbiAgICAgIGlmICghL15bYS16QS1aXVtcXHctXSokLy50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ0ludmFsaWQgY29tcG9uZW50IG5hbWU6IFwiJyArIG5hbWUgKyAnXCIuIENvbXBvbmVudCBuYW1lcyAnICtcbiAgICAgICAgICAnY2FuIG9ubHkgY29udGFpbiBhbHBoYW51bWVyaWMgY2hhcmFjdGVycyBhbmQgdGhlIGh5cGhlbiwgJyArXG4gICAgICAgICAgJ2FuZCBtdXN0IHN0YXJ0IHdpdGggYSBsZXR0ZXIuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBTdWIgPSBmdW5jdGlvbiBWdWVDb21wb25lbnQgKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX2luaXQob3B0aW9ucyk7XG4gICAgfTtcbiAgICBTdWIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdXBlci5wcm90b3R5cGUpO1xuICAgIFN1Yi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdWI7XG4gICAgU3ViLmNpZCA9IGNpZCsrO1xuICAgIFN1Yi5vcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgU3VwZXIub3B0aW9ucyxcbiAgICAgIGV4dGVuZE9wdGlvbnNcbiAgICApO1xuICAgIFN1Ylsnc3VwZXInXSA9IFN1cGVyO1xuXG4gICAgLy8gRm9yIHByb3BzIGFuZCBjb21wdXRlZCBwcm9wZXJ0aWVzLCB3ZSBkZWZpbmUgdGhlIHByb3h5IGdldHRlcnMgb25cbiAgICAvLyB0aGUgVnVlIGluc3RhbmNlcyBhdCBleHRlbnNpb24gdGltZSwgb24gdGhlIGV4dGVuZGVkIHByb3RvdHlwZS4gVGhpc1xuICAgIC8vIGF2b2lkcyBPYmplY3QuZGVmaW5lUHJvcGVydHkgY2FsbHMgZm9yIGVhY2ggaW5zdGFuY2UgY3JlYXRlZC5cbiAgICBpZiAoU3ViLm9wdGlvbnMucHJvcHMpIHtcbiAgICAgIGluaXRQcm9wcyQxKFN1Yik7XG4gICAgfVxuICAgIGlmIChTdWIub3B0aW9ucy5jb21wdXRlZCkge1xuICAgICAgaW5pdENvbXB1dGVkJDEoU3ViKTtcbiAgICB9XG5cbiAgICAvLyBhbGxvdyBmdXJ0aGVyIGV4dGVuc2lvbi9taXhpbi9wbHVnaW4gdXNhZ2VcbiAgICBTdWIuZXh0ZW5kID0gU3VwZXIuZXh0ZW5kO1xuICAgIFN1Yi5taXhpbiA9IFN1cGVyLm1peGluO1xuICAgIFN1Yi51c2UgPSBTdXBlci51c2U7XG5cbiAgICAvLyBjcmVhdGUgYXNzZXQgcmVnaXN0ZXJzLCBzbyBleHRlbmRlZCBjbGFzc2VzXG4gICAgLy8gY2FuIGhhdmUgdGhlaXIgcHJpdmF0ZSBhc3NldHMgdG9vLlxuICAgIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIFN1Ylt0eXBlXSA9IFN1cGVyW3R5cGVdO1xuICAgIH0pO1xuICAgIC8vIGVuYWJsZSByZWN1cnNpdmUgc2VsZi1sb29rdXBcbiAgICBpZiAobmFtZSkge1xuICAgICAgU3ViLm9wdGlvbnMuY29tcG9uZW50c1tuYW1lXSA9IFN1YjtcbiAgICB9XG5cbiAgICAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBzdXBlciBvcHRpb25zIGF0IGV4dGVuc2lvbiB0aW1lLlxuICAgIC8vIGxhdGVyIGF0IGluc3RhbnRpYXRpb24gd2UgY2FuIGNoZWNrIGlmIFN1cGVyJ3Mgb3B0aW9ucyBoYXZlXG4gICAgLy8gYmVlbiB1cGRhdGVkLlxuICAgIFN1Yi5zdXBlck9wdGlvbnMgPSBTdXBlci5vcHRpb25zO1xuICAgIFN1Yi5leHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucztcbiAgICBTdWIuc2VhbGVkT3B0aW9ucyA9IGV4dGVuZCh7fSwgU3ViLm9wdGlvbnMpO1xuXG4gICAgLy8gY2FjaGUgY29uc3RydWN0b3JcbiAgICBjYWNoZWRDdG9yc1tTdXBlcklkXSA9IFN1YjtcbiAgICByZXR1cm4gU3ViXG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyQxIChDb21wKSB7XG4gIHZhciBwcm9wcyA9IENvbXAub3B0aW9ucy5wcm9wcztcbiAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgcHJveHkoQ29tcC5wcm90b3R5cGUsIFwiX3Byb3BzXCIsIGtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdENvbXB1dGVkJDEgKENvbXApIHtcbiAgdmFyIGNvbXB1dGVkID0gQ29tcC5vcHRpb25zLmNvbXB1dGVkO1xuICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICBkZWZpbmVDb21wdXRlZChDb21wLnByb3RvdHlwZSwga2V5LCBjb21wdXRlZFtrZXldKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEFzc2V0UmVnaXN0ZXJzIChWdWUpIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhc3NldCByZWdpc3RyYXRpb24gbWV0aG9kcy5cbiAgICovXG4gIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBWdWVbdHlwZV0gPSBmdW5jdGlvbiAoXG4gICAgICBpZCxcbiAgICAgIGRlZmluaXRpb25cbiAgICApIHtcbiAgICAgIGlmICghZGVmaW5pdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgY29uZmlnLmlzUmVzZXJ2ZWRUYWcoaWQpKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAnRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCAnICtcbiAgICAgICAgICAgICAgJ2lkOiAnICsgaWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiBpc1BsYWluT2JqZWN0KGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbi5uYW1lID0gZGVmaW5pdGlvbi5uYW1lIHx8IGlkO1xuICAgICAgICAgIGRlZmluaXRpb24gPSB0aGlzLm9wdGlvbnMuX2Jhc2UuZXh0ZW5kKGRlZmluaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnZGlyZWN0aXZlJyAmJiB0eXBlb2YgZGVmaW5pdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGRlZmluaXRpb24gPSB7IGJpbmQ6IGRlZmluaXRpb24sIHVwZGF0ZTogZGVmaW5pdGlvbiB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF0gPSBkZWZpbml0aW9uO1xuICAgICAgICByZXR1cm4gZGVmaW5pdGlvblxuICAgICAgfVxuICAgIH07XG4gIH0pO1xufVxuXG4vKiAgKi9cblxudmFyIHBhdHRlcm5UeXBlcyA9IFtTdHJpbmcsIFJlZ0V4cCwgQXJyYXldO1xuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lIChvcHRzKSB7XG4gIHJldHVybiBvcHRzICYmIChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnKVxufVxuXG5mdW5jdGlvbiBtYXRjaGVzIChwYXR0ZXJuLCBuYW1lKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uaW5kZXhPZihuYW1lKSA+IC0xXG4gIH0gZWxzZSBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uc3BsaXQoJywnKS5pbmRleE9mKG5hbWUpID4gLTFcbiAgfSBlbHNlIGlmIChpc1JlZ0V4cChwYXR0ZXJuKSkge1xuICAgIHJldHVybiBwYXR0ZXJuLnRlc3QobmFtZSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gcHJ1bmVDYWNoZSAoY2FjaGUsIGN1cnJlbnQsIGZpbHRlcikge1xuICBmb3IgKHZhciBrZXkgaW4gY2FjaGUpIHtcbiAgICB2YXIgY2FjaGVkTm9kZSA9IGNhY2hlW2tleV07XG4gICAgaWYgKGNhY2hlZE5vZGUpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjYWNoZWROb2RlLmNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgaWYgKG5hbWUgJiYgIWZpbHRlcihuYW1lKSkge1xuICAgICAgICBpZiAoY2FjaGVkTm9kZSAhPT0gY3VycmVudCkge1xuICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShjYWNoZWROb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBjYWNoZVtrZXldID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJ1bmVDYWNoZUVudHJ5ICh2bm9kZSkge1xuICBpZiAodm5vZGUpIHtcbiAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xuICB9XG59XG5cbnZhciBLZWVwQWxpdmUgPSB7XG4gIG5hbWU6ICdrZWVwLWFsaXZlJyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcHJvcHM6IHtcbiAgICBpbmNsdWRlOiBwYXR0ZXJuVHlwZXMsXG4gICAgZXhjbHVkZTogcGF0dGVyblR5cGVzXG4gIH0sXG5cbiAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCAoKSB7XG4gICAgdGhpcy5jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH0sXG5cbiAgZGVzdHJveWVkOiBmdW5jdGlvbiBkZXN0cm95ZWQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMkMS5jYWNoZSkge1xuICAgICAgcHJ1bmVDYWNoZUVudHJ5KHRoaXMkMS5jYWNoZVtrZXldKTtcbiAgICB9XG4gIH0sXG5cbiAgd2F0Y2g6IHtcbiAgICBpbmNsdWRlOiBmdW5jdGlvbiBpbmNsdWRlICh2YWwpIHtcbiAgICAgIHBydW5lQ2FjaGUodGhpcy5jYWNoZSwgdGhpcy5fdm5vZGUsIGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xuICAgIH0sXG4gICAgZXhjbHVkZTogZnVuY3Rpb24gZXhjbHVkZSAodmFsKSB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMuY2FjaGUsIHRoaXMuX3Zub2RlLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gIW1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgfVxuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyICgpIHtcbiAgICB2YXIgdm5vZGUgPSBnZXRGaXJzdENvbXBvbmVudENoaWxkKHRoaXMuJHNsb3RzLmRlZmF1bHQpO1xuICAgIHZhciBjb21wb25lbnRPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICBpZiAoY29tcG9uZW50T3B0aW9ucykge1xuICAgICAgLy8gY2hlY2sgcGF0dGVyblxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgaWYgKG5hbWUgJiYgKFxuICAgICAgICAodGhpcy5pbmNsdWRlICYmICFtYXRjaGVzKHRoaXMuaW5jbHVkZSwgbmFtZSkpIHx8XG4gICAgICAgICh0aGlzLmV4Y2x1ZGUgJiYgbWF0Y2hlcyh0aGlzLmV4Y2x1ZGUsIG5hbWUpKVxuICAgICAgKSkge1xuICAgICAgICByZXR1cm4gdm5vZGVcbiAgICAgIH1cbiAgICAgIHZhciBrZXkgPSB2bm9kZS5rZXkgPT0gbnVsbFxuICAgICAgICAvLyBzYW1lIGNvbnN0cnVjdG9yIG1heSBnZXQgcmVnaXN0ZXJlZCBhcyBkaWZmZXJlbnQgbG9jYWwgY29tcG9uZW50c1xuICAgICAgICAvLyBzbyBjaWQgYWxvbmUgaXMgbm90IGVub3VnaCAoIzMyNjkpXG4gICAgICAgID8gY29tcG9uZW50T3B0aW9ucy5DdG9yLmNpZCArIChjb21wb25lbnRPcHRpb25zLnRhZyA/IChcIjo6XCIgKyAoY29tcG9uZW50T3B0aW9ucy50YWcpKSA6ICcnKVxuICAgICAgICA6IHZub2RlLmtleTtcbiAgICAgIGlmICh0aGlzLmNhY2hlW2tleV0pIHtcbiAgICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSB0aGlzLmNhY2hlW2tleV0uY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNhY2hlW2tleV0gPSB2bm9kZTtcbiAgICAgIH1cbiAgICAgIHZub2RlLmRhdGEua2VlcEFsaXZlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZub2RlXG4gIH1cbn07XG5cbnZhciBidWlsdEluQ29tcG9uZW50cyA9IHtcbiAgS2VlcEFsaXZlOiBLZWVwQWxpdmVcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0R2xvYmFsQVBJIChWdWUpIHtcbiAgLy8gY29uZmlnXG4gIHZhciBjb25maWdEZWYgPSB7fTtcbiAgY29uZmlnRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbmZpZzsgfTtcbiAge1xuICAgIGNvbmZpZ0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnRG8gbm90IHJlcGxhY2UgdGhlIFZ1ZS5jb25maWcgb2JqZWN0LCBzZXQgaW5kaXZpZHVhbCBmaWVsZHMgaW5zdGVhZC4nXG4gICAgICApO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSwgJ2NvbmZpZycsIGNvbmZpZ0RlZik7XG5cbiAgLy8gZXhwb3NlZCB1dGlsIG1ldGhvZHMuXG4gIC8vIE5PVEU6IHRoZXNlIGFyZSBub3QgY29uc2lkZXJlZCBwYXJ0IG9mIHRoZSBwdWJsaWMgQVBJIC0gYXZvaWQgcmVseWluZyBvblxuICAvLyB0aGVtIHVubGVzcyB5b3UgYXJlIGF3YXJlIG9mIHRoZSByaXNrLlxuICBWdWUudXRpbCA9IHtcbiAgICB3YXJuOiB3YXJuLFxuICAgIGV4dGVuZDogZXh0ZW5kLFxuICAgIG1lcmdlT3B0aW9uczogbWVyZ2VPcHRpb25zLFxuICAgIGRlZmluZVJlYWN0aXZlOiBkZWZpbmVSZWFjdGl2ZSQkMVxuICB9O1xuXG4gIFZ1ZS5zZXQgPSBzZXQ7XG4gIFZ1ZS5kZWxldGUgPSBkZWw7XG4gIFZ1ZS5uZXh0VGljayA9IG5leHRUaWNrO1xuXG4gIFZ1ZS5vcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIFZ1ZS5vcHRpb25zW3R5cGUgKyAncyddID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfSk7XG5cbiAgLy8gdGhpcyBpcyB1c2VkIHRvIGlkZW50aWZ5IHRoZSBcImJhc2VcIiBjb25zdHJ1Y3RvciB0byBleHRlbmQgYWxsIHBsYWluLW9iamVjdFxuICAvLyBjb21wb25lbnRzIHdpdGggaW4gV2VleCdzIG11bHRpLWluc3RhbmNlIHNjZW5hcmlvcy5cbiAgVnVlLm9wdGlvbnMuX2Jhc2UgPSBWdWU7XG5cbiAgZXh0ZW5kKFZ1ZS5vcHRpb25zLmNvbXBvbmVudHMsIGJ1aWx0SW5Db21wb25lbnRzKTtcblxuICBpbml0VXNlKFZ1ZSk7XG4gIGluaXRNaXhpbiQxKFZ1ZSk7XG4gIGluaXRFeHRlbmQoVnVlKTtcbiAgaW5pdEFzc2V0UmVnaXN0ZXJzKFZ1ZSk7XG59XG5cbmluaXRHbG9iYWxBUEkoVnVlJDMpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlJDMucHJvdG90eXBlLCAnJGlzU2VydmVyJywge1xuICBnZXQ6IGlzU2VydmVyUmVuZGVyaW5nXG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSQzLnByb3RvdHlwZSwgJyRzc3JDb250ZXh0Jywge1xuICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gdGhpcy4kdm5vZGUgJiYgdGhpcy4kdm5vZGUuc3NyQ29udGV4dFxuICB9XG59KTtcblxuVnVlJDMudmVyc2lvbiA9ICcyLjQuMSc7XG5cbi8qICAqL1xuXG4vLyB0aGVzZSBhcmUgcmVzZXJ2ZWQgZm9yIHdlYiBiZWNhdXNlIHRoZXkgYXJlIGRpcmVjdGx5IGNvbXBpbGVkIGF3YXlcbi8vIGR1cmluZyB0ZW1wbGF0ZSBjb21waWxhdGlvblxudmFyIGlzUmVzZXJ2ZWRBdHRyID0gbWFrZU1hcCgnc3R5bGUsY2xhc3MnKTtcblxuLy8gYXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSB1c2luZyBwcm9wcyBmb3IgYmluZGluZ1xudmFyIGFjY2VwdFZhbHVlID0gbWFrZU1hcCgnaW5wdXQsdGV4dGFyZWEsb3B0aW9uLHNlbGVjdCcpO1xudmFyIG11c3RVc2VQcm9wID0gZnVuY3Rpb24gKHRhZywgdHlwZSwgYXR0cikge1xuICByZXR1cm4gKFxuICAgIChhdHRyID09PSAndmFsdWUnICYmIGFjY2VwdFZhbHVlKHRhZykpICYmIHR5cGUgIT09ICdidXR0b24nIHx8XG4gICAgKGF0dHIgPT09ICdzZWxlY3RlZCcgJiYgdGFnID09PSAnb3B0aW9uJykgfHxcbiAgICAoYXR0ciA9PT0gJ2NoZWNrZWQnICYmIHRhZyA9PT0gJ2lucHV0JykgfHxcbiAgICAoYXR0ciA9PT0gJ211dGVkJyAmJiB0YWcgPT09ICd2aWRlbycpXG4gIClcbn07XG5cbnZhciBpc0VudW1lcmF0ZWRBdHRyID0gbWFrZU1hcCgnY29udGVudGVkaXRhYmxlLGRyYWdnYWJsZSxzcGVsbGNoZWNrJyk7XG5cbnZhciBpc0Jvb2xlYW5BdHRyID0gbWFrZU1hcChcbiAgJ2FsbG93ZnVsbHNjcmVlbixhc3luYyxhdXRvZm9jdXMsYXV0b3BsYXksY2hlY2tlZCxjb21wYWN0LGNvbnRyb2xzLGRlY2xhcmUsJyArXG4gICdkZWZhdWx0LGRlZmF1bHRjaGVja2VkLGRlZmF1bHRtdXRlZCxkZWZhdWx0c2VsZWN0ZWQsZGVmZXIsZGlzYWJsZWQsJyArXG4gICdlbmFibGVkLGZvcm1ub3ZhbGlkYXRlLGhpZGRlbixpbmRldGVybWluYXRlLGluZXJ0LGlzbWFwLGl0ZW1zY29wZSxsb29wLG11bHRpcGxlLCcgK1xuICAnbXV0ZWQsbm9ocmVmLG5vcmVzaXplLG5vc2hhZGUsbm92YWxpZGF0ZSxub3dyYXAsb3BlbixwYXVzZW9uZXhpdCxyZWFkb25seSwnICtcbiAgJ3JlcXVpcmVkLHJldmVyc2VkLHNjb3BlZCxzZWFtbGVzcyxzZWxlY3RlZCxzb3J0YWJsZSx0cmFuc2xhdGUsJyArXG4gICd0cnVlc3BlZWQsdHlwZW11c3RtYXRjaCx2aXNpYmxlJ1xuKTtcblxudmFyIHhsaW5rTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG5cbnZhciBpc1hsaW5rID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUuY2hhckF0KDUpID09PSAnOicgJiYgbmFtZS5zbGljZSgwLCA1KSA9PT0gJ3hsaW5rJ1xufTtcblxudmFyIGdldFhsaW5rUHJvcCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBpc1hsaW5rKG5hbWUpID8gbmFtZS5zbGljZSg2LCBuYW1lLmxlbmd0aCkgOiAnJ1xufTtcblxudmFyIGlzRmFsc3lBdHRyVmFsdWUgPSBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiB2YWwgPT0gbnVsbCB8fCB2YWwgPT09IGZhbHNlXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2VuQ2xhc3NGb3JWbm9kZSAodm5vZGUpIHtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xuICB2YXIgY2hpbGROb2RlID0gdm5vZGU7XG4gIHdoaWxlIChpc0RlZihjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICBpZiAoY2hpbGROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShjaGlsZE5vZGUuZGF0YSwgZGF0YSk7XG4gICAgfVxuICB9XG4gIHdoaWxlIChpc0RlZihwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUuZGF0YSkge1xuICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGRhdGEsIHBhcmVudE5vZGUuZGF0YSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZW5kZXJDbGFzcyhkYXRhLnN0YXRpY0NsYXNzLCBkYXRhLmNsYXNzKVxufVxuXG5mdW5jdGlvbiBtZXJnZUNsYXNzRGF0YSAoY2hpbGQsIHBhcmVudCkge1xuICByZXR1cm4ge1xuICAgIHN0YXRpY0NsYXNzOiBjb25jYXQoY2hpbGQuc3RhdGljQ2xhc3MsIHBhcmVudC5zdGF0aWNDbGFzcyksXG4gICAgY2xhc3M6IGlzRGVmKGNoaWxkLmNsYXNzKVxuICAgICAgPyBbY2hpbGQuY2xhc3MsIHBhcmVudC5jbGFzc11cbiAgICAgIDogcGFyZW50LmNsYXNzXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyQ2xhc3MgKFxuICBzdGF0aWNDbGFzcyxcbiAgZHluYW1pY0NsYXNzXG4pIHtcbiAgaWYgKGlzRGVmKHN0YXRpY0NsYXNzKSB8fCBpc0RlZihkeW5hbWljQ2xhc3MpKSB7XG4gICAgcmV0dXJuIGNvbmNhdChzdGF0aWNDbGFzcywgc3RyaW5naWZ5Q2xhc3MoZHluYW1pY0NsYXNzKSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gJydcbn1cblxuZnVuY3Rpb24gY29uY2F0IChhLCBiKSB7XG4gIHJldHVybiBhID8gYiA/IChhICsgJyAnICsgYikgOiBhIDogKGIgfHwgJycpXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUNsYXNzICh2YWx1ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5QXJyYXkodmFsdWUpXG4gIH1cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBzdHJpbmdpZnlPYmplY3QodmFsdWUpXG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gJydcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5QXJyYXkgKHZhbHVlKSB7XG4gIHZhciByZXMgPSAnJztcbiAgdmFyIHN0cmluZ2lmaWVkO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChpc0RlZihzdHJpbmdpZmllZCA9IHN0cmluZ2lmeUNsYXNzKHZhbHVlW2ldKSkgJiYgc3RyaW5naWZpZWQgIT09ICcnKSB7XG4gICAgICBpZiAocmVzKSB7IHJlcyArPSAnICc7IH1cbiAgICAgIHJlcyArPSBzdHJpbmdpZmllZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlPYmplY3QgKHZhbHVlKSB7XG4gIHZhciByZXMgPSAnJztcbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlW2tleV0pIHtcbiAgICAgIGlmIChyZXMpIHsgcmVzICs9ICcgJzsgfVxuICAgICAgcmVzICs9IGtleTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIG5hbWVzcGFjZU1hcCA9IHtcbiAgc3ZnOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuICBtYXRoOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCdcbn07XG5cbnZhciBpc0hUTUxUYWcgPSBtYWtlTWFwKFxuICAnaHRtbCxib2R5LGJhc2UsaGVhZCxsaW5rLG1ldGEsc3R5bGUsdGl0bGUsJyArXG4gICdhZGRyZXNzLGFydGljbGUsYXNpZGUsZm9vdGVyLGhlYWRlcixoMSxoMixoMyxoNCxoNSxoNixoZ3JvdXAsbmF2LHNlY3Rpb24sJyArXG4gICdkaXYsZGQsZGwsZHQsZmlnY2FwdGlvbixmaWd1cmUscGljdHVyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCwnICtcbiAgJ2EsYixhYmJyLGJkaSxiZG8sYnIsY2l0ZSxjb2RlLGRhdGEsZGZuLGVtLGksa2JkLG1hcmsscSxycCxydCxydGMscnVieSwnICtcbiAgJ3Msc2FtcCxzbWFsbCxzcGFuLHN0cm9uZyxzdWIsc3VwLHRpbWUsdSx2YXIsd2JyLGFyZWEsYXVkaW8sbWFwLHRyYWNrLHZpZGVvLCcgK1xuICAnZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSxjYW52YXMsc2NyaXB0LG5vc2NyaXB0LGRlbCxpbnMsJyArXG4gICdjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCx0aCx0ciwnICtcbiAgJ2J1dHRvbixkYXRhbGlzdCxmaWVsZHNldCxmb3JtLGlucHV0LGxhYmVsLGxlZ2VuZCxtZXRlcixvcHRncm91cCxvcHRpb24sJyArXG4gICdvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLCcgK1xuICAnZGV0YWlscyxkaWFsb2csbWVudSxtZW51aXRlbSxzdW1tYXJ5LCcgK1xuICAnY29udGVudCxlbGVtZW50LHNoYWRvdyx0ZW1wbGF0ZSxibG9ja3F1b3RlLGlmcmFtZSx0Zm9vdCdcbik7XG5cbi8vIHRoaXMgbWFwIGlzIGludGVudGlvbmFsbHkgc2VsZWN0aXZlLCBvbmx5IGNvdmVyaW5nIFNWRyBlbGVtZW50cyB0aGF0IG1heVxuLy8gY29udGFpbiBjaGlsZCBlbGVtZW50cy5cbnZhciBpc1NWRyA9IG1ha2VNYXAoXG4gICdzdmcsYW5pbWF0ZSxjaXJjbGUsY2xpcHBhdGgsY3Vyc29yLGRlZnMsZGVzYyxlbGxpcHNlLGZpbHRlcixmb250LWZhY2UsJyArXG4gICdmb3JlaWduT2JqZWN0LGcsZ2x5cGgsaW1hZ2UsbGluZSxtYXJrZXIsbWFzayxtaXNzaW5nLWdseXBoLHBhdGgscGF0dGVybiwnICtcbiAgJ3BvbHlnb24scG9seWxpbmUscmVjdCxzd2l0Y2gsc3ltYm9sLHRleHQsdGV4dHBhdGgsdHNwYW4sdXNlLHZpZXcnLFxuICB0cnVlXG4pO1xuXG52YXIgaXNQcmVUYWcgPSBmdW5jdGlvbiAodGFnKSB7IHJldHVybiB0YWcgPT09ICdwcmUnOyB9O1xuXG52YXIgaXNSZXNlcnZlZFRhZyA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgcmV0dXJuIGlzSFRNTFRhZyh0YWcpIHx8IGlzU1ZHKHRhZylcbn07XG5cbmZ1bmN0aW9uIGdldFRhZ05hbWVzcGFjZSAodGFnKSB7XG4gIGlmIChpc1NWRyh0YWcpKSB7XG4gICAgcmV0dXJuICdzdmcnXG4gIH1cbiAgLy8gYmFzaWMgc3VwcG9ydCBmb3IgTWF0aE1MXG4gIC8vIG5vdGUgaXQgZG9lc24ndCBzdXBwb3J0IG90aGVyIE1hdGhNTCBlbGVtZW50cyBiZWluZyBjb21wb25lbnQgcm9vdHNcbiAgaWYgKHRhZyA9PT0gJ21hdGgnKSB7XG4gICAgcmV0dXJuICdtYXRoJ1xuICB9XG59XG5cbnZhciB1bmtub3duRWxlbWVudENhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQgKHRhZykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFpbkJyb3dzZXIpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmIChpc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB0YWcgPSB0YWcudG9Mb3dlckNhc2UoKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gIT0gbnVsbCkge1xuICAgIHJldHVybiB1bmtub3duRWxlbWVudENhY2hlW3RhZ11cbiAgfVxuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gIGlmICh0YWcuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yODIxMDM2NC8xMDcwMjQ0XG4gICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAoXG4gICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxVbmtub3duRWxlbWVudCB8fFxuICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MRWxlbWVudFxuICAgICkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAvSFRNTFVua25vd25FbGVtZW50Ly50ZXN0KGVsLnRvU3RyaW5nKCkpKVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFF1ZXJ5IGFuIGVsZW1lbnQgc2VsZWN0b3IgaWYgaXQncyBub3QgYW4gZWxlbWVudCBhbHJlYWR5LlxuICovXG5mdW5jdGlvbiBxdWVyeSAoZWwpIHtcbiAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgc2VsZWN0ZWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsKTtcbiAgICBpZiAoIXNlbGVjdGVkKSB7XG4gICAgICBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAnQ2Fubm90IGZpbmQgZWxlbWVudDogJyArIGVsXG4gICAgICApO1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgfVxuICAgIHJldHVybiBzZWxlY3RlZFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBlbFxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50JDEgKHRhZ05hbWUsIHZub2RlKSB7XG4gIHZhciBlbG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICBpZiAodGFnTmFtZSAhPT0gJ3NlbGVjdCcpIHtcbiAgICByZXR1cm4gZWxtXG4gIH1cbiAgLy8gZmFsc2Ugb3IgbnVsbCB3aWxsIHJlbW92ZSB0aGUgYXR0cmlidXRlIGJ1dCB1bmRlZmluZWQgd2lsbCBub3RcbiAgaWYgKHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS5hdHRycyAmJiB2bm9kZS5kYXRhLmF0dHJzLm11bHRpcGxlICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbG0uc2V0QXR0cmlidXRlKCdtdWx0aXBsZScsICdtdWx0aXBsZScpO1xuICB9XG4gIHJldHVybiBlbG1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudE5TIChuYW1lc3BhY2UsIHRhZ05hbWUpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VNYXBbbmFtZXNwYWNlXSwgdGFnTmFtZSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUgKHRleHQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnQgKHRleHQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQodGV4dClcbn1cblxuZnVuY3Rpb24gaW5zZXJ0QmVmb3JlIChwYXJlbnROb2RlLCBuZXdOb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVDaGlsZCAobm9kZSwgY2hpbGQpIHtcbiAgbm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG59XG5cbmZ1bmN0aW9uIGFwcGVuZENoaWxkIChub2RlLCBjaGlsZCkge1xuICBub2RlLmFwcGVuZENoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gcGFyZW50Tm9kZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS5wYXJlbnROb2RlXG59XG5cbmZ1bmN0aW9uIG5leHRTaWJsaW5nIChub2RlKSB7XG4gIHJldHVybiBub2RlLm5leHRTaWJsaW5nXG59XG5cbmZ1bmN0aW9uIHRhZ05hbWUgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUudGFnTmFtZVxufVxuXG5mdW5jdGlvbiBzZXRUZXh0Q29udGVudCAobm9kZSwgdGV4dCkge1xuICBub2RlLnRleHRDb250ZW50ID0gdGV4dDtcbn1cblxuZnVuY3Rpb24gc2V0QXR0cmlidXRlIChub2RlLCBrZXksIHZhbCkge1xuICBub2RlLnNldEF0dHJpYnV0ZShrZXksIHZhbCk7XG59XG5cblxudmFyIG5vZGVPcHMgPSBPYmplY3QuZnJlZXplKHtcblx0Y3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCQxLFxuXHRjcmVhdGVFbGVtZW50TlM6IGNyZWF0ZUVsZW1lbnROUyxcblx0Y3JlYXRlVGV4dE5vZGU6IGNyZWF0ZVRleHROb2RlLFxuXHRjcmVhdGVDb21tZW50OiBjcmVhdGVDb21tZW50LFxuXHRpbnNlcnRCZWZvcmU6IGluc2VydEJlZm9yZSxcblx0cmVtb3ZlQ2hpbGQ6IHJlbW92ZUNoaWxkLFxuXHRhcHBlbmRDaGlsZDogYXBwZW5kQ2hpbGQsXG5cdHBhcmVudE5vZGU6IHBhcmVudE5vZGUsXG5cdG5leHRTaWJsaW5nOiBuZXh0U2libGluZyxcblx0dGFnTmFtZTogdGFnTmFtZSxcblx0c2V0VGV4dENvbnRlbnQ6IHNldFRleHRDb250ZW50LFxuXHRzZXRBdHRyaWJ1dGU6IHNldEF0dHJpYnV0ZVxufSk7XG5cbi8qICAqL1xuXG52YXIgcmVmID0ge1xuICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZSAoXywgdm5vZGUpIHtcbiAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICBpZiAob2xkVm5vZGUuZGF0YS5yZWYgIT09IHZub2RlLmRhdGEucmVmKSB7XG4gICAgICByZWdpc3RlclJlZihvbGRWbm9kZSwgdHJ1ZSk7XG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgfVxuICB9LFxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlLCB0cnVlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJSZWYgKHZub2RlLCBpc1JlbW92YWwpIHtcbiAgdmFyIGtleSA9IHZub2RlLmRhdGEucmVmO1xuICBpZiAoIWtleSkgeyByZXR1cm4gfVxuXG4gIHZhciB2bSA9IHZub2RlLmNvbnRleHQ7XG4gIHZhciByZWYgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSB8fCB2bm9kZS5lbG07XG4gIHZhciByZWZzID0gdm0uJHJlZnM7XG4gIGlmIChpc1JlbW92YWwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZWZzW2tleV0pKSB7XG4gICAgICByZW1vdmUocmVmc1trZXldLCByZWYpO1xuICAgIH0gZWxzZSBpZiAocmVmc1trZXldID09PSByZWYpIHtcbiAgICAgIHJlZnNba2V5XSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZub2RlLmRhdGEucmVmSW5Gb3IpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZWZzW2tleV0pKSB7XG4gICAgICAgIHJlZnNba2V5XSA9IFtyZWZdO1xuICAgICAgfSBlbHNlIGlmIChyZWZzW2tleV0uaW5kZXhPZihyZWYpIDwgMCkge1xuICAgICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgICAgcmVmc1trZXldLnB1c2gocmVmKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVmc1trZXldID0gcmVmO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFZpcnR1YWwgRE9NIHBhdGNoaW5nIGFsZ29yaXRobSBiYXNlZCBvbiBTbmFiYmRvbSBieVxuICogU2ltb24gRnJpaXMgVmluZHVtIChAcGFsZGVwaW5kKVxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcGFsZGVwaW5kL3NuYWJiZG9tL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqXG4gKiBtb2RpZmllZCBieSBFdmFuIFlvdSAoQHl5eDk5MDgwMylcbiAqXG5cbi8qXG4gKiBOb3QgdHlwZS1jaGVja2luZyB0aGlzIGJlY2F1c2UgdGhpcyBmaWxlIGlzIHBlcmYtY3JpdGljYWwgYW5kIHRoZSBjb3N0XG4gKiBvZiBtYWtpbmcgZmxvdyB1bmRlcnN0YW5kIGl0IGlzIG5vdCB3b3J0aCBpdC5cbiAqL1xuXG52YXIgZW1wdHlOb2RlID0gbmV3IFZOb2RlKCcnLCB7fSwgW10pO1xuXG52YXIgaG9va3MgPSBbJ2NyZWF0ZScsICdhY3RpdmF0ZScsICd1cGRhdGUnLCAncmVtb3ZlJywgJ2Rlc3Ryb3knXTtcblxuZnVuY3Rpb24gc2FtZVZub2RlIChhLCBiKSB7XG4gIHJldHVybiAoXG4gICAgYS5rZXkgPT09IGIua2V5ICYmIChcbiAgICAgIChcbiAgICAgICAgYS50YWcgPT09IGIudGFnICYmXG4gICAgICAgIGEuaXNDb21tZW50ID09PSBiLmlzQ29tbWVudCAmJlxuICAgICAgICBpc0RlZihhLmRhdGEpID09PSBpc0RlZihiLmRhdGEpICYmXG4gICAgICAgIHNhbWVJbnB1dFR5cGUoYSwgYilcbiAgICAgICkgfHwgKFxuICAgICAgICBpc1RydWUoYS5pc0FzeW5jUGxhY2Vob2xkZXIpICYmXG4gICAgICAgIGEuYXN5bmNGYWN0b3J5ID09PSBiLmFzeW5jRmFjdG9yeSAmJlxuICAgICAgICBpc1VuZGVmKGIuYXN5bmNGYWN0b3J5LmVycm9yKVxuICAgICAgKVxuICAgIClcbiAgKVxufVxuXG4vLyBTb21lIGJyb3dzZXJzIGRvIG5vdCBzdXBwb3J0IGR5bmFtaWNhbGx5IGNoYW5naW5nIHR5cGUgZm9yIDxpbnB1dD5cbi8vIHNvIHRoZXkgbmVlZCB0byBiZSB0cmVhdGVkIGFzIGRpZmZlcmVudCBub2Rlc1xuZnVuY3Rpb24gc2FtZUlucHV0VHlwZSAoYSwgYikge1xuICBpZiAoYS50YWcgIT09ICdpbnB1dCcpIHsgcmV0dXJuIHRydWUgfVxuICB2YXIgaTtcbiAgdmFyIHR5cGVBID0gaXNEZWYoaSA9IGEuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgdmFyIHR5cGVCID0gaXNEZWYoaSA9IGIuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgcmV0dXJuIHR5cGVBID09PSB0eXBlQlxufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXlUb09sZElkeCAoY2hpbGRyZW4sIGJlZ2luSWR4LCBlbmRJZHgpIHtcbiAgdmFyIGksIGtleTtcbiAgdmFyIG1hcCA9IHt9O1xuICBmb3IgKGkgPSBiZWdpbklkeDsgaSA8PSBlbmRJZHg7ICsraSkge1xuICAgIGtleSA9IGNoaWxkcmVuW2ldLmtleTtcbiAgICBpZiAoaXNEZWYoa2V5KSkgeyBtYXBba2V5XSA9IGk7IH1cbiAgfVxuICByZXR1cm4gbWFwXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBhdGNoRnVuY3Rpb24gKGJhY2tlbmQpIHtcbiAgdmFyIGksIGo7XG4gIHZhciBjYnMgPSB7fTtcblxuICB2YXIgbW9kdWxlcyA9IGJhY2tlbmQubW9kdWxlcztcbiAgdmFyIG5vZGVPcHMgPSBiYWNrZW5kLm5vZGVPcHM7XG5cbiAgZm9yIChpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgKytpKSB7XG4gICAgY2JzW2hvb2tzW2ldXSA9IFtdO1xuICAgIGZvciAoaiA9IDA7IGogPCBtb2R1bGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICBpZiAoaXNEZWYobW9kdWxlc1tqXVtob29rc1tpXV0pKSB7XG4gICAgICAgIGNic1tob29rc1tpXV0ucHVzaChtb2R1bGVzW2pdW2hvb2tzW2ldXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW1wdHlOb2RlQXQgKGVsbSkge1xuICAgIHJldHVybiBuZXcgVk5vZGUobm9kZU9wcy50YWdOYW1lKGVsbSkudG9Mb3dlckNhc2UoKSwge30sIFtdLCB1bmRlZmluZWQsIGVsbSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJtQ2IgKGNoaWxkRWxtLCBsaXN0ZW5lcnMpIHtcbiAgICBmdW5jdGlvbiByZW1vdmUkJDEgKCkge1xuICAgICAgaWYgKC0tcmVtb3ZlJCQxLmxpc3RlbmVycyA9PT0gMCkge1xuICAgICAgICByZW1vdmVOb2RlKGNoaWxkRWxtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlJCQxLmxpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgICByZXR1cm4gcmVtb3ZlJCQxXG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVOb2RlIChlbCkge1xuICAgIHZhciBwYXJlbnQgPSBub2RlT3BzLnBhcmVudE5vZGUoZWwpO1xuICAgIC8vIGVsZW1lbnQgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIHJlbW92ZWQgZHVlIHRvIHYtaHRtbCAvIHYtdGV4dFxuICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XG4gICAgICBub2RlT3BzLnJlbW92ZUNoaWxkKHBhcmVudCwgZWwpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBpblByZSA9IDA7XG4gIGZ1bmN0aW9uIGNyZWF0ZUVsbSAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0sIG5lc3RlZCkge1xuICAgIHZub2RlLmlzUm9vdEluc2VydCA9ICFuZXN0ZWQ7IC8vIGZvciB0cmFuc2l0aW9uIGVudGVyIGNoZWNrXG4gICAgaWYgKGNyZWF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICB2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgICB2YXIgdGFnID0gdm5vZGUudGFnO1xuICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgICAgaW5QcmUrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgIWluUHJlICYmXG4gICAgICAgICAgIXZub2RlLm5zICYmXG4gICAgICAgICAgIShjb25maWcuaWdub3JlZEVsZW1lbnRzLmxlbmd0aCAmJiBjb25maWcuaWdub3JlZEVsZW1lbnRzLmluZGV4T2YodGFnKSA+IC0xKSAmJlxuICAgICAgICAgIGNvbmZpZy5pc1Vua25vd25FbGVtZW50KHRhZylcbiAgICAgICAgKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgICdVbmtub3duIGN1c3RvbSBlbGVtZW50OiA8JyArIHRhZyArICc+IC0gZGlkIHlvdSAnICtcbiAgICAgICAgICAgICdyZWdpc3RlciB0aGUgY29tcG9uZW50IGNvcnJlY3RseT8gRm9yIHJlY3Vyc2l2ZSBjb21wb25lbnRzLCAnICtcbiAgICAgICAgICAgICdtYWtlIHN1cmUgdG8gcHJvdmlkZSB0aGUgXCJuYW1lXCIgb3B0aW9uLicsXG4gICAgICAgICAgICB2bm9kZS5jb250ZXh0XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdm5vZGUuZWxtID0gdm5vZGUubnNcbiAgICAgICAgPyBub2RlT3BzLmNyZWF0ZUVsZW1lbnROUyh2bm9kZS5ucywgdGFnKVxuICAgICAgICA6IG5vZGVPcHMuY3JlYXRlRWxlbWVudCh0YWcsIHZub2RlKTtcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICB7XG4gICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgZGF0YSAmJiBkYXRhLnByZSkge1xuICAgICAgICBpblByZS0tO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkpIHtcbiAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlQ29tbWVudCh2bm9kZS50ZXh0KTtcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KTtcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgdmFyIGkgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihpKSkge1xuICAgICAgdmFyIGlzUmVhY3RpdmF0ZWQgPSBpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkgJiYgaS5rZWVwQWxpdmU7XG4gICAgICBpZiAoaXNEZWYoaSA9IGkuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHtcbiAgICAgICAgaSh2bm9kZSwgZmFsc2UgLyogaHlkcmF0aW5nICovLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgICB9XG4gICAgICAvLyBhZnRlciBjYWxsaW5nIHRoZSBpbml0IGhvb2ssIGlmIHRoZSB2bm9kZSBpcyBhIGNoaWxkIGNvbXBvbmVudFxuICAgICAgLy8gaXQgc2hvdWxkJ3ZlIGNyZWF0ZWQgYSBjaGlsZCBpbnN0YW5jZSBhbmQgbW91bnRlZCBpdC4gdGhlIGNoaWxkXG4gICAgICAvLyBjb21wb25lbnQgYWxzbyBoYXMgc2V0IHRoZSBwbGFjZWhvbGRlciB2bm9kZSdzIGVsbS5cbiAgICAgIC8vIGluIHRoYXQgY2FzZSB3ZSBjYW4ganVzdCByZXR1cm4gdGhlIGVsZW1lbnQgYW5kIGJlIGRvbmUuXG4gICAgICBpZiAoaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGlmIChpc1RydWUoaXNSZWFjdGl2YXRlZCkpIHtcbiAgICAgICAgICByZWFjdGl2YXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBpZiAoaXNEZWYodm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KSkge1xuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2guYXBwbHkoaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpO1xuICAgICAgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0ID0gbnVsbDtcbiAgICB9XG4gICAgdm5vZGUuZWxtID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuJGVsO1xuICAgIGlmIChpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgc2V0U2NvcGUodm5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlbXB0eSBjb21wb25lbnQgcm9vdC5cbiAgICAgIC8vIHNraXAgYWxsIGVsZW1lbnQtcmVsYXRlZCBtb2R1bGVzIGV4Y2VwdCBmb3IgcmVmICgjMzQ1NSlcbiAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICAgIC8vIG1ha2Ugc3VyZSB0byBpbnZva2UgdGhlIGluc2VydCBob29rXG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhY3RpdmF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICB2YXIgaTtcbiAgICAvLyBoYWNrIGZvciAjNDMzOTogYSByZWFjdGl2YXRlZCBjb21wb25lbnQgd2l0aCBpbm5lciB0cmFuc2l0aW9uXG4gICAgLy8gZG9lcyBub3QgdHJpZ2dlciBiZWNhdXNlIHRoZSBpbm5lciBub2RlJ3MgY3JlYXRlZCBob29rcyBhcmUgbm90IGNhbGxlZFxuICAgIC8vIGFnYWluLiBJdCdzIG5vdCBpZGVhbCB0byBpbnZvbHZlIG1vZHVsZS1zcGVjaWZpYyBsb2dpYyBpbiBoZXJlIGJ1dFxuICAgIC8vIHRoZXJlIGRvZXNuJ3Qgc2VlbSB0byBiZSBhIGJldHRlciB3YXkgdG8gZG8gaXQuXG4gICAgdmFyIGlubmVyTm9kZSA9IHZub2RlO1xuICAgIHdoaWxlIChpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIGlubmVyTm9kZSA9IGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICBpZiAoaXNEZWYoaSA9IGlubmVyTm9kZS5kYXRhKSAmJiBpc0RlZihpID0gaS50cmFuc2l0aW9uKSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmFjdGl2YXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgY2JzLmFjdGl2YXRlW2ldKGVtcHR5Tm9kZSwgaW5uZXJOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaChpbm5lck5vZGUpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICAvLyB1bmxpa2UgYSBuZXdseSBjcmVhdGVkIGNvbXBvbmVudCxcbiAgICAvLyBhIHJlYWN0aXZhdGVkIGtlZXAtYWxpdmUgY29tcG9uZW50IGRvZXNuJ3QgaW5zZXJ0IGl0c2VsZlxuICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2VydCAocGFyZW50LCBlbG0sIHJlZiQkMSkge1xuICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XG4gICAgICBpZiAoaXNEZWYocmVmJCQxKSkge1xuICAgICAgICBpZiAocmVmJCQxLnBhcmVudE5vZGUgPT09IHBhcmVudCkge1xuICAgICAgICAgIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudCwgZWxtLCByZWYkJDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlT3BzLmFwcGVuZENoaWxkKHBhcmVudCwgZWxtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDaGlsZHJlbiAodm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3JlYXRlRWxtKGNoaWxkcmVuW2ldLCBpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmVsbSwgbnVsbCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZSh2bm9kZS50ZXh0KSkge1xuICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZCh2bm9kZS5lbG0sIG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUodm5vZGUudGV4dCkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUGF0Y2hhYmxlICh2bm9kZSkge1xuICAgIHdoaWxlICh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgdm5vZGUgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgfVxuICAgIHJldHVybiBpc0RlZih2bm9kZS50YWcpXG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VDcmVhdGVIb29rcyAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kkMSkge1xuICAgICAgY2JzLmNyZWF0ZVtpJDFdKGVtcHR5Tm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICBpID0gdm5vZGUuZGF0YS5ob29rOyAvLyBSZXVzZSB2YXJpYWJsZVxuICAgIGlmIChpc0RlZihpKSkge1xuICAgICAgaWYgKGlzRGVmKGkuY3JlYXRlKSkgeyBpLmNyZWF0ZShlbXB0eU5vZGUsIHZub2RlKTsgfVxuICAgICAgaWYgKGlzRGVmKGkuaW5zZXJ0KSkgeyBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7IH1cbiAgICB9XG4gIH1cblxuICAvLyBzZXQgc2NvcGUgaWQgYXR0cmlidXRlIGZvciBzY29wZWQgQ1NTLlxuICAvLyB0aGlzIGlzIGltcGxlbWVudGVkIGFzIGEgc3BlY2lhbCBjYXNlIHRvIGF2b2lkIHRoZSBvdmVyaGVhZFxuICAvLyBvZiBnb2luZyB0aHJvdWdoIHRoZSBub3JtYWwgYXR0cmlidXRlIHBhdGNoaW5nIHByb2Nlc3MuXG4gIGZ1bmN0aW9uIHNldFNjb3BlICh2bm9kZSkge1xuICAgIHZhciBpO1xuICAgIHZhciBhbmNlc3RvciA9IHZub2RlO1xuICAgIHdoaWxlIChhbmNlc3Rvcikge1xuICAgICAgaWYgKGlzRGVmKGkgPSBhbmNlc3Rvci5jb250ZXh0KSAmJiBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZCkpIHtcbiAgICAgICAgbm9kZU9wcy5zZXRBdHRyaWJ1dGUodm5vZGUuZWxtLCBpLCAnJyk7XG4gICAgICB9XG4gICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICB9XG4gICAgLy8gZm9yIHNsb3QgY29udGVudCB0aGV5IHNob3VsZCBhbHNvIGdldCB0aGUgc2NvcGVJZCBmcm9tIHRoZSBob3N0IGluc3RhbmNlLlxuICAgIGlmIChpc0RlZihpID0gYWN0aXZlSW5zdGFuY2UpICYmXG4gICAgICBpICE9PSB2bm9kZS5jb250ZXh0ICYmXG4gICAgICBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZClcbiAgICApIHtcbiAgICAgIG5vZGVPcHMuc2V0QXR0cmlidXRlKHZub2RlLmVsbSwgaSwgJycpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFZub2RlcyAocGFyZW50RWxtLCByZWZFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgY3JlYXRlRWxtKHZub2Rlc1tzdGFydElkeF0sIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZURlc3Ryb3lIb29rICh2bm9kZSkge1xuICAgIHZhciBpLCBqO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5kZXN0cm95KSkgeyBpKHZub2RlKTsgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKSB7IGNicy5kZXN0cm95W2ldKHZub2RlKTsgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNoaWxkcmVuKSkge1xuICAgICAgZm9yIChqID0gMDsgaiA8IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGludm9rZURlc3Ryb3lIb29rKHZub2RlLmNoaWxkcmVuW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVWbm9kZXMgKHBhcmVudEVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4KSB7XG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgdmFyIGNoID0gdm5vZGVzW3N0YXJ0SWR4XTtcbiAgICAgIGlmIChpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKGlzRGVmKGNoLnRhZykpIHtcbiAgICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGNoKTtcbiAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhjaCk7XG4gICAgICAgIH0gZWxzZSB7IC8vIFRleHQgbm9kZVxuICAgICAgICAgIHJlbW92ZU5vZGUoY2guZWxtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2sgKHZub2RlLCBybSkge1xuICAgIGlmIChpc0RlZihybSkgfHwgaXNEZWYodm5vZGUuZGF0YSkpIHtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxpc3RlbmVycyA9IGNicy5yZW1vdmUubGVuZ3RoICsgMTtcbiAgICAgIGlmIChpc0RlZihybSkpIHtcbiAgICAgICAgLy8gd2UgaGF2ZSBhIHJlY3Vyc2l2ZWx5IHBhc3NlZCBkb3duIHJtIGNhbGxiYWNrXG4gICAgICAgIC8vIGluY3JlYXNlIHRoZSBsaXN0ZW5lcnMgY291bnRcbiAgICAgICAgcm0ubGlzdGVuZXJzICs9IGxpc3RlbmVycztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRpcmVjdGx5IHJlbW92aW5nXG4gICAgICAgIHJtID0gY3JlYXRlUm1DYih2bm9kZS5lbG0sIGxpc3RlbmVycyk7XG4gICAgICB9XG4gICAgICAvLyByZWN1cnNpdmVseSBpbnZva2UgaG9va3Mgb24gY2hpbGQgY29tcG9uZW50IHJvb3Qgbm9kZVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkgJiYgaXNEZWYoaSA9IGkuX3Zub2RlKSAmJiBpc0RlZihpLmRhdGEpKSB7XG4gICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soaSwgcm0pO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5yZW1vdmUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY2JzLnJlbW92ZVtpXSh2bm9kZSwgcm0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5kYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnJlbW92ZSkpIHtcbiAgICAgICAgaSh2bm9kZSwgcm0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm0oKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlTm9kZSh2bm9kZS5lbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNoaWxkcmVuIChwYXJlbnRFbG0sIG9sZENoLCBuZXdDaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KSB7XG4gICAgdmFyIG9sZFN0YXJ0SWR4ID0gMDtcbiAgICB2YXIgbmV3U3RhcnRJZHggPSAwO1xuICAgIHZhciBvbGRFbmRJZHggPSBvbGRDaC5sZW5ndGggLSAxO1xuICAgIHZhciBvbGRTdGFydFZub2RlID0gb2xkQ2hbMF07XG4gICAgdmFyIG9sZEVuZFZub2RlID0gb2xkQ2hbb2xkRW5kSWR4XTtcbiAgICB2YXIgbmV3RW5kSWR4ID0gbmV3Q2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWzBdO1xuICAgIHZhciBuZXdFbmRWbm9kZSA9IG5ld0NoW25ld0VuZElkeF07XG4gICAgdmFyIG9sZEtleVRvSWR4LCBpZHhJbk9sZCwgZWxtVG9Nb3ZlLCByZWZFbG07XG5cbiAgICAvLyByZW1vdmVPbmx5IGlzIGEgc3BlY2lhbCBmbGFnIHVzZWQgb25seSBieSA8dHJhbnNpdGlvbi1ncm91cD5cbiAgICAvLyB0byBlbnN1cmUgcmVtb3ZlZCBlbGVtZW50cyBzdGF5IGluIGNvcnJlY3QgcmVsYXRpdmUgcG9zaXRpb25zXG4gICAgLy8gZHVyaW5nIGxlYXZpbmcgdHJhbnNpdGlvbnNcbiAgICB2YXIgY2FuTW92ZSA9ICFyZW1vdmVPbmx5O1xuXG4gICAgd2hpbGUgKG9sZFN0YXJ0SWR4IDw9IG9sZEVuZElkeCAmJiBuZXdTdGFydElkeCA8PSBuZXdFbmRJZHgpIHtcbiAgICAgIGlmIChpc1VuZGVmKG9sZFN0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTsgLy8gVm5vZGUgaGFzIGJlZW4gbW92ZWQgbGVmdFxuICAgICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZEVuZFZub2RlKSkge1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgcmlnaHRcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVuZFZub2RlLmVsbSkpO1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIGxlZnRcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZEVuZFZub2RlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzVW5kZWYob2xkS2V5VG9JZHgpKSB7IG9sZEtleVRvSWR4ID0gY3JlYXRlS2V5VG9PbGRJZHgob2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpOyB9XG4gICAgICAgIGlkeEluT2xkID0gaXNEZWYobmV3U3RhcnRWbm9kZS5rZXkpID8gb2xkS2V5VG9JZHhbbmV3U3RhcnRWbm9kZS5rZXldIDogbnVsbDtcbiAgICAgICAgaWYgKGlzVW5kZWYoaWR4SW5PbGQpKSB7IC8vIE5ldyBlbGVtZW50XG4gICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsbVRvTW92ZSA9IG9sZENoW2lkeEluT2xkXTtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgIWVsbVRvTW92ZSkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgJ0l0IHNlZW1zIHRoZXJlIGFyZSBkdXBsaWNhdGUga2V5cyB0aGF0IGlzIGNhdXNpbmcgYW4gdXBkYXRlIGVycm9yLiAnICtcbiAgICAgICAgICAgICAgJ01ha2Ugc3VyZSBlYWNoIHYtZm9yIGl0ZW0gaGFzIGEgdW5pcXVlIGtleS4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2FtZVZub2RlKGVsbVRvTW92ZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICAgIHBhdGNoVm5vZGUoZWxtVG9Nb3ZlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgb2xkQ2hbaWR4SW5PbGRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIGVsbVRvTW92ZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gc2FtZSBrZXkgYnV0IGRpZmZlcmVudCBlbGVtZW50LiB0cmVhdCBhcyBuZXcgZWxlbWVudFxuICAgICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvbGRTdGFydElkeCA+IG9sZEVuZElkeCkge1xuICAgICAgcmVmRWxtID0gaXNVbmRlZihuZXdDaFtuZXdFbmRJZHggKyAxXSkgPyBudWxsIDogbmV3Q2hbbmV3RW5kSWR4ICsgMV0uZWxtO1xuICAgICAgYWRkVm5vZGVzKHBhcmVudEVsbSwgcmVmRWxtLCBuZXdDaCwgbmV3U3RhcnRJZHgsIG5ld0VuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICB9IGVsc2UgaWYgKG5ld1N0YXJ0SWR4ID4gbmV3RW5kSWR4KSB7XG4gICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtLCBvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGF0Y2hWbm9kZSAob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpIHtcbiAgICBpZiAob2xkVm5vZGUgPT09IHZub2RlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgZWxtID0gdm5vZGUuZWxtID0gb2xkVm5vZGUuZWxtO1xuXG4gICAgaWYgKGlzVHJ1ZShvbGRWbm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIpKSB7XG4gICAgICBpZiAoaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICBoeWRyYXRlKG9sZFZub2RlLmVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gcmV1c2UgZWxlbWVudCBmb3Igc3RhdGljIHRyZWVzLlxuICAgIC8vIG5vdGUgd2Ugb25seSBkbyB0aGlzIGlmIHRoZSB2bm9kZSBpcyBjbG9uZWQgLVxuICAgIC8vIGlmIHRoZSBuZXcgbm9kZSBpcyBub3QgY2xvbmVkIGl0IG1lYW5zIHRoZSByZW5kZXIgZnVuY3Rpb25zIGhhdmUgYmVlblxuICAgIC8vIHJlc2V0IGJ5IHRoZSBob3QtcmVsb2FkLWFwaSBhbmQgd2UgbmVlZCB0byBkbyBhIHByb3BlciByZS1yZW5kZXIuXG4gICAgaWYgKGlzVHJ1ZSh2bm9kZS5pc1N0YXRpYykgJiZcbiAgICAgIGlzVHJ1ZShvbGRWbm9kZS5pc1N0YXRpYykgJiZcbiAgICAgIHZub2RlLmtleSA9PT0gb2xkVm5vZGUua2V5ICYmXG4gICAgICAoaXNUcnVlKHZub2RlLmlzQ2xvbmVkKSB8fCBpc1RydWUodm5vZGUuaXNPbmNlKSlcbiAgICApIHtcbiAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnByZXBhdGNoKSkge1xuICAgICAgaShvbGRWbm9kZSwgdm5vZGUpO1xuICAgIH1cblxuICAgIHZhciBvbGRDaCA9IG9sZFZub2RlLmNoaWxkcmVuO1xuICAgIHZhciBjaCA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMudXBkYXRlLmxlbmd0aDsgKytpKSB7IGNicy51cGRhdGVbaV0ob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnVwZGF0ZSkpIHsgaShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgfVxuICAgIGlmIChpc1VuZGVmKHZub2RlLnRleHQpKSB7XG4gICAgICBpZiAoaXNEZWYob2xkQ2gpICYmIGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAob2xkQ2ggIT09IGNoKSB7IHVwZGF0ZUNoaWxkcmVuKGVsbSwgb2xkQ2gsIGNoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpOyB9XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHsgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTsgfVxuICAgICAgICBhZGRWbm9kZXMoZWxtLCBudWxsLCBjaCwgMCwgY2gubGVuZ3RoIC0gMSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkQ2gpKSB7XG4gICAgICAgIHJlbW92ZVZub2RlcyhlbG0sIG9sZENoLCAwLCBvbGRDaC5sZW5ndGggLSAxKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHtcbiAgICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9sZFZub2RlLnRleHQgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCB2bm9kZS50ZXh0KTtcbiAgICB9XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucG9zdHBhdGNoKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VJbnNlcnRIb29rICh2bm9kZSwgcXVldWUsIGluaXRpYWwpIHtcbiAgICAvLyBkZWxheSBpbnNlcnQgaG9va3MgZm9yIGNvbXBvbmVudCByb290IG5vZGVzLCBpbnZva2UgdGhlbSBhZnRlciB0aGVcbiAgICAvLyBlbGVtZW50IGlzIHJlYWxseSBpbnNlcnRlZFxuICAgIGlmIChpc1RydWUoaW5pdGlhbCkgJiYgaXNEZWYodm5vZGUucGFyZW50KSkge1xuICAgICAgdm5vZGUucGFyZW50LmRhdGEucGVuZGluZ0luc2VydCA9IHF1ZXVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHF1ZXVlW2ldLmRhdGEuaG9vay5pbnNlcnQocXVldWVbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBiYWlsZWQgPSBmYWxzZTtcbiAgLy8gbGlzdCBvZiBtb2R1bGVzIHRoYXQgY2FuIHNraXAgY3JlYXRlIGhvb2sgZHVyaW5nIGh5ZHJhdGlvbiBiZWNhdXNlIHRoZXlcbiAgLy8gYXJlIGFscmVhZHkgcmVuZGVyZWQgb24gdGhlIGNsaWVudCBvciBoYXMgbm8gbmVlZCBmb3IgaW5pdGlhbGl6YXRpb25cbiAgdmFyIGlzUmVuZGVyZWRNb2R1bGUgPSBtYWtlTWFwKCdhdHRycyxzdHlsZSxjbGFzcyxzdGF0aWNDbGFzcyxzdGF0aWNTdHlsZSxrZXknKTtcblxuICAvLyBOb3RlOiB0aGlzIGlzIGEgYnJvd3Nlci1vbmx5IGZ1bmN0aW9uIHNvIHdlIGNhbiBhc3N1bWUgZWxtcyBhcmUgRE9NIG5vZGVzLlxuICBmdW5jdGlvbiBoeWRyYXRlIChlbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkgJiYgaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5KSkge1xuICAgICAgdm5vZGUuZWxtID0gZWxtO1xuICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHtcbiAgICAgIGlmICghYXNzZXJ0Tm9kZU1hdGNoKGVsbSwgdm5vZGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICB2bm9kZS5lbG0gPSBlbG07XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHsgaSh2bm9kZSwgdHJ1ZSAvKiBoeWRyYXRpbmcgKi8pOyB9XG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgICAvLyBjaGlsZCBjb21wb25lbnQuIGl0IHNob3VsZCBoYXZlIGh5ZHJhdGVkIGl0cyBvd24gdHJlZS5cbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKHRhZykpIHtcbiAgICAgIGlmIChpc0RlZihjaGlsZHJlbikpIHtcbiAgICAgICAgLy8gZW1wdHkgZWxlbWVudCwgYWxsb3cgY2xpZW50IHRvIHBpY2sgdXAgYW5kIHBvcHVsYXRlIGNoaWxkcmVuXG4gICAgICAgIGlmICghZWxtLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgY2hpbGRyZW5NYXRjaCA9IHRydWU7XG4gICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGVsbS5maXJzdENoaWxkO1xuICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNoaWxkcmVuLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgICAgIGlmICghY2hpbGROb2RlIHx8ICFoeWRyYXRlKGNoaWxkTm9kZSwgY2hpbGRyZW5baSQxXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSkge1xuICAgICAgICAgICAgICBjaGlsZHJlbk1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGlmIGNoaWxkTm9kZSBpcyBub3QgbnVsbCwgaXQgbWVhbnMgdGhlIGFjdHVhbCBjaGlsZE5vZGVzIGxpc3QgaXNcbiAgICAgICAgICAvLyBsb25nZXIgdGhhbiB0aGUgdmlydHVhbCBjaGlsZHJlbiBsaXN0LlxuICAgICAgICAgIGlmICghY2hpbGRyZW5NYXRjaCB8fCBjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgIWJhaWxlZFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGJhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ01pc21hdGNoaW5nIGNoaWxkTm9kZXMgdnMuIFZOb2RlczogJywgZWxtLmNoaWxkTm9kZXMsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgaWYgKCFpc1JlbmRlcmVkTW9kdWxlKGtleSkpIHtcbiAgICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsbS5kYXRhICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICBlbG0uZGF0YSA9IHZub2RlLnRleHQ7XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnROb2RlTWF0Y2ggKG5vZGUsIHZub2RlKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLnRhZykpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHZub2RlLnRhZy5pbmRleE9mKCd2dWUtY29tcG9uZW50JykgPT09IDAgfHxcbiAgICAgICAgdm5vZGUudGFnLnRvTG93ZXJDYXNlKCkgPT09IChub2RlLnRhZ05hbWUgJiYgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAodm5vZGUuaXNDb21tZW50ID8gOCA6IDMpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHBhdGNoIChvbGRWbm9kZSwgdm5vZGUsIGh5ZHJhdGluZywgcmVtb3ZlT25seSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICBpZiAoaXNVbmRlZih2bm9kZSkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRWbm9kZSkpIHsgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpOyB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgaXNJbml0aWFsUGF0Y2ggPSBmYWxzZTtcbiAgICB2YXIgaW5zZXJ0ZWRWbm9kZVF1ZXVlID0gW107XG5cbiAgICBpZiAoaXNVbmRlZihvbGRWbm9kZSkpIHtcbiAgICAgIC8vIGVtcHR5IG1vdW50IChsaWtlbHkgYXMgY29tcG9uZW50KSwgY3JlYXRlIG5ldyByb290IGVsZW1lbnRcbiAgICAgIGlzSW5pdGlhbFBhdGNoID0gdHJ1ZTtcbiAgICAgIGNyZWF0ZUVsbSh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpc1JlYWxFbGVtZW50ID0gaXNEZWYob2xkVm5vZGUubm9kZVR5cGUpO1xuICAgICAgaWYgKCFpc1JlYWxFbGVtZW50ICYmIHNhbWVWbm9kZShvbGRWbm9kZSwgdm5vZGUpKSB7XG4gICAgICAgIC8vIHBhdGNoIGV4aXN0aW5nIHJvb3Qgbm9kZVxuICAgICAgICBwYXRjaFZub2RlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1JlYWxFbGVtZW50KSB7XG4gICAgICAgICAgLy8gbW91bnRpbmcgdG8gYSByZWFsIGVsZW1lbnRcbiAgICAgICAgICAvLyBjaGVjayBpZiB0aGlzIGlzIHNlcnZlci1yZW5kZXJlZCBjb250ZW50IGFuZCBpZiB3ZSBjYW4gcGVyZm9ybVxuICAgICAgICAgIC8vIGEgc3VjY2Vzc2Z1bCBoeWRyYXRpb24uXG4gICAgICAgICAgaWYgKG9sZFZub2RlLm5vZGVUeXBlID09PSAxICYmIG9sZFZub2RlLmhhc0F0dHJpYnV0ZShTU1JfQVRUUikpIHtcbiAgICAgICAgICAgIG9sZFZub2RlLnJlbW92ZUF0dHJpYnV0ZShTU1JfQVRUUik7XG4gICAgICAgICAgICBoeWRyYXRpbmcgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNUcnVlKGh5ZHJhdGluZykpIHtcbiAgICAgICAgICAgIGlmIChoeWRyYXRlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSkge1xuICAgICAgICAgICAgICBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHRydWUpO1xuICAgICAgICAgICAgICByZXR1cm4gb2xkVm5vZGVcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgJ1RoZSBjbGllbnQtc2lkZSByZW5kZXJlZCB2aXJ0dWFsIERPTSB0cmVlIGlzIG5vdCBtYXRjaGluZyAnICtcbiAgICAgICAgICAgICAgICAnc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQuIFRoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSBpbmNvcnJlY3QgJyArXG4gICAgICAgICAgICAgICAgJ0hUTUwgbWFya3VwLCBmb3IgZXhhbXBsZSBuZXN0aW5nIGJsb2NrLWxldmVsIGVsZW1lbnRzIGluc2lkZSAnICtcbiAgICAgICAgICAgICAgICAnPHA+LCBvciBtaXNzaW5nIDx0Ym9keT4uIEJhaWxpbmcgaHlkcmF0aW9uIGFuZCBwZXJmb3JtaW5nICcgK1xuICAgICAgICAgICAgICAgICdmdWxsIGNsaWVudC1zaWRlIHJlbmRlci4nXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGVpdGhlciBub3Qgc2VydmVyLXJlbmRlcmVkLCBvciBoeWRyYXRpb24gZmFpbGVkLlxuICAgICAgICAgIC8vIGNyZWF0ZSBhbiBlbXB0eSBub2RlIGFuZCByZXBsYWNlIGl0XG4gICAgICAgICAgb2xkVm5vZGUgPSBlbXB0eU5vZGVBdChvbGRWbm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVwbGFjaW5nIGV4aXN0aW5nIGVsZW1lbnRcbiAgICAgICAgdmFyIG9sZEVsbSA9IG9sZFZub2RlLmVsbTtcbiAgICAgICAgdmFyIHBhcmVudEVsbSQxID0gbm9kZU9wcy5wYXJlbnROb2RlKG9sZEVsbSk7XG4gICAgICAgIGNyZWF0ZUVsbShcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUsXG4gICAgICAgICAgLy8gZXh0cmVtZWx5IHJhcmUgZWRnZSBjYXNlOiBkbyBub3QgaW5zZXJ0IGlmIG9sZCBlbGVtZW50IGlzIGluIGFcbiAgICAgICAgICAvLyBsZWF2aW5nIHRyYW5zaXRpb24uIE9ubHkgaGFwcGVucyB3aGVuIGNvbWJpbmluZyB0cmFuc2l0aW9uICtcbiAgICAgICAgICAvLyBrZWVwLWFsaXZlICsgSE9Dcy4gKCM0NTkwKVxuICAgICAgICAgIG9sZEVsbS5fbGVhdmVDYiA/IG51bGwgOiBwYXJlbnRFbG0kMSxcbiAgICAgICAgICBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVsbSlcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoaXNEZWYodm5vZGUucGFyZW50KSkge1xuICAgICAgICAgIC8vIGNvbXBvbmVudCByb290IGVsZW1lbnQgcmVwbGFjZWQuXG4gICAgICAgICAgLy8gdXBkYXRlIHBhcmVudCBwbGFjZWhvbGRlciBub2RlIGVsZW1lbnQsIHJlY3Vyc2l2ZWx5XG4gICAgICAgICAgdmFyIGFuY2VzdG9yID0gdm5vZGUucGFyZW50O1xuICAgICAgICAgIHdoaWxlIChhbmNlc3Rvcikge1xuICAgICAgICAgICAgYW5jZXN0b3IuZWxtID0gdm5vZGUuZWxtO1xuICAgICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICBjYnMuY3JlYXRlW2ldKGVtcHR5Tm9kZSwgdm5vZGUucGFyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWYocGFyZW50RWxtJDEpKSB7XG4gICAgICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSQxLCBbb2xkVm5vZGVdLCAwLCAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50YWcpKSB7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpc0luaXRpYWxQYXRjaCk7XG4gICAgcmV0dXJuIHZub2RlLmVsbVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgZGlyZWN0aXZlcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICB1cGRhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIHVuYmluZERpcmVjdGl2ZXMgKHZub2RlKSB7XG4gICAgdXBkYXRlRGlyZWN0aXZlcyh2bm9kZSwgZW1wdHlOb2RlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gdXBkYXRlRGlyZWN0aXZlcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMgfHwgdm5vZGUuZGF0YS5kaXJlY3RpdmVzKSB7XG4gICAgX3VwZGF0ZShvbGRWbm9kZSwgdm5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF91cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgaXNDcmVhdGUgPSBvbGRWbm9kZSA9PT0gZW1wdHlOb2RlO1xuICB2YXIgaXNEZXN0cm95ID0gdm5vZGUgPT09IGVtcHR5Tm9kZTtcbiAgdmFyIG9sZERpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzLCBvbGRWbm9kZS5jb250ZXh0KTtcbiAgdmFyIG5ld0RpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEodm5vZGUuZGF0YS5kaXJlY3RpdmVzLCB2bm9kZS5jb250ZXh0KTtcblxuICB2YXIgZGlyc1dpdGhJbnNlcnQgPSBbXTtcbiAgdmFyIGRpcnNXaXRoUG9zdHBhdGNoID0gW107XG5cbiAgdmFyIGtleSwgb2xkRGlyLCBkaXI7XG4gIGZvciAoa2V5IGluIG5ld0RpcnMpIHtcbiAgICBvbGREaXIgPSBvbGREaXJzW2tleV07XG4gICAgZGlyID0gbmV3RGlyc1trZXldO1xuICAgIGlmICghb2xkRGlyKSB7XG4gICAgICAvLyBuZXcgZGlyZWN0aXZlLCBiaW5kXG4gICAgICBjYWxsSG9vayQxKGRpciwgJ2JpbmQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5pbnNlcnRlZCkge1xuICAgICAgICBkaXJzV2l0aEluc2VydC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIGRpcmVjdGl2ZSwgdXBkYXRlXG4gICAgICBkaXIub2xkVmFsdWUgPSBvbGREaXIudmFsdWU7XG4gICAgICBjYWxsSG9vayQxKGRpciwgJ3VwZGF0ZScsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmNvbXBvbmVudFVwZGF0ZWQpIHtcbiAgICAgICAgZGlyc1dpdGhQb3N0cGF0Y2gucHVzaChkaXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChkaXJzV2l0aEluc2VydC5sZW5ndGgpIHtcbiAgICB2YXIgY2FsbEluc2VydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhJbnNlcnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbEhvb2skMShkaXJzV2l0aEluc2VydFtpXSwgJ2luc2VydGVkJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChpc0NyZWF0ZSkge1xuICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUuZGF0YS5ob29rIHx8ICh2bm9kZS5kYXRhLmhvb2sgPSB7fSksICdpbnNlcnQnLCBjYWxsSW5zZXJ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbEluc2VydCgpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGgpIHtcbiAgICBtZXJnZVZOb2RlSG9vayh2bm9kZS5kYXRhLmhvb2sgfHwgKHZub2RlLmRhdGEuaG9vayA9IHt9KSwgJ3Bvc3RwYXRjaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbEhvb2skMShkaXJzV2l0aFBvc3RwYXRjaFtpXSwgJ2NvbXBvbmVudFVwZGF0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKCFpc0NyZWF0ZSkge1xuICAgIGZvciAoa2V5IGluIG9sZERpcnMpIHtcbiAgICAgIGlmICghbmV3RGlyc1trZXldKSB7XG4gICAgICAgIC8vIG5vIGxvbmdlciBwcmVzZW50LCB1bmJpbmRcbiAgICAgICAgY2FsbEhvb2skMShvbGREaXJzW2tleV0sICd1bmJpbmQnLCBvbGRWbm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBlbXB0eU1vZGlmaWVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSAoXG4gIGRpcnMsXG4gIHZtXG4pIHtcbiAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGlmICghZGlycykge1xuICAgIHJldHVybiByZXNcbiAgfVxuICB2YXIgaSwgZGlyO1xuICBmb3IgKGkgPSAwOyBpIDwgZGlycy5sZW5ndGg7IGkrKykge1xuICAgIGRpciA9IGRpcnNbaV07XG4gICAgaWYgKCFkaXIubW9kaWZpZXJzKSB7XG4gICAgICBkaXIubW9kaWZpZXJzID0gZW1wdHlNb2RpZmllcnM7XG4gICAgfVxuICAgIHJlc1tnZXRSYXdEaXJOYW1lKGRpcildID0gZGlyO1xuICAgIGRpci5kZWYgPSByZXNvbHZlQXNzZXQodm0uJG9wdGlvbnMsICdkaXJlY3RpdmVzJywgZGlyLm5hbWUsIHRydWUpO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gZ2V0UmF3RGlyTmFtZSAoZGlyKSB7XG4gIHJldHVybiBkaXIucmF3TmFtZSB8fCAoKGRpci5uYW1lKSArIFwiLlwiICsgKE9iamVjdC5rZXlzKGRpci5tb2RpZmllcnMgfHwge30pLmpvaW4oJy4nKSkpXG59XG5cbmZ1bmN0aW9uIGNhbGxIb29rJDEgKGRpciwgaG9vaywgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpIHtcbiAgdmFyIGZuID0gZGlyLmRlZiAmJiBkaXIuZGVmW2hvb2tdO1xuICBpZiAoZm4pIHtcbiAgICB0cnkge1xuICAgICAgZm4odm5vZGUuZWxtLCBkaXIsIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bm9kZS5jb250ZXh0LCAoXCJkaXJlY3RpdmUgXCIgKyAoZGlyLm5hbWUpICsgXCIgXCIgKyBob29rICsgXCIgaG9va1wiKSk7XG4gICAgfVxuICB9XG59XG5cbnZhciBiYXNlTW9kdWxlcyA9IFtcbiAgcmVmLFxuICBkaXJlY3RpdmVzXG5dO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQXR0cnMgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgb3B0cyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIGlmIChpc0RlZihvcHRzKSAmJiBvcHRzLkN0b3Iub3B0aW9ucy5pbmhlcml0QXR0cnMgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5hdHRycykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmF0dHJzKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBrZXksIGN1ciwgb2xkO1xuICB2YXIgZWxtID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkQXR0cnMgPSBvbGRWbm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICB2YXIgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgaWYgKGlzRGVmKGF0dHJzLl9fb2JfXykpIHtcbiAgICBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgPSBleHRlbmQoe30sIGF0dHJzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIGF0dHJzKSB7XG4gICAgY3VyID0gYXR0cnNba2V5XTtcbiAgICBvbGQgPSBvbGRBdHRyc1trZXldO1xuICAgIGlmIChvbGQgIT09IGN1cikge1xuICAgICAgc2V0QXR0cihlbG0sIGtleSwgY3VyKTtcbiAgICB9XG4gIH1cbiAgLy8gIzQzOTE6IGluIElFOSwgc2V0dGluZyB0eXBlIGNhbiByZXNldCB2YWx1ZSBmb3IgaW5wdXRbdHlwZT1yYWRpb11cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0lFOSAmJiBhdHRycy52YWx1ZSAhPT0gb2xkQXR0cnMudmFsdWUpIHtcbiAgICBzZXRBdHRyKGVsbSwgJ3ZhbHVlJywgYXR0cnMudmFsdWUpO1xuICB9XG4gIGZvciAoa2V5IGluIG9sZEF0dHJzKSB7XG4gICAgaWYgKGlzVW5kZWYoYXR0cnNba2V5XSkpIHtcbiAgICAgIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldEF0dHIgKGVsLCBrZXksIHZhbHVlKSB7XG4gIGlmIChpc0Jvb2xlYW5BdHRyKGtleSkpIHtcbiAgICAvLyBzZXQgYXR0cmlidXRlIGZvciBibGFuayB2YWx1ZVxuICAgIC8vIGUuZy4gPG9wdGlvbiBkaXNhYmxlZD5TZWxlY3Qgb25lPC9vcHRpb24+XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwga2V5KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKGtleSwgaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkgfHwgdmFsdWUgPT09ICdmYWxzZScgPyAnZmFsc2UnIDogJ3RydWUnKTtcbiAgfSBlbHNlIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlTlMoeGxpbmtOUywga2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGF0dHJzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUF0dHJzLFxuICB1cGRhdGU6IHVwZGF0ZUF0dHJzXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQ2xhc3MgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuICBpZiAoXG4gICAgaXNVbmRlZihkYXRhLnN0YXRpY0NsYXNzKSAmJlxuICAgIGlzVW5kZWYoZGF0YS5jbGFzcykgJiYgKFxuICAgICAgaXNVbmRlZihvbGREYXRhKSB8fCAoXG4gICAgICAgIGlzVW5kZWYob2xkRGF0YS5zdGF0aWNDbGFzcykgJiZcbiAgICAgICAgaXNVbmRlZihvbGREYXRhLmNsYXNzKVxuICAgICAgKVxuICAgIClcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY2xzID0gZ2VuQ2xhc3NGb3JWbm9kZSh2bm9kZSk7XG5cbiAgLy8gaGFuZGxlIHRyYW5zaXRpb24gY2xhc3Nlc1xuICB2YXIgdHJhbnNpdGlvbkNsYXNzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzO1xuICBpZiAoaXNEZWYodHJhbnNpdGlvbkNsYXNzKSkge1xuICAgIGNscyA9IGNvbmNhdChjbHMsIHN0cmluZ2lmeUNsYXNzKHRyYW5zaXRpb25DbGFzcykpO1xuICB9XG5cbiAgLy8gc2V0IHRoZSBjbGFzc1xuICBpZiAoY2xzICE9PSBlbC5fcHJldkNsYXNzKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNscyk7XG4gICAgZWwuX3ByZXZDbGFzcyA9IGNscztcbiAgfVxufVxuXG52YXIga2xhc3MgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQ2xhc3MsXG4gIHVwZGF0ZTogdXBkYXRlQ2xhc3Ncbn07XG5cbi8qICAqL1xuXG52YXIgdmFsaWREaXZpc2lvbkNoYXJSRSA9IC9bXFx3KS4rXFwtXyRcXF1dLztcblxuZnVuY3Rpb24gcGFyc2VGaWx0ZXJzIChleHApIHtcbiAgdmFyIGluU2luZ2xlID0gZmFsc2U7XG4gIHZhciBpbkRvdWJsZSA9IGZhbHNlO1xuICB2YXIgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlO1xuICB2YXIgaW5SZWdleCA9IGZhbHNlO1xuICB2YXIgY3VybHkgPSAwO1xuICB2YXIgc3F1YXJlID0gMDtcbiAgdmFyIHBhcmVuID0gMDtcbiAgdmFyIGxhc3RGaWx0ZXJJbmRleCA9IDA7XG4gIHZhciBjLCBwcmV2LCBpLCBleHByZXNzaW9uLCBmaWx0ZXJzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBleHAubGVuZ3RoOyBpKyspIHtcbiAgICBwcmV2ID0gYztcbiAgICBjID0gZXhwLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGluU2luZ2xlKSB7XG4gICAgICBpZiAoYyA9PT0gMHgyNyAmJiBwcmV2ICE9PSAweDVDKSB7IGluU2luZ2xlID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKGluRG91YmxlKSB7XG4gICAgICBpZiAoYyA9PT0gMHgyMiAmJiBwcmV2ICE9PSAweDVDKSB7IGluRG91YmxlID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKGluVGVtcGxhdGVTdHJpbmcpIHtcbiAgICAgIGlmIChjID09PSAweDYwICYmIHByZXYgIT09IDB4NUMpIHsgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChpblJlZ2V4KSB7XG4gICAgICBpZiAoYyA9PT0gMHgyZiAmJiBwcmV2ICE9PSAweDVDKSB7IGluUmVnZXggPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBjID09PSAweDdDICYmIC8vIHBpcGVcbiAgICAgIGV4cC5jaGFyQ29kZUF0KGkgKyAxKSAhPT0gMHg3QyAmJlxuICAgICAgZXhwLmNoYXJDb2RlQXQoaSAtIDEpICE9PSAweDdDICYmXG4gICAgICAhY3VybHkgJiYgIXNxdWFyZSAmJiAhcGFyZW5cbiAgICApIHtcbiAgICAgIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gZmlyc3QgZmlsdGVyLCBlbmQgb2YgZXhwcmVzc2lvblxuICAgICAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcbiAgICAgICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwdXNoRmlsdGVyKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICBjYXNlIDB4MjI6IGluRG91YmxlID0gdHJ1ZTsgYnJlYWsgICAgICAgICAvLyBcIlxuICAgICAgICBjYXNlIDB4Mjc6IGluU2luZ2xlID0gdHJ1ZTsgYnJlYWsgICAgICAgICAvLyAnXG4gICAgICAgIGNhc2UgMHg2MDogaW5UZW1wbGF0ZVN0cmluZyA9IHRydWU7IGJyZWFrIC8vIGBcbiAgICAgICAgY2FzZSAweDI4OiBwYXJlbisrOyBicmVhayAgICAgICAgICAgICAgICAgLy8gKFxuICAgICAgICBjYXNlIDB4Mjk6IHBhcmVuLS07IGJyZWFrICAgICAgICAgICAgICAgICAvLyApXG4gICAgICAgIGNhc2UgMHg1Qjogc3F1YXJlKys7IGJyZWFrICAgICAgICAgICAgICAgIC8vIFtcbiAgICAgICAgY2FzZSAweDVEOiBzcXVhcmUtLTsgYnJlYWsgICAgICAgICAgICAgICAgLy8gXVxuICAgICAgICBjYXNlIDB4N0I6IGN1cmx5Kys7IGJyZWFrICAgICAgICAgICAgICAgICAvLyB7XG4gICAgICAgIGNhc2UgMHg3RDogY3VybHktLTsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgIH1cbiAgICAgIGlmIChjID09PSAweDJmKSB7IC8vIC9cbiAgICAgICAgdmFyIGogPSBpIC0gMTtcbiAgICAgICAgdmFyIHAgPSAodm9pZCAwKTtcbiAgICAgICAgLy8gZmluZCBmaXJzdCBub24td2hpdGVzcGFjZSBwcmV2IGNoYXJcbiAgICAgICAgZm9yICg7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgcCA9IGV4cC5jaGFyQXQoaik7XG4gICAgICAgICAgaWYgKHAgIT09ICcgJykgeyBicmVhayB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwIHx8ICF2YWxpZERpdmlzaW9uQ2hhclJFLnRlc3QocCkpIHtcbiAgICAgICAgICBpblJlZ2V4ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgfSBlbHNlIGlmIChsYXN0RmlsdGVySW5kZXggIT09IDApIHtcbiAgICBwdXNoRmlsdGVyKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoRmlsdGVyICgpIHtcbiAgICAoZmlsdGVycyB8fCAoZmlsdGVycyA9IFtdKSkucHVzaChleHAuc2xpY2UobGFzdEZpbHRlckluZGV4LCBpKS50cmltKCkpO1xuICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xuICB9XG5cbiAgaWYgKGZpbHRlcnMpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgZXhwcmVzc2lvbiA9IHdyYXBGaWx0ZXIoZXhwcmVzc2lvbiwgZmlsdGVyc1tpXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV4cHJlc3Npb25cbn1cblxuZnVuY3Rpb24gd3JhcEZpbHRlciAoZXhwLCBmaWx0ZXIpIHtcbiAgdmFyIGkgPSBmaWx0ZXIuaW5kZXhPZignKCcpO1xuICBpZiAoaSA8IDApIHtcbiAgICAvLyBfZjogcmVzb2x2ZUZpbHRlclxuICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBmaWx0ZXIgKyBcIlxcXCIpKFwiICsgZXhwICsgXCIpXCIpXG4gIH0gZWxzZSB7XG4gICAgdmFyIG5hbWUgPSBmaWx0ZXIuc2xpY2UoMCwgaSk7XG4gICAgdmFyIGFyZ3MgPSBmaWx0ZXIuc2xpY2UoaSArIDEpO1xuICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBuYW1lICsgXCJcXFwiKShcIiArIGV4cCArIFwiLFwiICsgYXJncylcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmFzZVdhcm4gKG1zZykge1xuICBjb25zb2xlLmVycm9yKChcIltWdWUgY29tcGlsZXJdOiBcIiArIG1zZykpO1xufVxuXG5mdW5jdGlvbiBwbHVja01vZHVsZUZ1bmN0aW9uIChcbiAgbW9kdWxlcyxcbiAga2V5XG4pIHtcbiAgcmV0dXJuIG1vZHVsZXNcbiAgICA/IG1vZHVsZXMubWFwKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtW2tleV07IH0pLmZpbHRlcihmdW5jdGlvbiAoXykgeyByZXR1cm4gXzsgfSlcbiAgICA6IFtdXG59XG5cbmZ1bmN0aW9uIGFkZFByb3AgKGVsLCBuYW1lLCB2YWx1ZSkge1xuICAoZWwucHJvcHMgfHwgKGVsLnByb3BzID0gW10pKS5wdXNoKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRBdHRyIChlbCwgbmFtZSwgdmFsdWUpIHtcbiAgKGVsLmF0dHJzIHx8IChlbC5hdHRycyA9IFtdKSkucHVzaCh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9KTtcbn1cblxuZnVuY3Rpb24gYWRkRGlyZWN0aXZlIChcbiAgZWwsXG4gIG5hbWUsXG4gIHJhd05hbWUsXG4gIHZhbHVlLFxuICBhcmcsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIChlbC5kaXJlY3RpdmVzIHx8IChlbC5kaXJlY3RpdmVzID0gW10pKS5wdXNoKHsgbmFtZTogbmFtZSwgcmF3TmFtZTogcmF3TmFtZSwgdmFsdWU6IHZhbHVlLCBhcmc6IGFyZywgbW9kaWZpZXJzOiBtb2RpZmllcnMgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZEhhbmRsZXIgKFxuICBlbCxcbiAgbmFtZSxcbiAgdmFsdWUsXG4gIG1vZGlmaWVycyxcbiAgaW1wb3J0YW50LFxuICB3YXJuXG4pIHtcbiAgLy8gd2FybiBwcmV2ZW50IGFuZCBwYXNzaXZlIG1vZGlmaWVyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoXG4gICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiAmJlxuICAgIG1vZGlmaWVycyAmJiBtb2RpZmllcnMucHJldmVudCAmJiBtb2RpZmllcnMucGFzc2l2ZVxuICApIHtcbiAgICB3YXJuKFxuICAgICAgJ3Bhc3NpdmUgYW5kIHByZXZlbnQgY2FuXFwndCBiZSB1c2VkIHRvZ2V0aGVyLiAnICtcbiAgICAgICdQYXNzaXZlIGhhbmRsZXIgY2FuXFwndCBwcmV2ZW50IGRlZmF1bHQgZXZlbnQuJ1xuICAgICk7XG4gIH1cbiAgLy8gY2hlY2sgY2FwdHVyZSBtb2RpZmllclxuICBpZiAobW9kaWZpZXJzICYmIG1vZGlmaWVycy5jYXB0dXJlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5jYXB0dXJlO1xuICAgIG5hbWUgPSAnIScgKyBuYW1lOyAvLyBtYXJrIHRoZSBldmVudCBhcyBjYXB0dXJlZFxuICB9XG4gIGlmIChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm9uY2UpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLm9uY2U7XG4gICAgbmFtZSA9ICd+JyArIG5hbWU7IC8vIG1hcmsgdGhlIGV2ZW50IGFzIG9uY2VcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKG1vZGlmaWVycyAmJiBtb2RpZmllcnMucGFzc2l2ZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMucGFzc2l2ZTtcbiAgICBuYW1lID0gJyYnICsgbmFtZTsgLy8gbWFyayB0aGUgZXZlbnQgYXMgcGFzc2l2ZVxuICB9XG4gIHZhciBldmVudHM7XG4gIGlmIChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm5hdGl2ZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMubmF0aXZlO1xuICAgIGV2ZW50cyA9IGVsLm5hdGl2ZUV2ZW50cyB8fCAoZWwubmF0aXZlRXZlbnRzID0ge30pO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50cyA9IGVsLmV2ZW50cyB8fCAoZWwuZXZlbnRzID0ge30pO1xuICB9XG4gIHZhciBuZXdIYW5kbGVyID0geyB2YWx1ZTogdmFsdWUsIG1vZGlmaWVyczogbW9kaWZpZXJzIH07XG4gIHZhciBoYW5kbGVycyA9IGV2ZW50c1tuYW1lXTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXJzKSkge1xuICAgIGltcG9ydGFudCA/IGhhbmRsZXJzLnVuc2hpZnQobmV3SGFuZGxlcikgOiBoYW5kbGVycy5wdXNoKG5ld0hhbmRsZXIpO1xuICB9IGVsc2UgaWYgKGhhbmRsZXJzKSB7XG4gICAgZXZlbnRzW25hbWVdID0gaW1wb3J0YW50ID8gW25ld0hhbmRsZXIsIGhhbmRsZXJzXSA6IFtoYW5kbGVycywgbmV3SGFuZGxlcl07XG4gIH0gZWxzZSB7XG4gICAgZXZlbnRzW25hbWVdID0gbmV3SGFuZGxlcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRCaW5kaW5nQXR0ciAoXG4gIGVsLFxuICBuYW1lLFxuICBnZXRTdGF0aWNcbikge1xuICB2YXIgZHluYW1pY1ZhbHVlID1cbiAgICBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnOicgKyBuYW1lKSB8fFxuICAgIGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWJpbmQ6JyArIG5hbWUpO1xuICBpZiAoZHluYW1pY1ZhbHVlICE9IG51bGwpIHtcbiAgICByZXR1cm4gcGFyc2VGaWx0ZXJzKGR5bmFtaWNWYWx1ZSlcbiAgfSBlbHNlIGlmIChnZXRTdGF0aWMgIT09IGZhbHNlKSB7XG4gICAgdmFyIHN0YXRpY1ZhbHVlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgbmFtZSk7XG4gICAgaWYgKHN0YXRpY1ZhbHVlICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzdGF0aWNWYWx1ZSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QW5kUmVtb3ZlQXR0ciAoZWwsIG5hbWUpIHtcbiAgdmFyIHZhbDtcbiAgaWYgKCh2YWwgPSBlbC5hdHRyc01hcFtuYW1lXSkgIT0gbnVsbCkge1xuICAgIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChsaXN0W2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWxcbn1cblxuLyogICovXG5cbi8qKlxuICogQ3Jvc3MtcGxhdGZvcm0gY29kZSBnZW5lcmF0aW9uIGZvciBjb21wb25lbnQgdi1tb2RlbFxuICovXG5mdW5jdGlvbiBnZW5Db21wb25lbnRNb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIHJlZiA9IG1vZGlmaWVycyB8fCB7fTtcbiAgdmFyIG51bWJlciA9IHJlZi5udW1iZXI7XG4gIHZhciB0cmltID0gcmVmLnRyaW07XG5cbiAgdmFyIGJhc2VWYWx1ZUV4cHJlc3Npb24gPSAnJCR2JztcbiAgdmFyIHZhbHVlRXhwcmVzc2lvbiA9IGJhc2VWYWx1ZUV4cHJlc3Npb247XG4gIGlmICh0cmltKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID1cbiAgICAgIFwiKHR5cGVvZiBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIiA9PT0gJ3N0cmluZydcIiArXG4gICAgICAgIFwiPyBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIi50cmltKClcIiArXG4gICAgICAgIFwiOiBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgfVxuICBpZiAobnVtYmVyKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID0gXCJfbihcIiArIHZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xuICB9XG4gIHZhciBhc3NpZ25tZW50ID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XG5cbiAgZWwubW9kZWwgPSB7XG4gICAgdmFsdWU6IChcIihcIiArIHZhbHVlICsgXCIpXCIpLFxuICAgIGV4cHJlc3Npb246IChcIlxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLFxuICAgIGNhbGxiYWNrOiAoXCJmdW5jdGlvbiAoXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIpIHtcIiArIGFzc2lnbm1lbnQgKyBcIn1cIilcbiAgfTtcbn1cblxuLyoqXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlZ2VuIGhlbHBlciBmb3IgZ2VuZXJhdGluZyB2LW1vZGVsIHZhbHVlIGFzc2lnbm1lbnQgY29kZS5cbiAqL1xuZnVuY3Rpb24gZ2VuQXNzaWdubWVudENvZGUgKFxuICB2YWx1ZSxcbiAgYXNzaWdubWVudFxuKSB7XG4gIHZhciBtb2RlbFJzID0gcGFyc2VNb2RlbCh2YWx1ZSk7XG4gIGlmIChtb2RlbFJzLmlkeCA9PT0gbnVsbCkge1xuICAgIHJldHVybiAodmFsdWUgKyBcIj1cIiArIGFzc2lnbm1lbnQpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChcIiRzZXQoXCIgKyAobW9kZWxScy5leHApICsgXCIsIFwiICsgKG1vZGVsUnMuaWR4KSArIFwiLCBcIiArIGFzc2lnbm1lbnQgKyBcIilcIilcbiAgfVxufVxuXG4vKipcbiAqIHBhcnNlIGRpcmVjdGl2ZSBtb2RlbCB0byBkbyB0aGUgYXJyYXkgdXBkYXRlIHRyYW5zZm9ybS4gYVtpZHhdID0gdmFsID0+ICQkYS5zcGxpY2UoJCRpZHgsIDEsIHZhbClcbiAqXG4gKiBmb3IgbG9vcCBwb3NzaWJsZSBjYXNlczpcbiAqXG4gKiAtIHRlc3RcbiAqIC0gdGVzdFtpZHhdXG4gKiAtIHRlc3RbdGVzdDFbaWR4XV1cbiAqIC0gdGVzdFtcImFcIl1baWR4XVxuICogLSB4eHgudGVzdFthW2FdLnRlc3QxW2lkeF1dXG4gKiAtIHRlc3QueHh4LmFbXCJhc2FcIl1bdGVzdDFbaWR4XV1cbiAqXG4gKi9cblxudmFyIGxlbjtcbnZhciBzdHI7XG52YXIgY2hyO1xudmFyIGluZGV4JDE7XG52YXIgZXhwcmVzc2lvblBvcztcbnZhciBleHByZXNzaW9uRW5kUG9zO1xuXG5mdW5jdGlvbiBwYXJzZU1vZGVsICh2YWwpIHtcbiAgc3RyID0gdmFsO1xuICBsZW4gPSBzdHIubGVuZ3RoO1xuICBpbmRleCQxID0gZXhwcmVzc2lvblBvcyA9IGV4cHJlc3Npb25FbmRQb3MgPSAwO1xuXG4gIGlmICh2YWwuaW5kZXhPZignWycpIDwgMCB8fCB2YWwubGFzdEluZGV4T2YoJ10nKSA8IGxlbiAtIDEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXhwOiB2YWwsXG4gICAgICBpZHg6IG51bGxcbiAgICB9XG4gIH1cblxuICB3aGlsZSAoIWVvZigpKSB7XG4gICAgY2hyID0gbmV4dCgpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc1N0cmluZ1N0YXJ0KGNocikpIHtcbiAgICAgIHBhcnNlU3RyaW5nKGNocik7XG4gICAgfSBlbHNlIGlmIChjaHIgPT09IDB4NUIpIHtcbiAgICAgIHBhcnNlQnJhY2tldChjaHIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZXhwOiB2YWwuc3Vic3RyaW5nKDAsIGV4cHJlc3Npb25Qb3MpLFxuICAgIGlkeDogdmFsLnN1YnN0cmluZyhleHByZXNzaW9uUG9zICsgMSwgZXhwcmVzc2lvbkVuZFBvcylcbiAgfVxufVxuXG5mdW5jdGlvbiBuZXh0ICgpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQ29kZUF0KCsraW5kZXgkMSlcbn1cblxuZnVuY3Rpb24gZW9mICgpIHtcbiAgcmV0dXJuIGluZGV4JDEgPj0gbGVuXG59XG5cbmZ1bmN0aW9uIGlzU3RyaW5nU3RhcnQgKGNocikge1xuICByZXR1cm4gY2hyID09PSAweDIyIHx8IGNociA9PT0gMHgyN1xufVxuXG5mdW5jdGlvbiBwYXJzZUJyYWNrZXQgKGNocikge1xuICB2YXIgaW5CcmFja2V0ID0gMTtcbiAgZXhwcmVzc2lvblBvcyA9IGluZGV4JDE7XG4gIHdoaWxlICghZW9mKCkpIHtcbiAgICBjaHIgPSBuZXh0KCk7XG4gICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xuICAgICAgcGFyc2VTdHJpbmcoY2hyKTtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmIChjaHIgPT09IDB4NUIpIHsgaW5CcmFja2V0Kys7IH1cbiAgICBpZiAoY2hyID09PSAweDVEKSB7IGluQnJhY2tldC0tOyB9XG4gICAgaWYgKGluQnJhY2tldCA9PT0gMCkge1xuICAgICAgZXhwcmVzc2lvbkVuZFBvcyA9IGluZGV4JDE7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZVN0cmluZyAoY2hyKSB7XG4gIHZhciBzdHJpbmdRdW90ZSA9IGNocjtcbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICBpZiAoY2hyID09PSBzdHJpbmdRdW90ZSkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciB3YXJuJDE7XG5cbi8vIGluIHNvbWUgY2FzZXMsIHRoZSBldmVudCB1c2VkIGhhcyB0byBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWVcbi8vIHNvIHdlIHVzZWQgc29tZSByZXNlcnZlZCB0b2tlbnMgZHVyaW5nIGNvbXBpbGUuXG52YXIgUkFOR0VfVE9LRU4gPSAnX19yJztcbnZhciBDSEVDS0JPWF9SQURJT19UT0tFTiA9ICdfX2MnO1xuXG5mdW5jdGlvbiBtb2RlbCAoXG4gIGVsLFxuICBkaXIsXG4gIF93YXJuXG4pIHtcbiAgd2FybiQxID0gX3dhcm47XG4gIHZhciB2YWx1ZSA9IGRpci52YWx1ZTtcbiAgdmFyIG1vZGlmaWVycyA9IGRpci5tb2RpZmllcnM7XG4gIHZhciB0YWcgPSBlbC50YWc7XG4gIHZhciB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcblxuICB7XG4gICAgdmFyIGR5bmFtaWNUeXBlID0gZWwuYXR0cnNNYXBbJ3YtYmluZDp0eXBlJ10gfHwgZWwuYXR0cnNNYXBbJzp0eXBlJ107XG4gICAgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiBkeW5hbWljVHlwZSkge1xuICAgICAgd2FybiQxKFxuICAgICAgICBcIjxpbnB1dCA6dHlwZT1cXFwiXCIgKyBkeW5hbWljVHlwZSArIFwiXFxcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiPjpcXG5cIiArXG4gICAgICAgIFwidi1tb2RlbCBkb2VzIG5vdCBzdXBwb3J0IGR5bmFtaWMgaW5wdXQgdHlwZXMuIFVzZSB2LWlmIGJyYW5jaGVzIGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIC8vIGlucHV0cyB3aXRoIHR5cGU9XCJmaWxlXCIgYXJlIHJlYWQgb25seSBhbmQgc2V0dGluZyB0aGUgaW5wdXQnc1xuICAgIC8vIHZhbHVlIHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gICAgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAnZmlsZScpIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCIgdHlwZT1cXFwiZmlsZVxcXCI+OlxcblwiICtcbiAgICAgICAgXCJGaWxlIGlucHV0cyBhcmUgcmVhZCBvbmx5LiBVc2UgYSB2LW9uOmNoYW5nZSBsaXN0ZW5lciBpbnN0ZWFkLlwiXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICBnZW5Db21wb25lbnRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gICAgLy8gY29tcG9uZW50IHYtbW9kZWwgZG9lc24ndCBuZWVkIGV4dHJhIHJ1bnRpbWVcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgZ2VuU2VsZWN0KGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ2NoZWNrYm94Jykge1xuICAgIGdlbkNoZWNrYm94TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAncmFkaW8nKSB7XG4gICAgZ2VuUmFkaW9Nb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnIHx8IHRhZyA9PT0gJ3RleHRhcmVhJykge1xuICAgIGdlbkRlZmF1bHRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAoIWNvbmZpZy5pc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICBnZW5Db21wb25lbnRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gICAgLy8gY29tcG9uZW50IHYtbW9kZWwgZG9lc24ndCBuZWVkIGV4dHJhIHJ1bnRpbWVcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIHtcbiAgICB3YXJuJDEoXG4gICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIj46IFwiICtcbiAgICAgIFwidi1tb2RlbCBpcyBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgZWxlbWVudCB0eXBlLiBcIiArXG4gICAgICAnSWYgeW91IGFyZSB3b3JraW5nIHdpdGggY29udGVudGVkaXRhYmxlLCBpdFxcJ3MgcmVjb21tZW5kZWQgdG8gJyArXG4gICAgICAnd3JhcCBhIGxpYnJhcnkgZGVkaWNhdGVkIGZvciB0aGF0IHB1cnBvc2UgaW5zaWRlIGEgY3VzdG9tIGNvbXBvbmVudC4nXG4gICAgKTtcbiAgfVxuXG4gIC8vIGVuc3VyZSBydW50aW1lIGRpcmVjdGl2ZSBtZXRhZGF0YVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBnZW5DaGVja2JveE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIHZhciB2YWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3ZhbHVlJykgfHwgJ251bGwnO1xuICB2YXIgdHJ1ZVZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndHJ1ZS12YWx1ZScpIHx8ICd0cnVlJztcbiAgdmFyIGZhbHNlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdmYWxzZS12YWx1ZScpIHx8ICdmYWxzZSc7XG4gIGFkZFByb3AoZWwsICdjaGVja2VkJyxcbiAgICBcIkFycmF5LmlzQXJyYXkoXCIgKyB2YWx1ZSArIFwiKVwiICtcbiAgICAgIFwiP19pKFwiICsgdmFsdWUgKyBcIixcIiArIHZhbHVlQmluZGluZyArIFwiKT4tMVwiICsgKFxuICAgICAgICB0cnVlVmFsdWVCaW5kaW5nID09PSAndHJ1ZSdcbiAgICAgICAgICA/IChcIjooXCIgKyB2YWx1ZSArIFwiKVwiKVxuICAgICAgICAgIDogKFwiOl9xKFwiICsgdmFsdWUgKyBcIixcIiArIHRydWVWYWx1ZUJpbmRpbmcgKyBcIilcIilcbiAgICAgIClcbiAgKTtcbiAgYWRkSGFuZGxlcihlbCwgQ0hFQ0tCT1hfUkFESU9fVE9LRU4sXG4gICAgXCJ2YXIgJCRhPVwiICsgdmFsdWUgKyBcIixcIiArXG4gICAgICAgICckJGVsPSRldmVudC50YXJnZXQsJyArXG4gICAgICAgIFwiJCRjPSQkZWwuY2hlY2tlZD8oXCIgKyB0cnVlVmFsdWVCaW5kaW5nICsgXCIpOihcIiArIGZhbHNlVmFsdWVCaW5kaW5nICsgXCIpO1wiICtcbiAgICAnaWYoQXJyYXkuaXNBcnJheSgkJGEpKXsnICtcbiAgICAgIFwidmFyICQkdj1cIiArIChudW1iZXIgPyAnX24oJyArIHZhbHVlQmluZGluZyArICcpJyA6IHZhbHVlQmluZGluZykgKyBcIixcIiArXG4gICAgICAgICAgJyQkaT1faSgkJGEsJCR2KTsnICtcbiAgICAgIFwiaWYoJCRjKXskJGk8MCYmKFwiICsgdmFsdWUgKyBcIj0kJGEuY29uY2F0KCQkdikpfVwiICtcbiAgICAgIFwiZWxzZXskJGk+LTEmJihcIiArIHZhbHVlICsgXCI9JCRhLnNsaWNlKDAsJCRpKS5jb25jYXQoJCRhLnNsaWNlKCQkaSsxKSkpfVwiICtcbiAgICBcIn1lbHNle1wiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCAnJCRjJykpICsgXCJ9XCIsXG4gICAgbnVsbCwgdHJ1ZVxuICApO1xufVxuXG5mdW5jdGlvbiBnZW5SYWRpb01vZGVsIChcbiAgICBlbCxcbiAgICB2YWx1ZSxcbiAgICBtb2RpZmllcnNcbikge1xuICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIHZhciB2YWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3ZhbHVlJykgfHwgJ251bGwnO1xuICB2YWx1ZUJpbmRpbmcgPSBudW1iZXIgPyAoXCJfbihcIiArIHZhbHVlQmluZGluZyArIFwiKVwiKSA6IHZhbHVlQmluZGluZztcbiAgYWRkUHJvcChlbCwgJ2NoZWNrZWQnLCAoXCJfcShcIiArIHZhbHVlICsgXCIsXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIilcIikpO1xuICBhZGRIYW5kbGVyKGVsLCBDSEVDS0JPWF9SQURJT19UT0tFTiwgZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlQmluZGluZyksIG51bGwsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBnZW5TZWxlY3QgKFxuICAgIGVsLFxuICAgIHZhbHVlLFxuICAgIG1vZGlmaWVyc1xuKSB7XG4gIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgdmFyIHNlbGVjdGVkVmFsID0gXCJBcnJheS5wcm90b3R5cGUuZmlsdGVyXCIgK1xuICAgIFwiLmNhbGwoJGV2ZW50LnRhcmdldC5vcHRpb25zLGZ1bmN0aW9uKG8pe3JldHVybiBvLnNlbGVjdGVkfSlcIiArXG4gICAgXCIubWFwKGZ1bmN0aW9uKG8pe3ZhciB2YWwgPSBcXFwiX3ZhbHVlXFxcIiBpbiBvID8gby5fdmFsdWUgOiBvLnZhbHVlO1wiICtcbiAgICBcInJldHVybiBcIiArIChudW1iZXIgPyAnX24odmFsKScgOiAndmFsJykgKyBcIn0pXCI7XG5cbiAgdmFyIGFzc2lnbm1lbnQgPSAnJGV2ZW50LnRhcmdldC5tdWx0aXBsZSA/ICQkc2VsZWN0ZWRWYWwgOiAkJHNlbGVjdGVkVmFsWzBdJztcbiAgdmFyIGNvZGUgPSBcInZhciAkJHNlbGVjdGVkVmFsID0gXCIgKyBzZWxlY3RlZFZhbCArIFwiO1wiO1xuICBjb2RlID0gY29kZSArIFwiIFwiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCBhc3NpZ25tZW50KSk7XG4gIGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLCBjb2RlLCBudWxsLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gZ2VuRGVmYXVsdE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgdHlwZSA9IGVsLmF0dHJzTWFwLnR5cGU7XG4gIHZhciByZWYgPSBtb2RpZmllcnMgfHwge307XG4gIHZhciBsYXp5ID0gcmVmLmxhenk7XG4gIHZhciBudW1iZXIgPSByZWYubnVtYmVyO1xuICB2YXIgdHJpbSA9IHJlZi50cmltO1xuICB2YXIgbmVlZENvbXBvc2l0aW9uR3VhcmQgPSAhbGF6eSAmJiB0eXBlICE9PSAncmFuZ2UnO1xuICB2YXIgZXZlbnQgPSBsYXp5XG4gICAgPyAnY2hhbmdlJ1xuICAgIDogdHlwZSA9PT0gJ3JhbmdlJ1xuICAgICAgPyBSQU5HRV9UT0tFTlxuICAgICAgOiAnaW5wdXQnO1xuXG4gIHZhciB2YWx1ZUV4cHJlc3Npb24gPSAnJGV2ZW50LnRhcmdldC52YWx1ZSc7XG4gIGlmICh0cmltKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID0gXCIkZXZlbnQudGFyZ2V0LnZhbHVlLnRyaW0oKVwiO1xuICB9XG4gIGlmIChudW1iZXIpIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIl9uKFwiICsgdmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XG4gIH1cblxuICB2YXIgY29kZSA9IGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUV4cHJlc3Npb24pO1xuICBpZiAobmVlZENvbXBvc2l0aW9uR3VhcmQpIHtcbiAgICBjb2RlID0gXCJpZigkZXZlbnQudGFyZ2V0LmNvbXBvc2luZylyZXR1cm47XCIgKyBjb2RlO1xuICB9XG5cbiAgYWRkUHJvcChlbCwgJ3ZhbHVlJywgKFwiKFwiICsgdmFsdWUgKyBcIilcIikpO1xuICBhZGRIYW5kbGVyKGVsLCBldmVudCwgY29kZSwgbnVsbCwgdHJ1ZSk7XG4gIGlmICh0cmltIHx8IG51bWJlcikge1xuICAgIGFkZEhhbmRsZXIoZWwsICdibHVyJywgJyRmb3JjZVVwZGF0ZSgpJyk7XG4gIH1cbn1cblxuLyogICovXG5cbi8vIG5vcm1hbGl6ZSB2LW1vZGVsIGV2ZW50IHRva2VucyB0aGF0IGNhbiBvbmx5IGJlIGRldGVybWluZWQgYXQgcnVudGltZS5cbi8vIGl0J3MgaW1wb3J0YW50IHRvIHBsYWNlIHRoZSBldmVudCBhcyB0aGUgZmlyc3QgaW4gdGhlIGFycmF5IGJlY2F1c2Vcbi8vIHRoZSB3aG9sZSBwb2ludCBpcyBlbnN1cmluZyB0aGUgdi1tb2RlbCBjYWxsYmFjayBnZXRzIGNhbGxlZCBiZWZvcmVcbi8vIHVzZXItYXR0YWNoZWQgaGFuZGxlcnMuXG5mdW5jdGlvbiBub3JtYWxpemVFdmVudHMgKG9uKSB7XG4gIHZhciBldmVudDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihvbltSQU5HRV9UT0tFTl0pKSB7XG4gICAgLy8gSUUgaW5wdXRbdHlwZT1yYW5nZV0gb25seSBzdXBwb3J0cyBgY2hhbmdlYCBldmVudFxuICAgIGV2ZW50ID0gaXNJRSA/ICdjaGFuZ2UnIDogJ2lucHV0JztcbiAgICBvbltldmVudF0gPSBbXS5jb25jYXQob25bUkFOR0VfVE9LRU5dLCBvbltldmVudF0gfHwgW10pO1xuICAgIGRlbGV0ZSBvbltSQU5HRV9UT0tFTl07XG4gIH1cbiAgaWYgKGlzRGVmKG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSkpIHtcbiAgICAvLyBDaHJvbWUgZmlyZXMgbWljcm90YXNrcyBpbiBiZXR3ZWVuIGNsaWNrL2NoYW5nZSwgbGVhZHMgdG8gIzQ1MjFcbiAgICBldmVudCA9IGlzQ2hyb21lID8gJ2NsaWNrJyA6ICdjaGFuZ2UnO1xuICAgIG9uW2V2ZW50XSA9IFtdLmNvbmNhdChvbltDSEVDS0JPWF9SQURJT19UT0tFTl0sIG9uW2V2ZW50XSB8fCBbXSk7XG4gICAgZGVsZXRlIG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXTtcbiAgfVxufVxuXG52YXIgdGFyZ2V0JDE7XG5cbmZ1bmN0aW9uIGFkZCQxIChcbiAgZXZlbnQsXG4gIGhhbmRsZXIsXG4gIG9uY2UkJDEsXG4gIGNhcHR1cmUsXG4gIHBhc3NpdmVcbikge1xuICBpZiAob25jZSQkMSkge1xuICAgIHZhciBvbGRIYW5kbGVyID0gaGFuZGxlcjtcbiAgICB2YXIgX3RhcmdldCA9IHRhcmdldCQxOyAvLyBzYXZlIGN1cnJlbnQgdGFyZ2V0IGVsZW1lbnQgaW4gY2xvc3VyZVxuICAgIGhhbmRsZXIgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgIHZhciByZXMgPSBhcmd1bWVudHMubGVuZ3RoID09PSAxXG4gICAgICAgID8gb2xkSGFuZGxlcihldilcbiAgICAgICAgOiBvbGRIYW5kbGVyLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAocmVzICE9PSBudWxsKSB7XG4gICAgICAgIHJlbW92ZSQyKGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlLCBfdGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHRhcmdldCQxLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgZXZlbnQsXG4gICAgaGFuZGxlcixcbiAgICBzdXBwb3J0c1Bhc3NpdmVcbiAgICAgID8geyBjYXB0dXJlOiBjYXB0dXJlLCBwYXNzaXZlOiBwYXNzaXZlIH1cbiAgICAgIDogY2FwdHVyZVxuICApO1xufVxuXG5mdW5jdGlvbiByZW1vdmUkMiAoXG4gIGV2ZW50LFxuICBoYW5kbGVyLFxuICBjYXB0dXJlLFxuICBfdGFyZ2V0XG4pIHtcbiAgKF90YXJnZXQgfHwgdGFyZ2V0JDEpLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIGNhcHR1cmUpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVET01MaXN0ZW5lcnMgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgaXNDb21wb25lbnRSb290ID0gaXNEZWYodm5vZGUuY29tcG9uZW50T3B0aW9ucyk7XG4gIHZhciBvbGRPbiA9IGlzQ29tcG9uZW50Um9vdCA/IG9sZFZub2RlLmRhdGEubmF0aXZlT24gOiBvbGRWbm9kZS5kYXRhLm9uO1xuICB2YXIgb24gPSBpc0NvbXBvbmVudFJvb3QgPyB2bm9kZS5kYXRhLm5hdGl2ZU9uIDogdm5vZGUuZGF0YS5vbjtcbiAgaWYgKGlzVW5kZWYob2xkT24pICYmIGlzVW5kZWYob24pKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgb24gPSBvbiB8fCB7fTtcbiAgb2xkT24gPSBvbGRPbiB8fCB7fTtcbiAgdGFyZ2V0JDEgPSB2bm9kZS5lbG07XG4gIG5vcm1hbGl6ZUV2ZW50cyhvbik7XG4gIHVwZGF0ZUxpc3RlbmVycyhvbiwgb2xkT24sIGFkZCQxLCByZW1vdmUkMiwgdm5vZGUuY29udGV4dCk7XG59XG5cbnZhciBldmVudHMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzLFxuICB1cGRhdGU6IHVwZGF0ZURPTUxpc3RlbmVyc1xufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZURPTVByb3BzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5kb21Qcm9wcykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmRvbVByb3BzKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBrZXksIGN1cjtcbiAgdmFyIGVsbSA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZFByb3BzID0gb2xkVm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgdmFyIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gIGlmIChpc0RlZihwcm9wcy5fX29iX18pKSB7XG4gICAgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzID0gZXh0ZW5kKHt9LCBwcm9wcyk7XG4gIH1cblxuICBmb3IgKGtleSBpbiBvbGRQcm9wcykge1xuICAgIGlmIChpc1VuZGVmKHByb3BzW2tleV0pKSB7XG4gICAgICBlbG1ba2V5XSA9ICcnO1xuICAgIH1cbiAgfVxuICBmb3IgKGtleSBpbiBwcm9wcykge1xuICAgIGN1ciA9IHByb3BzW2tleV07XG4gICAgLy8gaWdub3JlIGNoaWxkcmVuIGlmIHRoZSBub2RlIGhhcyB0ZXh0Q29udGVudCBvciBpbm5lckhUTUwsXG4gICAgLy8gYXMgdGhlc2Ugd2lsbCB0aHJvdyBhd2F5IGV4aXN0aW5nIERPTSBub2RlcyBhbmQgY2F1c2UgcmVtb3ZhbCBlcnJvcnNcbiAgICAvLyBvbiBzdWJzZXF1ZW50IHBhdGNoZXMgKCMzMzYwKVxuICAgIGlmIChrZXkgPT09ICd0ZXh0Q29udGVudCcgfHwga2V5ID09PSAnaW5uZXJIVE1MJykge1xuICAgICAgaWYgKHZub2RlLmNoaWxkcmVuKSB7IHZub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7IH1cbiAgICAgIGlmIChjdXIgPT09IG9sZFByb3BzW2tleV0pIHsgY29udGludWUgfVxuICAgIH1cblxuICAgIGlmIChrZXkgPT09ICd2YWx1ZScpIHtcbiAgICAgIC8vIHN0b3JlIHZhbHVlIGFzIF92YWx1ZSBhcyB3ZWxsIHNpbmNlXG4gICAgICAvLyBub24tc3RyaW5nIHZhbHVlcyB3aWxsIGJlIHN0cmluZ2lmaWVkXG4gICAgICBlbG0uX3ZhbHVlID0gY3VyO1xuICAgICAgLy8gYXZvaWQgcmVzZXR0aW5nIGN1cnNvciBwb3NpdGlvbiB3aGVuIHZhbHVlIGlzIHRoZSBzYW1lXG4gICAgICB2YXIgc3RyQ3VyID0gaXNVbmRlZihjdXIpID8gJycgOiBTdHJpbmcoY3VyKTtcbiAgICAgIGlmIChzaG91bGRVcGRhdGVWYWx1ZShlbG0sIHZub2RlLCBzdHJDdXIpKSB7XG4gICAgICAgIGVsbS52YWx1ZSA9IHN0ckN1cjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWxtW2tleV0gPSBjdXI7XG4gICAgfVxuICB9XG59XG5cbi8vIGNoZWNrIHBsYXRmb3Jtcy93ZWIvdXRpbC9hdHRycy5qcyBhY2NlcHRWYWx1ZVxuXG5cbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZVZhbHVlIChcbiAgZWxtLFxuICB2bm9kZSxcbiAgY2hlY2tWYWxcbikge1xuICByZXR1cm4gKCFlbG0uY29tcG9zaW5nICYmIChcbiAgICB2bm9kZS50YWcgPT09ICdvcHRpb24nIHx8XG4gICAgaXNEaXJ0eShlbG0sIGNoZWNrVmFsKSB8fFxuICAgIGlzSW5wdXRDaGFuZ2VkKGVsbSwgY2hlY2tWYWwpXG4gICkpXG59XG5cbmZ1bmN0aW9uIGlzRGlydHkgKGVsbSwgY2hlY2tWYWwpIHtcbiAgLy8gcmV0dXJuIHRydWUgd2hlbiB0ZXh0Ym94ICgubnVtYmVyIGFuZCAudHJpbSkgbG9zZXMgZm9jdXMgYW5kIGl0cyB2YWx1ZSBpc1xuICAvLyBub3QgZXF1YWwgdG8gdGhlIHVwZGF0ZWQgdmFsdWVcbiAgcmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IGVsbSAmJiBlbG0udmFsdWUgIT09IGNoZWNrVmFsXG59XG5cbmZ1bmN0aW9uIGlzSW5wdXRDaGFuZ2VkIChlbG0sIG5ld1ZhbCkge1xuICB2YXIgdmFsdWUgPSBlbG0udmFsdWU7XG4gIHZhciBtb2RpZmllcnMgPSBlbG0uX3ZNb2RpZmllcnM7IC8vIGluamVjdGVkIGJ5IHYtbW9kZWwgcnVudGltZVxuICBpZiAoaXNEZWYobW9kaWZpZXJzKSAmJiBtb2RpZmllcnMubnVtYmVyKSB7XG4gICAgcmV0dXJuIHRvTnVtYmVyKHZhbHVlKSAhPT0gdG9OdW1iZXIobmV3VmFsKVxuICB9XG4gIGlmIChpc0RlZihtb2RpZmllcnMpICYmIG1vZGlmaWVycy50cmltKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRyaW0oKSAhPT0gbmV3VmFsLnRyaW0oKVxuICB9XG4gIHJldHVybiB2YWx1ZSAhPT0gbmV3VmFsXG59XG5cbnZhciBkb21Qcm9wcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01Qcm9wcyxcbiAgdXBkYXRlOiB1cGRhdGVET01Qcm9wc1xufTtcblxuLyogICovXG5cbnZhciBwYXJzZVN0eWxlVGV4dCA9IGNhY2hlZChmdW5jdGlvbiAoY3NzVGV4dCkge1xuICB2YXIgcmVzID0ge307XG4gIHZhciBsaXN0RGVsaW1pdGVyID0gLzsoPyFbXihdKlxcKSkvZztcbiAgdmFyIHByb3BlcnR5RGVsaW1pdGVyID0gLzooLispLztcbiAgY3NzVGV4dC5zcGxpdChsaXN0RGVsaW1pdGVyKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIHZhciB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyKTtcbiAgICAgIHRtcC5sZW5ndGggPiAxICYmIChyZXNbdG1wWzBdLnRyaW0oKV0gPSB0bXBbMV0udHJpbSgpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzXG59KTtcblxuLy8gbWVyZ2Ugc3RhdGljIGFuZCBkeW5hbWljIHN0eWxlIGRhdGEgb24gdGhlIHNhbWUgdm5vZGVcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlRGF0YSAoZGF0YSkge1xuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcoZGF0YS5zdHlsZSk7XG4gIC8vIHN0YXRpYyBzdHlsZSBpcyBwcmUtcHJvY2Vzc2VkIGludG8gYW4gb2JqZWN0IGR1cmluZyBjb21waWxhdGlvblxuICAvLyBhbmQgaXMgYWx3YXlzIGEgZnJlc2ggb2JqZWN0LCBzbyBpdCdzIHNhZmUgdG8gbWVyZ2UgaW50byBpdFxuICByZXR1cm4gZGF0YS5zdGF0aWNTdHlsZVxuICAgID8gZXh0ZW5kKGRhdGEuc3RhdGljU3R5bGUsIHN0eWxlKVxuICAgIDogc3R5bGVcbn1cblxuLy8gbm9ybWFsaXplIHBvc3NpYmxlIGFycmF5IC8gc3RyaW5nIHZhbHVlcyBpbnRvIE9iamVjdFxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVCaW5kaW5nIChiaW5kaW5nU3R5bGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYmluZGluZ1N0eWxlKSkge1xuICAgIHJldHVybiB0b09iamVjdChiaW5kaW5nU3R5bGUpXG4gIH1cbiAgaWYgKHR5cGVvZiBiaW5kaW5nU3R5bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhcnNlU3R5bGVUZXh0KGJpbmRpbmdTdHlsZSlcbiAgfVxuICByZXR1cm4gYmluZGluZ1N0eWxlXG59XG5cbi8qKlxuICogcGFyZW50IGNvbXBvbmVudCBzdHlsZSBzaG91bGQgYmUgYWZ0ZXIgY2hpbGQnc1xuICogc28gdGhhdCBwYXJlbnQgY29tcG9uZW50J3Mgc3R5bGUgY291bGQgb3ZlcnJpZGUgaXRcbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGUgKHZub2RlLCBjaGVja0NoaWxkKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIHN0eWxlRGF0YTtcblxuICBpZiAoY2hlY2tDaGlsZCkge1xuICAgIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKGNoaWxkTm9kZS5kYXRhICYmIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEoY2hpbGROb2RlLmRhdGEpKSkge1xuICAgICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICgoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHZub2RlLmRhdGEpKSkge1xuICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gIH1cblxuICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xuICB3aGlsZSAoKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICBpZiAocGFyZW50Tm9kZS5kYXRhICYmIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEocGFyZW50Tm9kZS5kYXRhKSkpIHtcbiAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBjc3NWYXJSRSA9IC9eLS0vO1xudmFyIGltcG9ydGFudFJFID0gL1xccyohaW1wb3J0YW50JC87XG52YXIgc2V0UHJvcCA9IGZ1bmN0aW9uIChlbCwgbmFtZSwgdmFsKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoY3NzVmFyUkUudGVzdChuYW1lKSkge1xuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbCk7XG4gIH0gZWxzZSBpZiAoaW1wb3J0YW50UkUudGVzdCh2YWwpKSB7XG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsLnJlcGxhY2UoaW1wb3J0YW50UkUsICcnKSwgJ2ltcG9ydGFudCcpO1xuICB9IGVsc2Uge1xuICAgIHZhciBub3JtYWxpemVkTmFtZSA9IG5vcm1hbGl6ZShuYW1lKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAvLyBTdXBwb3J0IHZhbHVlcyBhcnJheSBjcmVhdGVkIGJ5IGF1dG9wcmVmaXhlciwgZS5nLlxuICAgICAgLy8ge2Rpc3BsYXk6IFtcIi13ZWJraXQtYm94XCIsIFwiLW1zLWZsZXhib3hcIiwgXCJmbGV4XCJdfVxuICAgICAgLy8gU2V0IHRoZW0gb25lIGJ5IG9uZSwgYW5kIHRoZSBicm93c2VyIHdpbGwgb25seSBzZXQgdGhvc2UgaXQgY2FuIHJlY29nbml6ZVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHZhbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWxbaV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlW25vcm1hbGl6ZWROYW1lXSA9IHZhbDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciB2ZW5kb3JOYW1lcyA9IFsnV2Via2l0JywgJ01veicsICdtcyddO1xuXG52YXIgZW1wdHlTdHlsZTtcbnZhciBub3JtYWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHByb3ApIHtcbiAgZW1wdHlTdHlsZSA9IGVtcHR5U3R5bGUgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG4gIHByb3AgPSBjYW1lbGl6ZShwcm9wKTtcbiAgaWYgKHByb3AgIT09ICdmaWx0ZXInICYmIChwcm9wIGluIGVtcHR5U3R5bGUpKSB7XG4gICAgcmV0dXJuIHByb3BcbiAgfVxuICB2YXIgY2FwTmFtZSA9IHByb3AuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wLnNsaWNlKDEpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHZlbmRvck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5hbWUgPSB2ZW5kb3JOYW1lc1tpXSArIGNhcE5hbWU7XG4gICAgaWYgKG5hbWUgaW4gZW1wdHlTdHlsZSkge1xuICAgICAgcmV0dXJuIG5hbWVcbiAgICB9XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiB1cGRhdGVTdHlsZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuXG4gIGlmIChpc1VuZGVmKGRhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYoZGF0YS5zdHlsZSkgJiZcbiAgICBpc1VuZGVmKG9sZERhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYob2xkRGF0YS5zdHlsZSlcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3VyLCBuYW1lO1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBvbGRTdGF0aWNTdHlsZSA9IG9sZERhdGEuc3RhdGljU3R5bGU7XG4gIHZhciBvbGRTdHlsZUJpbmRpbmcgPSBvbGREYXRhLm5vcm1hbGl6ZWRTdHlsZSB8fCBvbGREYXRhLnN0eWxlIHx8IHt9O1xuXG4gIC8vIGlmIHN0YXRpYyBzdHlsZSBleGlzdHMsIHN0eWxlYmluZGluZyBhbHJlYWR5IG1lcmdlZCBpbnRvIGl0IHdoZW4gZG9pbmcgbm9ybWFsaXplU3R5bGVEYXRhXG4gIHZhciBvbGRTdHlsZSA9IG9sZFN0YXRpY1N0eWxlIHx8IG9sZFN0eWxlQmluZGluZztcblxuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcodm5vZGUuZGF0YS5zdHlsZSkgfHwge307XG5cbiAgLy8gc3RvcmUgbm9ybWFsaXplZCBzdHlsZSB1bmRlciBhIGRpZmZlcmVudCBrZXkgZm9yIG5leHQgZGlmZlxuICAvLyBtYWtlIHN1cmUgdG8gY2xvbmUgaXQgaWYgaXQncyByZWFjdGl2ZSwgc2luY2UgdGhlIHVzZXIgbGlrbGV5IHdhbnRzXG4gIC8vIHRvIG11dGF0ZSBpdC5cbiAgdm5vZGUuZGF0YS5ub3JtYWxpemVkU3R5bGUgPSBpc0RlZihzdHlsZS5fX29iX18pXG4gICAgPyBleHRlbmQoe30sIHN0eWxlKVxuICAgIDogc3R5bGU7XG5cbiAgdmFyIG5ld1N0eWxlID0gZ2V0U3R5bGUodm5vZGUsIHRydWUpO1xuXG4gIGZvciAobmFtZSBpbiBvbGRTdHlsZSkge1xuICAgIGlmIChpc1VuZGVmKG5ld1N0eWxlW25hbWVdKSkge1xuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgJycpO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gbmV3U3R5bGUpIHtcbiAgICBjdXIgPSBuZXdTdHlsZVtuYW1lXTtcbiAgICBpZiAoY3VyICE9PSBvbGRTdHlsZVtuYW1lXSkge1xuICAgICAgLy8gaWU5IHNldHRpbmcgdG8gbnVsbCBoYXMgbm8gZWZmZWN0LCBtdXN0IHVzZSBlbXB0eSBzdHJpbmdcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsIGN1ciA9PSBudWxsID8gJycgOiBjdXIpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgc3R5bGUgPSB7XG4gIGNyZWF0ZTogdXBkYXRlU3R5bGUsXG4gIHVwZGF0ZTogdXBkYXRlU3R5bGVcbn07XG5cbi8qICAqL1xuXG4vKipcbiAqIEFkZCBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIGFkZENsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LmFkZChjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ciA9IFwiIFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcIiBcIjtcbiAgICBpZiAoY3VyLmluZGV4T2YoJyAnICsgY2xzICsgJyAnKSA8IDApIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoY3VyICsgY2xzKS50cmltKCkpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LnJlbW92ZShjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xzKTtcbiAgICB9XG4gICAgaWYgKCFlbC5jbGFzc0xpc3QubGVuZ3RoKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG4gICAgdmFyIHRhciA9ICcgJyArIGNscyArICcgJztcbiAgICB3aGlsZSAoY3VyLmluZGV4T2YodGFyKSA+PSAwKSB7XG4gICAgICBjdXIgPSBjdXIucmVwbGFjZSh0YXIsICcgJyk7XG4gICAgfVxuICAgIGN1ciA9IGN1ci50cmltKCk7XG4gICAgaWYgKGN1cikge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGN1cik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uIChkZWYkJDEpIHtcbiAgaWYgKCFkZWYkJDEpIHtcbiAgICByZXR1cm5cbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgcmVzID0ge307XG4gICAgaWYgKGRlZiQkMS5jc3MgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbmQocmVzLCBhdXRvQ3NzVHJhbnNpdGlvbihkZWYkJDEubmFtZSB8fCAndicpKTtcbiAgICB9XG4gICAgZXh0ZW5kKHJlcywgZGVmJCQxKTtcbiAgICByZXR1cm4gcmVzXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gYXV0b0Nzc1RyYW5zaXRpb24oZGVmJCQxKVxuICB9XG59XG5cbnZhciBhdXRvQ3NzVHJhbnNpdGlvbiA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4ge1xuICAgIGVudGVyQ2xhc3M6IChuYW1lICsgXCItZW50ZXJcIiksXG4gICAgZW50ZXJUb0NsYXNzOiAobmFtZSArIFwiLWVudGVyLXRvXCIpLFxuICAgIGVudGVyQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItZW50ZXItYWN0aXZlXCIpLFxuICAgIGxlYXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmVcIiksXG4gICAgbGVhdmVUb0NsYXNzOiAobmFtZSArIFwiLWxlYXZlLXRvXCIpLFxuICAgIGxlYXZlQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtYWN0aXZlXCIpXG4gIH1cbn0pO1xuXG52YXIgaGFzVHJhbnNpdGlvbiA9IGluQnJvd3NlciAmJiAhaXNJRTk7XG52YXIgVFJBTlNJVElPTiA9ICd0cmFuc2l0aW9uJztcbnZhciBBTklNQVRJT04gPSAnYW5pbWF0aW9uJztcblxuLy8gVHJhbnNpdGlvbiBwcm9wZXJ0eS9ldmVudCBzbmlmZmluZ1xudmFyIHRyYW5zaXRpb25Qcm9wID0gJ3RyYW5zaXRpb24nO1xudmFyIHRyYW5zaXRpb25FbmRFdmVudCA9ICd0cmFuc2l0aW9uZW5kJztcbnZhciBhbmltYXRpb25Qcm9wID0gJ2FuaW1hdGlvbic7XG52YXIgYW5pbWF0aW9uRW5kRXZlbnQgPSAnYW5pbWF0aW9uZW5kJztcbmlmIChoYXNUcmFuc2l0aW9uKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAod2luZG93Lm9udHJhbnNpdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0dHJhbnNpdGlvbmVuZCAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHRyYW5zaXRpb25Qcm9wID0gJ1dlYmtpdFRyYW5zaXRpb24nO1xuICAgIHRyYW5zaXRpb25FbmRFdmVudCA9ICd3ZWJraXRUcmFuc2l0aW9uRW5kJztcbiAgfVxuICBpZiAod2luZG93Lm9uYW5pbWF0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICB3aW5kb3cub253ZWJraXRhbmltYXRpb25lbmQgIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICBhbmltYXRpb25Qcm9wID0gJ1dlYmtpdEFuaW1hdGlvbic7XG4gICAgYW5pbWF0aW9uRW5kRXZlbnQgPSAnd2Via2l0QW5pbWF0aW9uRW5kJztcbiAgfVxufVxuXG4vLyBiaW5kaW5nIHRvIHdpbmRvdyBpcyBuZWNlc3NhcnkgdG8gbWFrZSBob3QgcmVsb2FkIHdvcmsgaW4gSUUgaW4gc3RyaWN0IG1vZGVcbnZhciByYWYgPSBpbkJyb3dzZXIgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZVxuICA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpXG4gIDogc2V0VGltZW91dDtcblxuZnVuY3Rpb24gbmV4dEZyYW1lIChmbikge1xuICByYWYoZnVuY3Rpb24gKCkge1xuICAgIHJhZihmbik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgdmFyIHRyYW5zaXRpb25DbGFzc2VzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzIHx8IChlbC5fdHJhbnNpdGlvbkNsYXNzZXMgPSBbXSk7XG4gIGlmICh0cmFuc2l0aW9uQ2xhc3Nlcy5pbmRleE9mKGNscykgPCAwKSB7XG4gICAgdHJhbnNpdGlvbkNsYXNzZXMucHVzaChjbHMpO1xuICAgIGFkZENsYXNzKGVsLCBjbHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgcmVtb3ZlKGVsLl90cmFuc2l0aW9uQ2xhc3NlcywgY2xzKTtcbiAgfVxuICByZW1vdmVDbGFzcyhlbCwgY2xzKTtcbn1cblxuZnVuY3Rpb24gd2hlblRyYW5zaXRpb25FbmRzIChcbiAgZWwsXG4gIGV4cGVjdGVkVHlwZSxcbiAgY2Jcbikge1xuICB2YXIgcmVmID0gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSk7XG4gIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gIHZhciB0aW1lb3V0ID0gcmVmLnRpbWVvdXQ7XG4gIHZhciBwcm9wQ291bnQgPSByZWYucHJvcENvdW50O1xuICBpZiAoIXR5cGUpIHsgcmV0dXJuIGNiKCkgfVxuICB2YXIgZXZlbnQgPSB0eXBlID09PSBUUkFOU0lUSU9OID8gdHJhbnNpdGlvbkVuZEV2ZW50IDogYW5pbWF0aW9uRW5kRXZlbnQ7XG4gIHZhciBlbmRlZCA9IDA7XG4gIHZhciBlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xuICAgIGNiKCk7XG4gIH07XG4gIHZhciBvbkVuZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUudGFyZ2V0ID09PSBlbCkge1xuICAgICAgaWYgKCsrZW5kZWQgPj0gcHJvcENvdW50KSB7XG4gICAgICAgIGVuZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVuZGVkIDwgcHJvcENvdW50KSB7XG4gICAgICBlbmQoKTtcbiAgICB9XG4gIH0sIHRpbWVvdXQgKyAxKTtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xufVxuXG52YXIgdHJhbnNmb3JtUkUgPSAvXFxiKHRyYW5zZm9ybXxhbGwpKCx8JCkvO1xuXG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uSW5mbyAoZWwsIGV4cGVjdGVkVHlwZSkge1xuICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICB2YXIgdHJhbnNpdGlvbkRlbGF5cyA9IHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEZWxheSddLnNwbGl0KCcsICcpO1xuICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9ucyA9IHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEdXJhdGlvbiddLnNwbGl0KCcsICcpO1xuICB2YXIgdHJhbnNpdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KHRyYW5zaXRpb25EZWxheXMsIHRyYW5zaXRpb25EdXJhdGlvbnMpO1xuICB2YXIgYW5pbWF0aW9uRGVsYXlzID0gc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRGVsYXknXS5zcGxpdCgnLCAnKTtcbiAgdmFyIGFuaW1hdGlvbkR1cmF0aW9ucyA9IHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10uc3BsaXQoJywgJyk7XG4gIHZhciBhbmltYXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dChhbmltYXRpb25EZWxheXMsIGFuaW1hdGlvbkR1cmF0aW9ucyk7XG5cbiAgdmFyIHR5cGU7XG4gIHZhciB0aW1lb3V0ID0gMDtcbiAgdmFyIHByb3BDb3VudCA9IDA7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZXhwZWN0ZWRUeXBlID09PSBUUkFOU0lUSU9OKSB7XG4gICAgaWYgKHRyYW5zaXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IFRSQU5TSVRJT047XG4gICAgICB0aW1lb3V0ID0gdHJhbnNpdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBBTklNQVRJT04pIHtcbiAgICBpZiAoYW5pbWF0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBBTklNQVRJT047XG4gICAgICB0aW1lb3V0ID0gYW5pbWF0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRpbWVvdXQgPSBNYXRoLm1heCh0cmFuc2l0aW9uVGltZW91dCwgYW5pbWF0aW9uVGltZW91dCk7XG4gICAgdHlwZSA9IHRpbWVvdXQgPiAwXG4gICAgICA/IHRyYW5zaXRpb25UaW1lb3V0ID4gYW5pbWF0aW9uVGltZW91dFxuICAgICAgICA/IFRSQU5TSVRJT05cbiAgICAgICAgOiBBTklNQVRJT05cbiAgICAgIDogbnVsbDtcbiAgICBwcm9wQ291bnQgPSB0eXBlXG4gICAgICA/IHR5cGUgPT09IFRSQU5TSVRJT05cbiAgICAgICAgPyB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgICA6IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgIDogMDtcbiAgfVxuICB2YXIgaGFzVHJhbnNmb3JtID1cbiAgICB0eXBlID09PSBUUkFOU0lUSU9OICYmXG4gICAgdHJhbnNmb3JtUkUudGVzdChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnUHJvcGVydHknXSk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogdHlwZSxcbiAgICB0aW1lb3V0OiB0aW1lb3V0LFxuICAgIHByb3BDb3VudDogcHJvcENvdW50LFxuICAgIGhhc1RyYW5zZm9ybTogaGFzVHJhbnNmb3JtXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VGltZW91dCAoZGVsYXlzLCBkdXJhdGlvbnMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgd2hpbGUgKGRlbGF5cy5sZW5ndGggPCBkdXJhdGlvbnMubGVuZ3RoKSB7XG4gICAgZGVsYXlzID0gZGVsYXlzLmNvbmNhdChkZWxheXMpO1xuICB9XG5cbiAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KG51bGwsIGR1cmF0aW9ucy5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICByZXR1cm4gdG9NcyhkKSArIHRvTXMoZGVsYXlzW2ldKVxuICB9KSlcbn1cblxuZnVuY3Rpb24gdG9NcyAocykge1xuICByZXR1cm4gTnVtYmVyKHMuc2xpY2UoMCwgLTEpKSAqIDEwMDBcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVudGVyICh2bm9kZSwgdG9nZ2xlRGlzcGxheSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG5cbiAgLy8gY2FsbCBsZWF2ZSBjYWxsYmFjayBub3dcbiAgaWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSkge1xuICAgIGVsLl9sZWF2ZUNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgZWwuX2xlYXZlQ2IoKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcbiAgaWYgKGlzVW5kZWYoZGF0YSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYoZWwuX2VudGVyQ2IpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICB2YXIgZW50ZXJDbGFzcyA9IGRhdGEuZW50ZXJDbGFzcztcbiAgdmFyIGVudGVyVG9DbGFzcyA9IGRhdGEuZW50ZXJUb0NsYXNzO1xuICB2YXIgZW50ZXJBY3RpdmVDbGFzcyA9IGRhdGEuZW50ZXJBY3RpdmVDbGFzcztcbiAgdmFyIGFwcGVhckNsYXNzID0gZGF0YS5hcHBlYXJDbGFzcztcbiAgdmFyIGFwcGVhclRvQ2xhc3MgPSBkYXRhLmFwcGVhclRvQ2xhc3M7XG4gIHZhciBhcHBlYXJBY3RpdmVDbGFzcyA9IGRhdGEuYXBwZWFyQWN0aXZlQ2xhc3M7XG4gIHZhciBiZWZvcmVFbnRlciA9IGRhdGEuYmVmb3JlRW50ZXI7XG4gIHZhciBlbnRlciA9IGRhdGEuZW50ZXI7XG4gIHZhciBhZnRlckVudGVyID0gZGF0YS5hZnRlckVudGVyO1xuICB2YXIgZW50ZXJDYW5jZWxsZWQgPSBkYXRhLmVudGVyQ2FuY2VsbGVkO1xuICB2YXIgYmVmb3JlQXBwZWFyID0gZGF0YS5iZWZvcmVBcHBlYXI7XG4gIHZhciBhcHBlYXIgPSBkYXRhLmFwcGVhcjtcbiAgdmFyIGFmdGVyQXBwZWFyID0gZGF0YS5hZnRlckFwcGVhcjtcbiAgdmFyIGFwcGVhckNhbmNlbGxlZCA9IGRhdGEuYXBwZWFyQ2FuY2VsbGVkO1xuICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gIC8vIGFjdGl2ZUluc3RhbmNlIHdpbGwgYWx3YXlzIGJlIHRoZSA8dHJhbnNpdGlvbj4gY29tcG9uZW50IG1hbmFnaW5nIHRoaXNcbiAgLy8gdHJhbnNpdGlvbi4gT25lIGVkZ2UgY2FzZSB0byBjaGVjayBpcyB3aGVuIHRoZSA8dHJhbnNpdGlvbj4gaXMgcGxhY2VkXG4gIC8vIGFzIHRoZSByb290IG5vZGUgb2YgYSBjaGlsZCBjb21wb25lbnQuIEluIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIGNoZWNrXG4gIC8vIDx0cmFuc2l0aW9uPidzIHBhcmVudCBmb3IgYXBwZWFyIGNoZWNrLlxuICB2YXIgY29udGV4dCA9IGFjdGl2ZUluc3RhbmNlO1xuICB2YXIgdHJhbnNpdGlvbk5vZGUgPSBhY3RpdmVJbnN0YW5jZS4kdm5vZGU7XG4gIHdoaWxlICh0cmFuc2l0aW9uTm9kZSAmJiB0cmFuc2l0aW9uTm9kZS5wYXJlbnQpIHtcbiAgICB0cmFuc2l0aW9uTm9kZSA9IHRyYW5zaXRpb25Ob2RlLnBhcmVudDtcbiAgICBjb250ZXh0ID0gdHJhbnNpdGlvbk5vZGUuY29udGV4dDtcbiAgfVxuXG4gIHZhciBpc0FwcGVhciA9ICFjb250ZXh0Ll9pc01vdW50ZWQgfHwgIXZub2RlLmlzUm9vdEluc2VydDtcblxuICBpZiAoaXNBcHBlYXIgJiYgIWFwcGVhciAmJiBhcHBlYXIgIT09ICcnKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgc3RhcnRDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckNsYXNzXG4gICAgPyBhcHBlYXJDbGFzc1xuICAgIDogZW50ZXJDbGFzcztcbiAgdmFyIGFjdGl2ZUNsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICA/IGFwcGVhckFjdGl2ZUNsYXNzXG4gICAgOiBlbnRlckFjdGl2ZUNsYXNzO1xuICB2YXIgdG9DbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhclRvQ2xhc3NcbiAgICA/IGFwcGVhclRvQ2xhc3NcbiAgICA6IGVudGVyVG9DbGFzcztcblxuICB2YXIgYmVmb3JlRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/IChiZWZvcmVBcHBlYXIgfHwgYmVmb3JlRW50ZXIpXG4gICAgOiBiZWZvcmVFbnRlcjtcbiAgdmFyIGVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAodHlwZW9mIGFwcGVhciA9PT0gJ2Z1bmN0aW9uJyA/IGFwcGVhciA6IGVudGVyKVxuICAgIDogZW50ZXI7XG4gIHZhciBhZnRlckVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYWZ0ZXJBcHBlYXIgfHwgYWZ0ZXJFbnRlcilcbiAgICA6IGFmdGVyRW50ZXI7XG4gIHZhciBlbnRlckNhbmNlbGxlZEhvb2sgPSBpc0FwcGVhclxuICAgID8gKGFwcGVhckNhbmNlbGxlZCB8fCBlbnRlckNhbmNlbGxlZClcbiAgICA6IGVudGVyQ2FuY2VsbGVkO1xuXG4gIHZhciBleHBsaWNpdEVudGVyRHVyYXRpb24gPSB0b051bWJlcihcbiAgICBpc09iamVjdChkdXJhdGlvbilcbiAgICAgID8gZHVyYXRpb24uZW50ZXJcbiAgICAgIDogZHVyYXRpb25cbiAgKTtcblxuICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgZXhwbGljaXRFbnRlckR1cmF0aW9uICE9IG51bGwpIHtcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbiwgJ2VudGVyJywgdm5vZGUpO1xuICB9XG5cbiAgdmFyIGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcbiAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGVudGVySG9vayk7XG5cbiAgdmFyIGNiID0gZWwuX2VudGVyQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIH1cbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgfVxuICAgICAgZW50ZXJDYW5jZWxsZWRIb29rICYmIGVudGVyQ2FuY2VsbGVkSG9vayhlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyRW50ZXJIb29rICYmIGFmdGVyRW50ZXJIb29rKGVsKTtcbiAgICB9XG4gICAgZWwuX2VudGVyQ2IgPSBudWxsO1xuICB9KTtcblxuICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgIC8vIHJlbW92ZSBwZW5kaW5nIGxlYXZlIGVsZW1lbnQgb24gZW50ZXIgYnkgaW5qZWN0aW5nIGFuIGluc2VydCBob29rXG4gICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUuZGF0YS5ob29rIHx8ICh2bm9kZS5kYXRhLmhvb2sgPSB7fSksICdpbnNlcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcbiAgICAgIHZhciBwZW5kaW5nTm9kZSA9IHBhcmVudCAmJiBwYXJlbnQuX3BlbmRpbmcgJiYgcGFyZW50Ll9wZW5kaW5nW3Zub2RlLmtleV07XG4gICAgICBpZiAocGVuZGluZ05vZGUgJiZcbiAgICAgICAgcGVuZGluZ05vZGUudGFnID09PSB2bm9kZS50YWcgJiZcbiAgICAgICAgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiXG4gICAgICApIHtcbiAgICAgICAgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiKCk7XG4gICAgICB9XG4gICAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gICAgfSk7XG4gIH1cblxuICAvLyBzdGFydCBlbnRlciB0cmFuc2l0aW9uXG4gIGJlZm9yZUVudGVySG9vayAmJiBiZWZvcmVFbnRlckhvb2soZWwpO1xuICBpZiAoZXhwZWN0c0NTUykge1xuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgaWYgKCFjYi5jYW5jZWxsZWQgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24pKSB7XG4gICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRFbnRlckR1cmF0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHZub2RlLmRhdGEuc2hvdykge1xuICAgIHRvZ2dsZURpc3BsYXkgJiYgdG9nZ2xlRGlzcGxheSgpO1xuICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgfVxuXG4gIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgIGNiKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGVhdmUgKHZub2RlLCBybSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG5cbiAgLy8gY2FsbCBlbnRlciBjYWxsYmFjayBub3dcbiAgaWYgKGlzRGVmKGVsLl9lbnRlckNiKSkge1xuICAgIGVsLl9lbnRlckNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgZWwuX2VudGVyQ2IoKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcbiAgaWYgKGlzVW5kZWYoZGF0YSkpIHtcbiAgICByZXR1cm4gcm0oKVxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihlbC5fbGVhdmVDYikgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjc3MgPSBkYXRhLmNzcztcbiAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XG4gIHZhciBsZWF2ZUNsYXNzID0gZGF0YS5sZWF2ZUNsYXNzO1xuICB2YXIgbGVhdmVUb0NsYXNzID0gZGF0YS5sZWF2ZVRvQ2xhc3M7XG4gIHZhciBsZWF2ZUFjdGl2ZUNsYXNzID0gZGF0YS5sZWF2ZUFjdGl2ZUNsYXNzO1xuICB2YXIgYmVmb3JlTGVhdmUgPSBkYXRhLmJlZm9yZUxlYXZlO1xuICB2YXIgbGVhdmUgPSBkYXRhLmxlYXZlO1xuICB2YXIgYWZ0ZXJMZWF2ZSA9IGRhdGEuYWZ0ZXJMZWF2ZTtcbiAgdmFyIGxlYXZlQ2FuY2VsbGVkID0gZGF0YS5sZWF2ZUNhbmNlbGxlZDtcbiAgdmFyIGRlbGF5TGVhdmUgPSBkYXRhLmRlbGF5TGVhdmU7XG4gIHZhciBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XG5cbiAgdmFyIGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcbiAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGxlYXZlKTtcblxuICB2YXIgZXhwbGljaXRMZWF2ZUR1cmF0aW9uID0gdG9OdW1iZXIoXG4gICAgaXNPYmplY3QoZHVyYXRpb24pXG4gICAgICA/IGR1cmF0aW9uLmxlYXZlXG4gICAgICA6IGR1cmF0aW9uXG4gICk7XG5cbiAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzRGVmKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbiwgJ2xlYXZlJywgdm5vZGUpO1xuICB9XG5cbiAgdmFyIGNiID0gZWwuX2xlYXZlQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZWwucGFyZW50Tm9kZSAmJiBlbC5wYXJlbnROb2RlLl9wZW5kaW5nKSB7XG4gICAgICBlbC5wYXJlbnROb2RlLl9wZW5kaW5nW3Zub2RlLmtleV0gPSBudWxsO1xuICAgIH1cbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIH1cbiAgICAgIGxlYXZlQ2FuY2VsbGVkICYmIGxlYXZlQ2FuY2VsbGVkKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZShlbCk7XG4gICAgfVxuICAgIGVsLl9sZWF2ZUNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKGRlbGF5TGVhdmUpIHtcbiAgICBkZWxheUxlYXZlKHBlcmZvcm1MZWF2ZSk7XG4gIH0gZWxzZSB7XG4gICAgcGVyZm9ybUxlYXZlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwZXJmb3JtTGVhdmUgKCkge1xuICAgIC8vIHRoZSBkZWxheWVkIGxlYXZlIG1heSBoYXZlIGFscmVhZHkgYmVlbiBjYW5jZWxsZWRcbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gcmVjb3JkIGxlYXZpbmcgZWxlbWVudFxuICAgIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgICAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyB8fCAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyA9IHt9KSlbKHZub2RlLmtleSldID0gdm5vZGU7XG4gICAgfVxuICAgIGJlZm9yZUxlYXZlICYmIGJlZm9yZUxlYXZlKGVsKTtcbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICAgIGlmICghY2IuY2FuY2VsbGVkICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdExlYXZlRHVyYXRpb24pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZWF2ZSAmJiBsZWF2ZShlbCwgY2IpO1xuICAgIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgY2IoKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gb25seSB1c2VkIGluIGRldiBtb2RlXG5mdW5jdGlvbiBjaGVja0R1cmF0aW9uICh2YWwsIG5hbWUsIHZub2RlKSB7XG4gIGlmICh0eXBlb2YgdmFsICE9PSAnbnVtYmVyJykge1xuICAgIHdhcm4oXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBub3QgYSB2YWxpZCBudW1iZXIgLSBcIiArXG4gICAgICBcImdvdCBcIiArIChKU09OLnN0cmluZ2lmeSh2YWwpKSArIFwiLlwiLFxuICAgICAgdm5vZGUuY29udGV4dFxuICAgICk7XG4gIH0gZWxzZSBpZiAoaXNOYU4odmFsKSkge1xuICAgIHdhcm4oXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBOYU4gLSBcIiArXG4gICAgICAndGhlIGR1cmF0aW9uIGV4cHJlc3Npb24gbWlnaHQgYmUgaW5jb3JyZWN0LicsXG4gICAgICB2bm9kZS5jb250ZXh0XG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1ZhbGlkRHVyYXRpb24gKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbClcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYSB0cmFuc2l0aW9uIGhvb2sncyBhcmd1bWVudCBsZW5ndGguIFRoZSBob29rIG1heSBiZTpcbiAqIC0gYSBtZXJnZWQgaG9vayAoaW52b2tlcikgd2l0aCB0aGUgb3JpZ2luYWwgaW4gLmZuc1xuICogLSBhIHdyYXBwZWQgY29tcG9uZW50IG1ldGhvZCAoY2hlY2sgLl9sZW5ndGgpXG4gKiAtIGEgcGxhaW4gZnVuY3Rpb24gKC5sZW5ndGgpXG4gKi9cbmZ1bmN0aW9uIGdldEhvb2tBcmd1bWVudHNMZW5ndGggKGZuKSB7XG4gIGlmIChpc1VuZGVmKGZuKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHZhciBpbnZva2VyRm5zID0gZm4uZm5zO1xuICBpZiAoaXNEZWYoaW52b2tlckZucykpIHtcbiAgICAvLyBpbnZva2VyXG4gICAgcmV0dXJuIGdldEhvb2tBcmd1bWVudHNMZW5ndGgoXG4gICAgICBBcnJheS5pc0FycmF5KGludm9rZXJGbnMpXG4gICAgICAgID8gaW52b2tlckZuc1swXVxuICAgICAgICA6IGludm9rZXJGbnNcbiAgICApXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChmbi5fbGVuZ3RoIHx8IGZuLmxlbmd0aCkgPiAxXG4gIH1cbn1cblxuZnVuY3Rpb24gX2VudGVyIChfLCB2bm9kZSkge1xuICBpZiAodm5vZGUuZGF0YS5zaG93ICE9PSB0cnVlKSB7XG4gICAgZW50ZXIodm5vZGUpO1xuICB9XG59XG5cbnZhciB0cmFuc2l0aW9uID0gaW5Ccm93c2VyID8ge1xuICBjcmVhdGU6IF9lbnRlcixcbiAgYWN0aXZhdGU6IF9lbnRlcixcbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUkJDEgKHZub2RlLCBybSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xuICAgICAgbGVhdmUodm5vZGUsIHJtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICB9XG4gIH1cbn0gOiB7fTtcblxudmFyIHBsYXRmb3JtTW9kdWxlcyA9IFtcbiAgYXR0cnMsXG4gIGtsYXNzLFxuICBldmVudHMsXG4gIGRvbVByb3BzLFxuICBzdHlsZSxcbiAgdHJhbnNpdGlvblxuXTtcblxuLyogICovXG5cbi8vIHRoZSBkaXJlY3RpdmUgbW9kdWxlIHNob3VsZCBiZSBhcHBsaWVkIGxhc3QsIGFmdGVyIGFsbFxuLy8gYnVpbHQtaW4gbW9kdWxlcyBoYXZlIGJlZW4gYXBwbGllZC5cbnZhciBtb2R1bGVzID0gcGxhdGZvcm1Nb2R1bGVzLmNvbmNhdChiYXNlTW9kdWxlcyk7XG5cbnZhciBwYXRjaCA9IGNyZWF0ZVBhdGNoRnVuY3Rpb24oeyBub2RlT3BzOiBub2RlT3BzLCBtb2R1bGVzOiBtb2R1bGVzIH0pO1xuXG4vKipcbiAqIE5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBsaWtlIGF0dGFjaGluZ1xuICogcHJvcGVydGllcyB0byBFbGVtZW50cy5cbiAqL1xuXG52YXIgaXNUZXh0SW5wdXRUeXBlID0gbWFrZU1hcCgndGV4dCxudW1iZXIscGFzc3dvcmQsc2VhcmNoLGVtYWlsLHRlbCx1cmwnKTtcblxuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAoaXNJRTkpIHtcbiAgLy8gaHR0cDovL3d3dy5tYXR0czQxMS5jb20vcG9zdC9pbnRlcm5ldC1leHBsb3Jlci05LW9uaW5wdXQvXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbmNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIGlmIChlbCAmJiBlbC52bW9kZWwpIHtcbiAgICAgIHRyaWdnZXIoZWwsICdpbnB1dCcpO1xuICAgIH1cbiAgfSk7XG59XG5cbnZhciBtb2RlbCQxID0ge1xuICBpbnNlcnRlZDogZnVuY3Rpb24gaW5zZXJ0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICB2YXIgY2IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgIH07XG4gICAgICBjYigpO1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXNJRSB8fCBpc0VkZ2UpIHtcbiAgICAgICAgc2V0VGltZW91dChjYiwgMCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh2bm9kZS50YWcgPT09ICd0ZXh0YXJlYScgfHwgaXNUZXh0SW5wdXRUeXBlKGVsLnR5cGUpKSB7XG4gICAgICBlbC5fdk1vZGlmaWVycyA9IGJpbmRpbmcubW9kaWZpZXJzO1xuICAgICAgaWYgKCFiaW5kaW5nLm1vZGlmaWVycy5sYXp5KSB7XG4gICAgICAgIC8vIFNhZmFyaSA8IDEwLjIgJiBVSVdlYlZpZXcgZG9lc24ndCBmaXJlIGNvbXBvc2l0aW9uZW5kIHdoZW5cbiAgICAgICAgLy8gc3dpdGNoaW5nIGZvY3VzIGJlZm9yZSBjb25maXJtaW5nIGNvbXBvc2l0aW9uIGNob2ljZVxuICAgICAgICAvLyB0aGlzIGFsc28gZml4ZXMgdGhlIGlzc3VlIHdoZXJlIHNvbWUgYnJvd3NlcnMgZS5nLiBpT1MgQ2hyb21lXG4gICAgICAgIC8vIGZpcmVzIFwiY2hhbmdlXCIgaW5zdGVhZCBvZiBcImlucHV0XCIgb24gYXV0b2NvbXBsZXRlLlxuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgICAgaWYgKCFpc0FuZHJvaWQpIHtcbiAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbnN0YXJ0Jywgb25Db21wb3NpdGlvblN0YXJ0KTtcbiAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbmVuZCcsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoaXNJRTkpIHtcbiAgICAgICAgICBlbC52bW9kZWwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBjb21wb25lbnRVcGRhdGVkOiBmdW5jdGlvbiBjb21wb25lbnRVcGRhdGVkIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgLy8gaW4gY2FzZSB0aGUgb3B0aW9ucyByZW5kZXJlZCBieSB2LWZvciBoYXZlIGNoYW5nZWQsXG4gICAgICAvLyBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIHZhbHVlIGlzIG91dC1vZi1zeW5jIHdpdGggdGhlIHJlbmRlcmVkIG9wdGlvbnMuXG4gICAgICAvLyBkZXRlY3Qgc3VjaCBjYXNlcyBhbmQgZmlsdGVyIG91dCB2YWx1ZXMgdGhhdCBubyBsb25nZXIgaGFzIGEgbWF0Y2hpbmdcbiAgICAgIC8vIG9wdGlvbiBpbiB0aGUgRE9NLlxuICAgICAgdmFyIG5lZWRSZXNldCA9IGVsLm11bHRpcGxlXG4gICAgICAgID8gYmluZGluZy52YWx1ZS5zb21lKGZ1bmN0aW9uICh2KSB7IHJldHVybiBoYXNOb01hdGNoaW5nT3B0aW9uKHYsIGVsLm9wdGlvbnMpOyB9KVxuICAgICAgICA6IGJpbmRpbmcudmFsdWUgIT09IGJpbmRpbmcub2xkVmFsdWUgJiYgaGFzTm9NYXRjaGluZ09wdGlvbihiaW5kaW5nLnZhbHVlLCBlbC5vcHRpb25zKTtcbiAgICAgIGlmIChuZWVkUmVzZXQpIHtcbiAgICAgICAgdHJpZ2dlcihlbCwgJ2NoYW5nZScpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gc2V0U2VsZWN0ZWQgKGVsLCBiaW5kaW5nLCB2bSkge1xuICB2YXIgdmFsdWUgPSBiaW5kaW5nLnZhbHVlO1xuICB2YXIgaXNNdWx0aXBsZSA9IGVsLm11bHRpcGxlO1xuICBpZiAoaXNNdWx0aXBsZSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgXCI8c2VsZWN0IG11bHRpcGxlIHYtbW9kZWw9XFxcIlwiICsgKGJpbmRpbmcuZXhwcmVzc2lvbikgKyBcIlxcXCI+IFwiICtcbiAgICAgIFwiZXhwZWN0cyBhbiBBcnJheSB2YWx1ZSBmb3IgaXRzIGJpbmRpbmcsIGJ1dCBnb3QgXCIgKyAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSkpLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIHZhciBzZWxlY3RlZCwgb3B0aW9uO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGVsLm9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb3B0aW9uID0gZWwub3B0aW9uc1tpXTtcbiAgICBpZiAoaXNNdWx0aXBsZSkge1xuICAgICAgc2VsZWN0ZWQgPSBsb29zZUluZGV4T2YodmFsdWUsIGdldFZhbHVlKG9wdGlvbikpID4gLTE7XG4gICAgICBpZiAob3B0aW9uLnNlbGVjdGVkICE9PSBzZWxlY3RlZCkge1xuICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGxvb3NlRXF1YWwoZ2V0VmFsdWUob3B0aW9uKSwgdmFsdWUpKSB7XG4gICAgICAgIGlmIChlbC5zZWxlY3RlZEluZGV4ICE9PSBpKSB7XG4gICAgICAgICAgZWwuc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghaXNNdWx0aXBsZSkge1xuICAgIGVsLnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNOb01hdGNoaW5nT3B0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IG9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKGxvb3NlRXF1YWwoZ2V0VmFsdWUob3B0aW9uc1tpXSksIHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlIChvcHRpb24pIHtcbiAgcmV0dXJuICdfdmFsdWUnIGluIG9wdGlvblxuICAgID8gb3B0aW9uLl92YWx1ZVxuICAgIDogb3B0aW9uLnZhbHVlXG59XG5cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25TdGFydCAoZSkge1xuICBlLnRhcmdldC5jb21wb3NpbmcgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uRW5kIChlKSB7XG4gIC8vIHByZXZlbnQgdHJpZ2dlcmluZyBhbiBpbnB1dCBldmVudCBmb3Igbm8gcmVhc29uXG4gIGlmICghZS50YXJnZXQuY29tcG9zaW5nKSB7IHJldHVybiB9XG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IGZhbHNlO1xuICB0cmlnZ2VyKGUudGFyZ2V0LCAnaW5wdXQnKTtcbn1cblxuZnVuY3Rpb24gdHJpZ2dlciAoZWwsIHR5cGUpIHtcbiAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpO1xuICBlLmluaXRFdmVudCh0eXBlLCB0cnVlLCB0cnVlKTtcbiAgZWwuZGlzcGF0Y2hFdmVudChlKTtcbn1cblxuLyogICovXG5cbi8vIHJlY3Vyc2l2ZWx5IHNlYXJjaCBmb3IgcG9zc2libGUgdHJhbnNpdGlvbiBkZWZpbmVkIGluc2lkZSB0aGUgY29tcG9uZW50IHJvb3RcbmZ1bmN0aW9uIGxvY2F0ZU5vZGUgKHZub2RlKSB7XG4gIHJldHVybiB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJiAoIXZub2RlLmRhdGEgfHwgIXZub2RlLmRhdGEudHJhbnNpdGlvbilcbiAgICA/IGxvY2F0ZU5vZGUodm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlKVxuICAgIDogdm5vZGVcbn1cblxudmFyIHNob3cgPSB7XG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQgKGVsLCByZWYsIHZub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuXG4gICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICB2YXIgdHJhbnNpdGlvbiQkMSA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xuICAgIHZhciBvcmlnaW5hbERpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgPVxuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnID8gJycgOiBlbC5zdHlsZS5kaXNwbGF5O1xuICAgIGlmICh2YWx1ZSAmJiB0cmFuc2l0aW9uJCQxICYmICFpc0lFOSkge1xuICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgIGVudGVyKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBvcmlnaW5hbERpc3BsYXk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gb3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAoZWwsIHJlZiwgdm5vZGUpIHtcbiAgICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XG4gICAgdmFyIG9sZFZhbHVlID0gcmVmLm9sZFZhbHVlO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHZhbHVlID09PSBvbGRWYWx1ZSkgeyByZXR1cm4gfVxuICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG4gICAgdmFyIHRyYW5zaXRpb24kJDEgPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICBpZiAodHJhbnNpdGlvbiQkMSAmJiAhaXNJRTkpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlYXZlKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQgKFxuICAgIGVsLFxuICAgIGJpbmRpbmcsXG4gICAgdm5vZGUsXG4gICAgb2xkVm5vZGUsXG4gICAgaXNEZXN0cm95XG4gICkge1xuICAgIGlmICghaXNEZXN0cm95KSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgIH1cbiAgfVxufTtcblxudmFyIHBsYXRmb3JtRGlyZWN0aXZlcyA9IHtcbiAgbW9kZWw6IG1vZGVsJDEsXG4gIHNob3c6IHNob3dcbn07XG5cbi8qICAqL1xuXG4vLyBQcm92aWRlcyB0cmFuc2l0aW9uIHN1cHBvcnQgZm9yIGEgc2luZ2xlIGVsZW1lbnQvY29tcG9uZW50LlxuLy8gc3VwcG9ydHMgdHJhbnNpdGlvbiBtb2RlIChvdXQtaW4gLyBpbi1vdXQpXG5cbnZhciB0cmFuc2l0aW9uUHJvcHMgPSB7XG4gIG5hbWU6IFN0cmluZyxcbiAgYXBwZWFyOiBCb29sZWFuLFxuICBjc3M6IEJvb2xlYW4sXG4gIG1vZGU6IFN0cmluZyxcbiAgdHlwZTogU3RyaW5nLFxuICBlbnRlckNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJUb0NsYXNzOiBTdHJpbmcsXG4gIGxlYXZlVG9DbGFzczogU3RyaW5nLFxuICBlbnRlckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyVG9DbGFzczogU3RyaW5nLFxuICBkdXJhdGlvbjogW051bWJlciwgU3RyaW5nLCBPYmplY3RdXG59O1xuXG4vLyBpbiBjYXNlIHRoZSBjaGlsZCBpcyBhbHNvIGFuIGFic3RyYWN0IGNvbXBvbmVudCwgZS5nLiA8a2VlcC1hbGl2ZT5cbi8vIHdlIHdhbnQgdG8gcmVjdXJzaXZlbHkgcmV0cmlldmUgdGhlIHJlYWwgY29tcG9uZW50IHRvIGJlIHJlbmRlcmVkXG5mdW5jdGlvbiBnZXRSZWFsQ2hpbGQgKHZub2RlKSB7XG4gIHZhciBjb21wT3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIGlmIChjb21wT3B0aW9ucyAmJiBjb21wT3B0aW9ucy5DdG9yLm9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICByZXR1cm4gZ2V0UmVhbENoaWxkKGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoY29tcE9wdGlvbnMuY2hpbGRyZW4pKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB2bm9kZVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RUcmFuc2l0aW9uRGF0YSAoY29tcCkge1xuICB2YXIgZGF0YSA9IHt9O1xuICB2YXIgb3B0aW9ucyA9IGNvbXAuJG9wdGlvbnM7XG4gIC8vIHByb3BzXG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLnByb3BzRGF0YSkge1xuICAgIGRhdGFba2V5XSA9IGNvbXBba2V5XTtcbiAgfVxuICAvLyBldmVudHMuXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzIGFuZCBwYXNzIHRoZW0gZGlyZWN0bHkgdG8gdGhlIHRyYW5zaXRpb24gbWV0aG9kc1xuICB2YXIgbGlzdGVuZXJzID0gb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBmb3IgKHZhciBrZXkkMSBpbiBsaXN0ZW5lcnMpIHtcbiAgICBkYXRhW2NhbWVsaXplKGtleSQxKV0gPSBsaXN0ZW5lcnNba2V5JDFdO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIHBsYWNlaG9sZGVyIChoLCByYXdDaGlsZCkge1xuICBpZiAoL1xcZC1rZWVwLWFsaXZlJC8udGVzdChyYXdDaGlsZC50YWcpKSB7XG4gICAgcmV0dXJuIGgoJ2tlZXAtYWxpdmUnLCB7XG4gICAgICBwcm9wczogcmF3Q2hpbGQuY29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGFcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGhhc1BhcmVudFRyYW5zaXRpb24gKHZub2RlKSB7XG4gIHdoaWxlICgodm5vZGUgPSB2bm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHZub2RlLmRhdGEudHJhbnNpdGlvbikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTYW1lQ2hpbGQgKGNoaWxkLCBvbGRDaGlsZCkge1xuICByZXR1cm4gb2xkQ2hpbGQua2V5ID09PSBjaGlsZC5rZXkgJiYgb2xkQ2hpbGQudGFnID09PSBjaGlsZC50YWdcbn1cblxuZnVuY3Rpb24gaXNBc3luY1BsYWNlaG9sZGVyIChub2RlKSB7XG4gIHJldHVybiBub2RlLmlzQ29tbWVudCAmJiBub2RlLmFzeW5jRmFjdG9yeVxufVxuXG52YXIgVHJhbnNpdGlvbiA9IHtcbiAgbmFtZTogJ3RyYW5zaXRpb24nLFxuICBwcm9wczogdHJhbnNpdGlvblByb3BzLFxuICBhYnN0cmFjdDogdHJ1ZSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW47XG4gICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gZmlsdGVyIG91dCB0ZXh0IG5vZGVzIChwb3NzaWJsZSB3aGl0ZXNwYWNlcylcbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50YWcgfHwgaXNBc3luY1BsYWNlaG9sZGVyKGMpOyB9KTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gd2FybiBtdWx0aXBsZSBlbGVtZW50c1xuICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnPHRyYW5zaXRpb24+IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBzaW5nbGUgZWxlbWVudC4gVXNlICcgK1xuICAgICAgICAnPHRyYW5zaXRpb24tZ3JvdXA+IGZvciBsaXN0cy4nLFxuICAgICAgICB0aGlzLiRwYXJlbnRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIG1vZGUgPSB0aGlzLm1vZGU7XG5cbiAgICAvLyB3YXJuIGludmFsaWQgbW9kZVxuICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgbW9kZSAmJiBtb2RlICE9PSAnaW4tb3V0JyAmJiBtb2RlICE9PSAnb3V0LWluJ1xuICAgICkge1xuICAgICAgd2FybihcbiAgICAgICAgJ2ludmFsaWQgPHRyYW5zaXRpb24+IG1vZGU6ICcgKyBtb2RlLFxuICAgICAgICB0aGlzLiRwYXJlbnRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIHJhd0NoaWxkID0gY2hpbGRyZW5bMF07XG5cbiAgICAvLyBpZiB0aGlzIGlzIGEgY29tcG9uZW50IHJvb3Qgbm9kZSBhbmQgdGhlIGNvbXBvbmVudCdzXG4gICAgLy8gcGFyZW50IGNvbnRhaW5lciBub2RlIGFsc28gaGFzIHRyYW5zaXRpb24sIHNraXAuXG4gICAgaWYgKGhhc1BhcmVudFRyYW5zaXRpb24odGhpcy4kdm5vZGUpKSB7XG4gICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICB9XG5cbiAgICAvLyBhcHBseSB0cmFuc2l0aW9uIGRhdGEgdG8gY2hpbGRcbiAgICAvLyB1c2UgZ2V0UmVhbENoaWxkKCkgdG8gaWdub3JlIGFic3RyYWN0IGNvbXBvbmVudHMgZS5nLiBrZWVwLWFsaXZlXG4gICAgdmFyIGNoaWxkID0gZ2V0UmVhbENoaWxkKHJhd0NoaWxkKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkKSB7XG4gICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbGVhdmluZykge1xuICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgIH1cblxuICAgIC8vIGVuc3VyZSBhIGtleSB0aGF0IGlzIHVuaXF1ZSB0byB0aGUgdm5vZGUgdHlwZSBhbmQgdG8gdGhpcyB0cmFuc2l0aW9uXG4gICAgLy8gY29tcG9uZW50IGluc3RhbmNlLiBUaGlzIGtleSB3aWxsIGJlIHVzZWQgdG8gcmVtb3ZlIHBlbmRpbmcgbGVhdmluZyBub2Rlc1xuICAgIC8vIGR1cmluZyBlbnRlcmluZy5cbiAgICB2YXIgaWQgPSBcIl9fdHJhbnNpdGlvbi1cIiArICh0aGlzLl91aWQpICsgXCItXCI7XG4gICAgY2hpbGQua2V5ID0gY2hpbGQua2V5ID09IG51bGxcbiAgICAgID8gY2hpbGQuaXNDb21tZW50XG4gICAgICAgID8gaWQgKyAnY29tbWVudCdcbiAgICAgICAgOiBpZCArIGNoaWxkLnRhZ1xuICAgICAgOiBpc1ByaW1pdGl2ZShjaGlsZC5rZXkpXG4gICAgICAgID8gKFN0cmluZyhjaGlsZC5rZXkpLmluZGV4T2YoaWQpID09PSAwID8gY2hpbGQua2V5IDogaWQgKyBjaGlsZC5rZXkpXG4gICAgICAgIDogY2hpbGQua2V5O1xuXG4gICAgdmFyIGRhdGEgPSAoY2hpbGQuZGF0YSB8fCAoY2hpbGQuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcbiAgICB2YXIgb2xkUmF3Q2hpbGQgPSB0aGlzLl92bm9kZTtcbiAgICB2YXIgb2xkQ2hpbGQgPSBnZXRSZWFsQ2hpbGQob2xkUmF3Q2hpbGQpO1xuXG4gICAgLy8gbWFyayB2LXNob3dcbiAgICAvLyBzbyB0aGF0IHRoZSB0cmFuc2l0aW9uIG1vZHVsZSBjYW4gaGFuZCBvdmVyIHRoZSBjb250cm9sIHRvIHRoZSBkaXJlY3RpdmVcbiAgICBpZiAoY2hpbGQuZGF0YS5kaXJlY3RpdmVzICYmIGNoaWxkLmRhdGEuZGlyZWN0aXZlcy5zb21lKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWUgPT09ICdzaG93JzsgfSkpIHtcbiAgICAgIGNoaWxkLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgb2xkQ2hpbGQgJiZcbiAgICAgIG9sZENoaWxkLmRhdGEgJiZcbiAgICAgICFpc1NhbWVDaGlsZChjaGlsZCwgb2xkQ2hpbGQpICYmXG4gICAgICAhaXNBc3luY1BsYWNlaG9sZGVyKG9sZENoaWxkKVxuICAgICkge1xuICAgICAgLy8gcmVwbGFjZSBvbGQgY2hpbGQgdHJhbnNpdGlvbiBkYXRhIHdpdGggZnJlc2ggb25lXG4gICAgICAvLyBpbXBvcnRhbnQgZm9yIGR5bmFtaWMgdHJhbnNpdGlvbnMhXG4gICAgICB2YXIgb2xkRGF0YSA9IG9sZENoaWxkICYmIChvbGRDaGlsZC5kYXRhLnRyYW5zaXRpb24gPSBleHRlbmQoe30sIGRhdGEpKTtcbiAgICAgIC8vIGhhbmRsZSB0cmFuc2l0aW9uIG1vZGVcbiAgICAgIGlmIChtb2RlID09PSAnb3V0LWluJykge1xuICAgICAgICAvLyByZXR1cm4gcGxhY2Vob2xkZXIgbm9kZSBhbmQgcXVldWUgdXBkYXRlIHdoZW4gbGVhdmUgZmluaXNoZXNcbiAgICAgICAgdGhpcy5fbGVhdmluZyA9IHRydWU7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdhZnRlckxlYXZlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMkMS5fbGVhdmluZyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMkMS4kZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcbiAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gJ2luLW91dCcpIHtcbiAgICAgICAgaWYgKGlzQXN5bmNQbGFjZWhvbGRlcihjaGlsZCkpIHtcbiAgICAgICAgICByZXR1cm4gb2xkUmF3Q2hpbGRcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVsYXllZExlYXZlO1xuICAgICAgICB2YXIgcGVyZm9ybUxlYXZlID0gZnVuY3Rpb24gKCkgeyBkZWxheWVkTGVhdmUoKTsgfTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2FmdGVyRW50ZXInLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnZW50ZXJDYW5jZWxsZWQnLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnZGVsYXlMZWF2ZScsIGZ1bmN0aW9uIChsZWF2ZSkgeyBkZWxheWVkTGVhdmUgPSBsZWF2ZTsgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhd0NoaWxkXG4gIH1cbn07XG5cbi8qICAqL1xuXG4vLyBQcm92aWRlcyB0cmFuc2l0aW9uIHN1cHBvcnQgZm9yIGxpc3QgaXRlbXMuXG4vLyBzdXBwb3J0cyBtb3ZlIHRyYW5zaXRpb25zIHVzaW5nIHRoZSBGTElQIHRlY2huaXF1ZS5cblxuLy8gQmVjYXVzZSB0aGUgdmRvbSdzIGNoaWxkcmVuIHVwZGF0ZSBhbGdvcml0aG0gaXMgXCJ1bnN0YWJsZVwiIC0gaS5lLlxuLy8gaXQgZG9lc24ndCBndWFyYW50ZWUgdGhlIHJlbGF0aXZlIHBvc2l0aW9uaW5nIG9mIHJlbW92ZWQgZWxlbWVudHMsXG4vLyB3ZSBmb3JjZSB0cmFuc2l0aW9uLWdyb3VwIHRvIHVwZGF0ZSBpdHMgY2hpbGRyZW4gaW50byB0d28gcGFzc2VzOlxuLy8gaW4gdGhlIGZpcnN0IHBhc3MsIHdlIHJlbW92ZSBhbGwgbm9kZXMgdGhhdCBuZWVkIHRvIGJlIHJlbW92ZWQsXG4vLyB0cmlnZ2VyaW5nIHRoZWlyIGxlYXZpbmcgdHJhbnNpdGlvbjsgaW4gdGhlIHNlY29uZCBwYXNzLCB3ZSBpbnNlcnQvbW92ZVxuLy8gaW50byB0aGUgZmluYWwgZGVzaXJlZCBzdGF0ZS4gVGhpcyB3YXkgaW4gdGhlIHNlY29uZCBwYXNzIHJlbW92ZWRcbi8vIG5vZGVzIHdpbGwgcmVtYWluIHdoZXJlIHRoZXkgc2hvdWxkIGJlLlxuXG52YXIgcHJvcHMgPSBleHRlbmQoe1xuICB0YWc6IFN0cmluZyxcbiAgbW92ZUNsYXNzOiBTdHJpbmdcbn0sIHRyYW5zaXRpb25Qcm9wcyk7XG5cbmRlbGV0ZSBwcm9wcy5tb2RlO1xuXG52YXIgVHJhbnNpdGlvbkdyb3VwID0ge1xuICBwcm9wczogcHJvcHMsXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGFnID0gdGhpcy50YWcgfHwgdGhpcy4kdm5vZGUuZGF0YS50YWcgfHwgJ3NwYW4nO1xuICAgIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBwcmV2Q2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgdmFyIHJhd0NoaWxkcmVuID0gdGhpcy4kc2xvdHMuZGVmYXVsdCB8fCBbXTtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgdmFyIHRyYW5zaXRpb25EYXRhID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSByYXdDaGlsZHJlbltpXTtcbiAgICAgIGlmIChjLnRhZykge1xuICAgICAgICBpZiAoYy5rZXkgIT0gbnVsbCAmJiBTdHJpbmcoYy5rZXkpLmluZGV4T2YoJ19fdmxpc3QnKSAhPT0gMCkge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2goYyk7XG4gICAgICAgICAgbWFwW2Mua2V5XSA9IGNcbiAgICAgICAgICA7KGMuZGF0YSB8fCAoYy5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG9wdHMgPSBjLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgICAgICAgdmFyIG5hbWUgPSBvcHRzID8gKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcgfHwgJycpIDogYy50YWc7XG4gICAgICAgICAgd2FybigoXCI8dHJhbnNpdGlvbi1ncm91cD4gY2hpbGRyZW4gbXVzdCBiZSBrZXllZDogPFwiICsgbmFtZSArIFwiPlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJldkNoaWxkcmVuKSB7XG4gICAgICB2YXIga2VwdCA9IFtdO1xuICAgICAgdmFyIHJlbW92ZWQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHByZXZDaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgIHZhciBjJDEgPSBwcmV2Q2hpbGRyZW5baSQxXTtcbiAgICAgICAgYyQxLmRhdGEudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICBjJDEuZGF0YS5wb3MgPSBjJDEuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAobWFwW2MkMS5rZXldKSB7XG4gICAgICAgICAga2VwdC5wdXNoKGMkMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlZC5wdXNoKGMkMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMua2VwdCA9IGgodGFnLCBudWxsLCBrZXB0KTtcbiAgICAgIHRoaXMucmVtb3ZlZCA9IHJlbW92ZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGgodGFnLCBudWxsLCBjaGlsZHJlbilcbiAgfSxcblxuICBiZWZvcmVVcGRhdGU6IGZ1bmN0aW9uIGJlZm9yZVVwZGF0ZSAoKSB7XG4gICAgLy8gZm9yY2UgcmVtb3ZpbmcgcGFzc1xuICAgIHRoaXMuX19wYXRjaF9fKFxuICAgICAgdGhpcy5fdm5vZGUsXG4gICAgICB0aGlzLmtlcHQsXG4gICAgICBmYWxzZSwgLy8gaHlkcmF0aW5nXG4gICAgICB0cnVlIC8vIHJlbW92ZU9ubHkgKCFpbXBvcnRhbnQsIGF2b2lkcyB1bm5lY2Vzc2FyeSBtb3ZlcylcbiAgICApO1xuICAgIHRoaXMuX3Zub2RlID0gdGhpcy5rZXB0O1xuICB9LFxuXG4gIHVwZGF0ZWQ6IGZ1bmN0aW9uIHVwZGF0ZWQgKCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuO1xuICAgIHZhciBtb3ZlQ2xhc3MgPSB0aGlzLm1vdmVDbGFzcyB8fCAoKHRoaXMubmFtZSB8fCAndicpICsgJy1tb3ZlJyk7XG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGggfHwgIXRoaXMuaGFzTW92ZShjaGlsZHJlblswXS5lbG0sIG1vdmVDbGFzcykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHdlIGRpdmlkZSB0aGUgd29yayBpbnRvIHRocmVlIGxvb3BzIHRvIGF2b2lkIG1peGluZyBET00gcmVhZHMgYW5kIHdyaXRlc1xuICAgIC8vIGluIGVhY2ggaXRlcmF0aW9uIC0gd2hpY2ggaGVscHMgcHJldmVudCBsYXlvdXQgdGhyYXNoaW5nLlxuICAgIGNoaWxkcmVuLmZvckVhY2goY2FsbFBlbmRpbmdDYnMpO1xuICAgIGNoaWxkcmVuLmZvckVhY2gocmVjb3JkUG9zaXRpb24pO1xuICAgIGNoaWxkcmVuLmZvckVhY2goYXBwbHlUcmFuc2xhdGlvbik7XG5cbiAgICAvLyBmb3JjZSByZWZsb3cgdG8gcHV0IGV2ZXJ5dGhpbmcgaW4gcG9zaXRpb25cbiAgICB2YXIgYm9keSA9IGRvY3VtZW50LmJvZHk7XG4gICAgdmFyIGYgPSBib2R5Lm9mZnNldEhlaWdodDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgaWYgKGMuZGF0YS5tb3ZlZCkge1xuICAgICAgICB2YXIgZWwgPSBjLmVsbTtcbiAgICAgICAgdmFyIHMgPSBlbC5zdHlsZTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnJztcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGVsLl9tb3ZlQ2IgPSBmdW5jdGlvbiBjYiAoZSkge1xuICAgICAgICAgIGlmICghZSB8fCAvdHJhbnNmb3JtJC8udGVzdChlLnByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBjYik7XG4gICAgICAgICAgICBlbC5fbW92ZUNiID0gbnVsbDtcbiAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBoYXNNb3ZlOiBmdW5jdGlvbiBoYXNNb3ZlIChlbCwgbW92ZUNsYXNzKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICghaGFzVHJhbnNpdGlvbikge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHRoaXMuX2hhc01vdmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc01vdmVcbiAgICAgIH1cbiAgICAgIC8vIERldGVjdCB3aGV0aGVyIGFuIGVsZW1lbnQgd2l0aCB0aGUgbW92ZSBjbGFzcyBhcHBsaWVkIGhhc1xuICAgICAgLy8gQ1NTIHRyYW5zaXRpb25zLiBTaW5jZSB0aGUgZWxlbWVudCBtYXkgYmUgaW5zaWRlIGFuIGVudGVyaW5nXG4gICAgICAvLyB0cmFuc2l0aW9uIGF0IHRoaXMgdmVyeSBtb21lbnQsIHdlIG1ha2UgYSBjbG9uZSBvZiBpdCBhbmQgcmVtb3ZlXG4gICAgICAvLyBhbGwgb3RoZXIgdHJhbnNpdGlvbiBjbGFzc2VzIGFwcGxpZWQgdG8gZW5zdXJlIG9ubHkgdGhlIG1vdmUgY2xhc3NcbiAgICAgIC8vIGlzIGFwcGxpZWQuXG4gICAgICB2YXIgY2xvbmUgPSBlbC5jbG9uZU5vZGUoKTtcbiAgICAgIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICAgICAgZWwuX3RyYW5zaXRpb25DbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNscykgeyByZW1vdmVDbGFzcyhjbG9uZSwgY2xzKTsgfSk7XG4gICAgICB9XG4gICAgICBhZGRDbGFzcyhjbG9uZSwgbW92ZUNsYXNzKTtcbiAgICAgIGNsb25lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB0aGlzLiRlbC5hcHBlbmRDaGlsZChjbG9uZSk7XG4gICAgICB2YXIgaW5mbyA9IGdldFRyYW5zaXRpb25JbmZvKGNsb25lKTtcbiAgICAgIHRoaXMuJGVsLnJlbW92ZUNoaWxkKGNsb25lKTtcbiAgICAgIHJldHVybiAodGhpcy5faGFzTW92ZSA9IGluZm8uaGFzVHJhbnNmb3JtKVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMgKGMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjLmVsbS5fbW92ZUNiKSB7XG4gICAgYy5lbG0uX21vdmVDYigpO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX2VudGVyQ2IpIHtcbiAgICBjLmVsbS5fZW50ZXJDYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlY29yZFBvc2l0aW9uIChjKSB7XG4gIGMuZGF0YS5uZXdQb3MgPSBjLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlUcmFuc2xhdGlvbiAoYykge1xuICB2YXIgb2xkUG9zID0gYy5kYXRhLnBvcztcbiAgdmFyIG5ld1BvcyA9IGMuZGF0YS5uZXdQb3M7XG4gIHZhciBkeCA9IG9sZFBvcy5sZWZ0IC0gbmV3UG9zLmxlZnQ7XG4gIHZhciBkeSA9IG9sZFBvcy50b3AgLSBuZXdQb3MudG9wO1xuICBpZiAoZHggfHwgZHkpIHtcbiAgICBjLmRhdGEubW92ZWQgPSB0cnVlO1xuICAgIHZhciBzID0gYy5lbG0uc3R5bGU7XG4gICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgZHggKyBcInB4LFwiICsgZHkgKyBcInB4KVwiO1xuICAgIHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcbiAgfVxufVxuXG52YXIgcGxhdGZvcm1Db21wb25lbnRzID0ge1xuICBUcmFuc2l0aW9uOiBUcmFuc2l0aW9uLFxuICBUcmFuc2l0aW9uR3JvdXA6IFRyYW5zaXRpb25Hcm91cFxufTtcblxuLyogICovXG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gc3BlY2lmaWMgdXRpbHNcblZ1ZSQzLmNvbmZpZy5tdXN0VXNlUHJvcCA9IG11c3RVc2VQcm9wO1xuVnVlJDMuY29uZmlnLmlzUmVzZXJ2ZWRUYWcgPSBpc1Jlc2VydmVkVGFnO1xuVnVlJDMuY29uZmlnLmlzUmVzZXJ2ZWRBdHRyID0gaXNSZXNlcnZlZEF0dHI7XG5WdWUkMy5jb25maWcuZ2V0VGFnTmFtZXNwYWNlID0gZ2V0VGFnTmFtZXNwYWNlO1xuVnVlJDMuY29uZmlnLmlzVW5rbm93bkVsZW1lbnQgPSBpc1Vua25vd25FbGVtZW50O1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHJ1bnRpbWUgZGlyZWN0aXZlcyAmIGNvbXBvbmVudHNcbmV4dGVuZChWdWUkMy5vcHRpb25zLmRpcmVjdGl2ZXMsIHBsYXRmb3JtRGlyZWN0aXZlcyk7XG5leHRlbmQoVnVlJDMub3B0aW9ucy5jb21wb25lbnRzLCBwbGF0Zm9ybUNvbXBvbmVudHMpO1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHBhdGNoIGZ1bmN0aW9uXG5WdWUkMy5wcm90b3R5cGUuX19wYXRjaF9fID0gaW5Ccm93c2VyID8gcGF0Y2ggOiBub29wO1xuXG4vLyBwdWJsaWMgbW91bnQgbWV0aG9kXG5WdWUkMy5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgZWwgPSBlbCAmJiBpbkJyb3dzZXIgPyBxdWVyeShlbCkgOiB1bmRlZmluZWQ7XG4gIHJldHVybiBtb3VudENvbXBvbmVudCh0aGlzLCBlbCwgaHlkcmF0aW5nKVxufTtcblxuLy8gZGV2dG9vbHMgZ2xvYmFsIGhvb2tcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgaWYgKGNvbmZpZy5kZXZ0b29scykge1xuICAgIGlmIChkZXZ0b29scykge1xuICAgICAgZGV2dG9vbHMuZW1pdCgnaW5pdCcsIFZ1ZSQzKTtcbiAgICB9IGVsc2UgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzQ2hyb21lKSB7XG4gICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgICAgJ0Rvd25sb2FkIHRoZSBWdWUgRGV2dG9vbHMgZXh0ZW5zaW9uIGZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOlxcbicgK1xuICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1kZXZ0b29scydcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIGNvbmZpZy5wcm9kdWN0aW9uVGlwICE9PSBmYWxzZSAmJlxuICAgIGluQnJvd3NlciAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCdcbiAgKSB7XG4gICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXG4gICAgICBcIllvdSBhcmUgcnVubmluZyBWdWUgaW4gZGV2ZWxvcG1lbnQgbW9kZS5cXG5cIiArXG4gICAgICBcIk1ha2Ugc3VyZSB0byB0dXJuIG9uIHByb2R1Y3Rpb24gbW9kZSB3aGVuIGRlcGxveWluZyBmb3IgcHJvZHVjdGlvbi5cXG5cIiArXG4gICAgICBcIlNlZSBtb3JlIHRpcHMgYXQgaHR0cHM6Ly92dWVqcy5vcmcvZ3VpZGUvZGVwbG95bWVudC5odG1sXCJcbiAgICApO1xuICB9XG59LCAwKTtcblxuLyogICovXG5cbi8vIGNoZWNrIHdoZXRoZXIgY3VycmVudCBicm93c2VyIGVuY29kZXMgYSBjaGFyIGluc2lkZSBhdHRyaWJ1dGUgdmFsdWVzXG5mdW5jdGlvbiBzaG91bGREZWNvZGUgKGNvbnRlbnQsIGVuY29kZWQpIHtcbiAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBkaXYuaW5uZXJIVE1MID0gXCI8ZGl2IGE9XFxcIlwiICsgY29udGVudCArIFwiXFxcIi8+XCI7XG4gIHJldHVybiBkaXYuaW5uZXJIVE1MLmluZGV4T2YoZW5jb2RlZCkgPiAwXG59XG5cbi8vICMzNjYzXG4vLyBJRSBlbmNvZGVzIG5ld2xpbmVzIGluc2lkZSBhdHRyaWJ1dGUgdmFsdWVzIHdoaWxlIG90aGVyIGJyb3dzZXJzIGRvbid0XG52YXIgc2hvdWxkRGVjb2RlTmV3bGluZXMgPSBpbkJyb3dzZXIgPyBzaG91bGREZWNvZGUoJ1xcbicsICcmIzEwOycpIDogZmFsc2U7XG5cbi8qICAqL1xuXG52YXIgZGVmYXVsdFRhZ1JFID0gL1xce1xceygoPzoufFxcbikrPylcXH1cXH0vZztcbnZhciByZWdleEVzY2FwZVJFID0gL1stLiorP14ke30oKXxbXFxdXFwvXFxcXF0vZztcblxudmFyIGJ1aWxkUmVnZXggPSBjYWNoZWQoZnVuY3Rpb24gKGRlbGltaXRlcnMpIHtcbiAgdmFyIG9wZW4gPSBkZWxpbWl0ZXJzWzBdLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xuICB2YXIgY2xvc2UgPSBkZWxpbWl0ZXJzWzFdLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xuICByZXR1cm4gbmV3IFJlZ0V4cChvcGVuICsgJygoPzoufFxcXFxuKSs/KScgKyBjbG9zZSwgJ2cnKVxufSk7XG5cbmZ1bmN0aW9uIHBhcnNlVGV4dCAoXG4gIHRleHQsXG4gIGRlbGltaXRlcnNcbikge1xuICB2YXIgdGFnUkUgPSBkZWxpbWl0ZXJzID8gYnVpbGRSZWdleChkZWxpbWl0ZXJzKSA6IGRlZmF1bHRUYWdSRTtcbiAgaWYgKCF0YWdSRS50ZXN0KHRleHQpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHRva2VucyA9IFtdO1xuICB2YXIgbGFzdEluZGV4ID0gdGFnUkUubGFzdEluZGV4ID0gMDtcbiAgdmFyIG1hdGNoLCBpbmRleDtcbiAgd2hpbGUgKChtYXRjaCA9IHRhZ1JFLmV4ZWModGV4dCkpKSB7XG4gICAgaW5kZXggPSBtYXRjaC5pbmRleDtcbiAgICAvLyBwdXNoIHRleHQgdG9rZW5cbiAgICBpZiAoaW5kZXggPiBsYXN0SW5kZXgpIHtcbiAgICAgIHRva2Vucy5wdXNoKEpTT04uc3RyaW5naWZ5KHRleHQuc2xpY2UobGFzdEluZGV4LCBpbmRleCkpKTtcbiAgICB9XG4gICAgLy8gdGFnIHRva2VuXG4gICAgdmFyIGV4cCA9IHBhcnNlRmlsdGVycyhtYXRjaFsxXS50cmltKCkpO1xuICAgIHRva2Vucy5wdXNoKChcIl9zKFwiICsgZXhwICsgXCIpXCIpKTtcbiAgICBsYXN0SW5kZXggPSBpbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgfVxuICBpZiAobGFzdEluZGV4IDwgdGV4dC5sZW5ndGgpIHtcbiAgICB0b2tlbnMucHVzaChKU09OLnN0cmluZ2lmeSh0ZXh0LnNsaWNlKGxhc3RJbmRleCkpKTtcbiAgfVxuICByZXR1cm4gdG9rZW5zLmpvaW4oJysnKVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSAoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIHdhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHZhciBzdGF0aWNDbGFzcyA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdjbGFzcycpO1xuICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgc3RhdGljQ2xhc3MpIHtcbiAgICB2YXIgZXhwcmVzc2lvbiA9IHBhcnNlVGV4dChzdGF0aWNDbGFzcywgb3B0aW9ucy5kZWxpbWl0ZXJzKTtcbiAgICBpZiAoZXhwcmVzc2lvbikge1xuICAgICAgd2FybihcbiAgICAgICAgXCJjbGFzcz1cXFwiXCIgKyBzdGF0aWNDbGFzcyArIFwiXFxcIjogXCIgK1xuICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgY2xhc3M9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDpjbGFzcz1cInZhbFwiPi4nXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBpZiAoc3RhdGljQ2xhc3MpIHtcbiAgICBlbC5zdGF0aWNDbGFzcyA9IEpTT04uc3RyaW5naWZ5KHN0YXRpY0NsYXNzKTtcbiAgfVxuICB2YXIgY2xhc3NCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdjbGFzcycsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XG4gIGlmIChjbGFzc0JpbmRpbmcpIHtcbiAgICBlbC5jbGFzc0JpbmRpbmcgPSBjbGFzc0JpbmRpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSAoZWwpIHtcbiAgdmFyIGRhdGEgPSAnJztcbiAgaWYgKGVsLnN0YXRpY0NsYXNzKSB7XG4gICAgZGF0YSArPSBcInN0YXRpY0NsYXNzOlwiICsgKGVsLnN0YXRpY0NsYXNzKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5jbGFzc0JpbmRpbmcpIHtcbiAgICBkYXRhICs9IFwiY2xhc3M6XCIgKyAoZWwuY2xhc3NCaW5kaW5nKSArIFwiLFwiO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbnZhciBrbGFzcyQxID0ge1xuICBzdGF0aWNLZXlzOiBbJ3N0YXRpY0NsYXNzJ10sXG4gIHRyYW5zZm9ybU5vZGU6IHRyYW5zZm9ybU5vZGUsXG4gIGdlbkRhdGE6IGdlbkRhdGFcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Ob2RlJDEgKGVsLCBvcHRpb25zKSB7XG4gIHZhciB3YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICB2YXIgc3RhdGljU3R5bGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc3R5bGUnKTtcbiAgaWYgKHN0YXRpY1N0eWxlKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAge1xuICAgICAgdmFyIGV4cHJlc3Npb24gPSBwYXJzZVRleHQoc3RhdGljU3R5bGUsIG9wdGlvbnMuZGVsaW1pdGVycyk7XG4gICAgICBpZiAoZXhwcmVzc2lvbikge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwic3R5bGU9XFxcIlwiICsgc3RhdGljU3R5bGUgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IHN0eWxlPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6c3R5bGU9XCJ2YWxcIj4uJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBlbC5zdGF0aWNTdHlsZSA9IEpTT04uc3RyaW5naWZ5KHBhcnNlU3R5bGVUZXh0KHN0YXRpY1N0eWxlKSk7XG4gIH1cblxuICB2YXIgc3R5bGVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzdHlsZScsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XG4gIGlmIChzdHlsZUJpbmRpbmcpIHtcbiAgICBlbC5zdHlsZUJpbmRpbmcgPSBzdHlsZUJpbmRpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSQxIChlbCkge1xuICB2YXIgZGF0YSA9ICcnO1xuICBpZiAoZWwuc3RhdGljU3R5bGUpIHtcbiAgICBkYXRhICs9IFwic3RhdGljU3R5bGU6XCIgKyAoZWwuc3RhdGljU3R5bGUpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLnN0eWxlQmluZGluZykge1xuICAgIGRhdGEgKz0gXCJzdHlsZTooXCIgKyAoZWwuc3R5bGVCaW5kaW5nKSArIFwiKSxcIjtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG52YXIgc3R5bGUkMSA9IHtcbiAgc3RhdGljS2V5czogWydzdGF0aWNTdHlsZSddLFxuICB0cmFuc2Zvcm1Ob2RlOiB0cmFuc2Zvcm1Ob2RlJDEsXG4gIGdlbkRhdGE6IGdlbkRhdGEkMVxufTtcblxudmFyIG1vZHVsZXMkMSA9IFtcbiAga2xhc3MkMSxcbiAgc3R5bGUkMVxuXTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHRleHQgKGVsLCBkaXIpIHtcbiAgaWYgKGRpci52YWx1ZSkge1xuICAgIGFkZFByb3AoZWwsICd0ZXh0Q29udGVudCcsIChcIl9zKFwiICsgKGRpci52YWx1ZSkgKyBcIilcIikpO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBodG1sIChlbCwgZGlyKSB7XG4gIGlmIChkaXIudmFsdWUpIHtcbiAgICBhZGRQcm9wKGVsLCAnaW5uZXJIVE1MJywgKFwiX3MoXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKSk7XG4gIH1cbn1cblxudmFyIGRpcmVjdGl2ZXMkMSA9IHtcbiAgbW9kZWw6IG1vZGVsLFxuICB0ZXh0OiB0ZXh0LFxuICBodG1sOiBodG1sXG59O1xuXG4vKiAgKi9cblxudmFyIGlzVW5hcnlUYWcgPSBtYWtlTWFwKFxuICAnYXJlYSxiYXNlLGJyLGNvbCxlbWJlZCxmcmFtZSxocixpbWcsaW5wdXQsaXNpbmRleCxrZXlnZW4sJyArXG4gICdsaW5rLG1ldGEscGFyYW0sc291cmNlLHRyYWNrLHdicidcbik7XG5cbi8vIEVsZW1lbnRzIHRoYXQgeW91IGNhbiwgaW50ZW50aW9uYWxseSwgbGVhdmUgb3BlblxuLy8gKGFuZCB3aGljaCBjbG9zZSB0aGVtc2VsdmVzKVxudmFyIGNhbkJlTGVmdE9wZW5UYWcgPSBtYWtlTWFwKFxuICAnY29sZ3JvdXAsZGQsZHQsbGksb3B0aW9ucyxwLHRkLHRmb290LHRoLHRoZWFkLHRyLHNvdXJjZSdcbik7XG5cbi8vIEhUTUw1IHRhZ3MgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5kaWNlcy5odG1sI2VsZW1lbnRzLTNcbi8vIFBocmFzaW5nIENvbnRlbnQgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZG9tLmh0bWwjcGhyYXNpbmctY29udGVudFxudmFyIGlzTm9uUGhyYXNpbmdUYWcgPSBtYWtlTWFwKFxuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGJhc2UsYmxvY2txdW90ZSxib2R5LGNhcHRpb24sY29sLGNvbGdyb3VwLGRkLCcgK1xuICAnZGV0YWlscyxkaWFsb2csZGl2LGRsLGR0LGZpZWxkc2V0LGZpZ2NhcHRpb24sZmlndXJlLGZvb3Rlcixmb3JtLCcgK1xuICAnaDEsaDIsaDMsaDQsaDUsaDYsaGVhZCxoZWFkZXIsaGdyb3VwLGhyLGh0bWwsbGVnZW5kLGxpLG1lbnVpdGVtLG1ldGEsJyArXG4gICdvcHRncm91cCxvcHRpb24scGFyYW0scnAscnQsc291cmNlLHN0eWxlLHN1bW1hcnksdGJvZHksdGQsdGZvb3QsdGgsdGhlYWQsJyArXG4gICd0aXRsZSx0cix0cmFjaydcbik7XG5cbi8qICAqL1xuXG52YXIgYmFzZU9wdGlvbnMgPSB7XG4gIGV4cGVjdEhUTUw6IHRydWUsXG4gIG1vZHVsZXM6IG1vZHVsZXMkMSxcbiAgZGlyZWN0aXZlczogZGlyZWN0aXZlcyQxLFxuICBpc1ByZVRhZzogaXNQcmVUYWcsXG4gIGlzVW5hcnlUYWc6IGlzVW5hcnlUYWcsXG4gIG11c3RVc2VQcm9wOiBtdXN0VXNlUHJvcCxcbiAgY2FuQmVMZWZ0T3BlblRhZzogY2FuQmVMZWZ0T3BlblRhZyxcbiAgaXNSZXNlcnZlZFRhZzogaXNSZXNlcnZlZFRhZyxcbiAgZ2V0VGFnTmFtZXNwYWNlOiBnZXRUYWdOYW1lc3BhY2UsXG4gIHN0YXRpY0tleXM6IGdlblN0YXRpY0tleXMobW9kdWxlcyQxKVxufTtcblxuLyogICovXG5cbnZhciBkZWNvZGVyO1xuXG52YXIgaGUgPSB7XG4gIGRlY29kZTogZnVuY3Rpb24gZGVjb2RlIChodG1sKSB7XG4gICAgZGVjb2RlciA9IGRlY29kZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGVjb2Rlci5pbm5lckhUTUwgPSBodG1sO1xuICAgIHJldHVybiBkZWNvZGVyLnRleHRDb250ZW50XG4gIH1cbn07XG5cbi8qKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgaXQncyBtb3N0bHkgdmVuZG9yIGNvZGUuXG4gKi9cblxuLyohXG4gKiBIVE1MIFBhcnNlciBCeSBKb2huIFJlc2lnIChlam9obi5vcmcpXG4gKiBNb2RpZmllZCBieSBKdXJpeSBcImthbmdheFwiIFpheXRzZXZcbiAqIE9yaWdpbmFsIGNvZGUgYnkgRXJpayBBcnZpZHNzb24sIE1vemlsbGEgUHVibGljIExpY2Vuc2VcbiAqIGh0dHA6Ly9lcmlrLmVhZS5uZXQvc2ltcGxlaHRtbHBhcnNlci9zaW1wbGVodG1scGFyc2VyLmpzXG4gKi9cblxuLy8gUmVndWxhciBFeHByZXNzaW9ucyBmb3IgcGFyc2luZyB0YWdzIGFuZCBhdHRyaWJ1dGVzXG52YXIgc2luZ2xlQXR0cklkZW50aWZpZXIgPSAvKFteXFxzXCInPD4vPV0rKS87XG52YXIgc2luZ2xlQXR0ckFzc2lnbiA9IC8oPzo9KS87XG52YXIgc2luZ2xlQXR0clZhbHVlcyA9IFtcbiAgLy8gYXR0ciB2YWx1ZSBkb3VibGUgcXVvdGVzXG4gIC9cIihbXlwiXSopXCIrLy5zb3VyY2UsXG4gIC8vIGF0dHIgdmFsdWUsIHNpbmdsZSBxdW90ZXNcbiAgLycoW14nXSopJysvLnNvdXJjZSxcbiAgLy8gYXR0ciB2YWx1ZSwgbm8gcXVvdGVzXG4gIC8oW15cXHNcIic9PD5gXSspLy5zb3VyY2Vcbl07XG52YXIgYXR0cmlidXRlID0gbmV3IFJlZ0V4cChcbiAgJ15cXFxccyonICsgc2luZ2xlQXR0cklkZW50aWZpZXIuc291cmNlICtcbiAgJyg/OlxcXFxzKignICsgc2luZ2xlQXR0ckFzc2lnbi5zb3VyY2UgKyAnKScgK1xuICAnXFxcXHMqKD86JyArIHNpbmdsZUF0dHJWYWx1ZXMuam9pbignfCcpICsgJykpPydcbik7XG5cbi8vIGNvdWxkIHVzZSBodHRwczovL3d3dy53My5vcmcvVFIvMTk5OS9SRUMteG1sLW5hbWVzLTE5OTkwMTE0LyNOVC1RTmFtZVxuLy8gYnV0IGZvciBWdWUgdGVtcGxhdGVzIHdlIGNhbiBlbmZvcmNlIGEgc2ltcGxlIGNoYXJzZXRcbnZhciBuY25hbWUgPSAnW2EtekEtWl9dW1xcXFx3XFxcXC1cXFxcLl0qJztcbnZhciBxbmFtZUNhcHR1cmUgPSAnKCg/OicgKyBuY25hbWUgKyAnXFxcXDopPycgKyBuY25hbWUgKyAnKSc7XG52YXIgc3RhcnRUYWdPcGVuID0gbmV3IFJlZ0V4cCgnXjwnICsgcW5hbWVDYXB0dXJlKTtcbnZhciBzdGFydFRhZ0Nsb3NlID0gL15cXHMqKFxcLz8pPi87XG52YXIgZW5kVGFnID0gbmV3IFJlZ0V4cCgnXjxcXFxcLycgKyBxbmFtZUNhcHR1cmUgKyAnW14+XSo+Jyk7XG52YXIgZG9jdHlwZSA9IC9ePCFET0NUWVBFIFtePl0rPi9pO1xudmFyIGNvbW1lbnQgPSAvXjwhLS0vO1xudmFyIGNvbmRpdGlvbmFsQ29tbWVudCA9IC9ePCFcXFsvO1xuXG52YXIgSVNfUkVHRVhfQ0FQVFVSSU5HX0JST0tFTiA9IGZhbHNlO1xuJ3gnLnJlcGxhY2UoL3goLik/L2csIGZ1bmN0aW9uIChtLCBnKSB7XG4gIElTX1JFR0VYX0NBUFRVUklOR19CUk9LRU4gPSBnID09PSAnJztcbn0pO1xuXG4vLyBTcGVjaWFsIEVsZW1lbnRzIChjYW4gY29udGFpbiBhbnl0aGluZylcbnZhciBpc1BsYWluVGV4dEVsZW1lbnQgPSBtYWtlTWFwKCdzY3JpcHQsc3R5bGUsdGV4dGFyZWEnLCB0cnVlKTtcbnZhciByZUNhY2hlID0ge307XG5cbnZhciBkZWNvZGluZ01hcCA9IHtcbiAgJyZsdDsnOiAnPCcsXG4gICcmZ3Q7JzogJz4nLFxuICAnJnF1b3Q7JzogJ1wiJyxcbiAgJyZhbXA7JzogJyYnLFxuICAnJiMxMDsnOiAnXFxuJ1xufTtcbnZhciBlbmNvZGVkQXR0ciA9IC8mKD86bHR8Z3R8cXVvdHxhbXApOy9nO1xudmFyIGVuY29kZWRBdHRyV2l0aE5ld0xpbmVzID0gLyYoPzpsdHxndHxxdW90fGFtcHwjMTApOy9nO1xuXG4vLyAjNTk5MlxudmFyIGlzSWdub3JlTmV3bGluZVRhZyA9IG1ha2VNYXAoJ3ByZSx0ZXh0YXJlYScsIHRydWUpO1xudmFyIHNob3VsZElnbm9yZUZpcnN0TmV3bGluZSA9IGZ1bmN0aW9uICh0YWcsIGh0bWwpIHsgcmV0dXJuIHRhZyAmJiBpc0lnbm9yZU5ld2xpbmVUYWcodGFnKSAmJiBodG1sWzBdID09PSAnXFxuJzsgfTtcblxuZnVuY3Rpb24gZGVjb2RlQXR0ciAodmFsdWUsIHNob3VsZERlY29kZU5ld2xpbmVzKSB7XG4gIHZhciByZSA9IHNob3VsZERlY29kZU5ld2xpbmVzID8gZW5jb2RlZEF0dHJXaXRoTmV3TGluZXMgOiBlbmNvZGVkQXR0cjtcbiAgcmV0dXJuIHZhbHVlLnJlcGxhY2UocmUsIGZ1bmN0aW9uIChtYXRjaCkgeyByZXR1cm4gZGVjb2RpbmdNYXBbbWF0Y2hdOyB9KVxufVxuXG5mdW5jdGlvbiBwYXJzZUhUTUwgKGh0bWwsIG9wdGlvbnMpIHtcbiAgdmFyIHN0YWNrID0gW107XG4gIHZhciBleHBlY3RIVE1MID0gb3B0aW9ucy5leHBlY3RIVE1MO1xuICB2YXIgaXNVbmFyeVRhZyQkMSA9IG9wdGlvbnMuaXNVbmFyeVRhZyB8fCBubztcbiAgdmFyIGNhbkJlTGVmdE9wZW5UYWckJDEgPSBvcHRpb25zLmNhbkJlTGVmdE9wZW5UYWcgfHwgbm87XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0LCBsYXN0VGFnO1xuICB3aGlsZSAoaHRtbCkge1xuICAgIGxhc3QgPSBodG1sO1xuICAgIC8vIE1ha2Ugc3VyZSB3ZSdyZSBub3QgaW4gYSBwbGFpbnRleHQgY29udGVudCBlbGVtZW50IGxpa2Ugc2NyaXB0L3N0eWxlXG4gICAgaWYgKCFsYXN0VGFnIHx8ICFpc1BsYWluVGV4dEVsZW1lbnQobGFzdFRhZykpIHtcbiAgICAgIGlmIChzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUobGFzdFRhZywgaHRtbCkpIHtcbiAgICAgICAgYWR2YW5jZSgxKTtcbiAgICAgIH1cbiAgICAgIHZhciB0ZXh0RW5kID0gaHRtbC5pbmRleE9mKCc8Jyk7XG4gICAgICBpZiAodGV4dEVuZCA9PT0gMCkge1xuICAgICAgICAvLyBDb21tZW50OlxuICAgICAgICBpZiAoY29tbWVudC50ZXN0KGh0bWwpKSB7XG4gICAgICAgICAgdmFyIGNvbW1lbnRFbmQgPSBodG1sLmluZGV4T2YoJy0tPicpO1xuXG4gICAgICAgICAgaWYgKGNvbW1lbnRFbmQgPj0gMCkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2hvdWxkS2VlcENvbW1lbnQpIHtcbiAgICAgICAgICAgICAgb3B0aW9ucy5jb21tZW50KGh0bWwuc3Vic3RyaW5nKDQsIGNvbW1lbnRFbmQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkdmFuY2UoY29tbWVudEVuZCArIDMpO1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbmRpdGlvbmFsX2NvbW1lbnQjRG93bmxldmVsLXJldmVhbGVkX2NvbmRpdGlvbmFsX2NvbW1lbnRcbiAgICAgICAgaWYgKGNvbmRpdGlvbmFsQ29tbWVudC50ZXN0KGh0bWwpKSB7XG4gICAgICAgICAgdmFyIGNvbmRpdGlvbmFsRW5kID0gaHRtbC5pbmRleE9mKCddPicpO1xuXG4gICAgICAgICAgaWYgKGNvbmRpdGlvbmFsRW5kID49IDApIHtcbiAgICAgICAgICAgIGFkdmFuY2UoY29uZGl0aW9uYWxFbmQgKyAyKTtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG9jdHlwZTpcbiAgICAgICAgdmFyIGRvY3R5cGVNYXRjaCA9IGh0bWwubWF0Y2goZG9jdHlwZSk7XG4gICAgICAgIGlmIChkb2N0eXBlTWF0Y2gpIHtcbiAgICAgICAgICBhZHZhbmNlKGRvY3R5cGVNYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbmQgdGFnOlxuICAgICAgICB2YXIgZW5kVGFnTWF0Y2ggPSBodG1sLm1hdGNoKGVuZFRhZyk7XG4gICAgICAgIGlmIChlbmRUYWdNYXRjaCkge1xuICAgICAgICAgIHZhciBjdXJJbmRleCA9IGluZGV4O1xuICAgICAgICAgIGFkdmFuY2UoZW5kVGFnTWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICBwYXJzZUVuZFRhZyhlbmRUYWdNYXRjaFsxXSwgY3VySW5kZXgsIGluZGV4KTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RhcnQgdGFnOlxuICAgICAgICB2YXIgc3RhcnRUYWdNYXRjaCA9IHBhcnNlU3RhcnRUYWcoKTtcbiAgICAgICAgaWYgKHN0YXJ0VGFnTWF0Y2gpIHtcbiAgICAgICAgICBoYW5kbGVTdGFydFRhZyhzdGFydFRhZ01hdGNoKTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB0ZXh0ID0gKHZvaWQgMCksIHJlc3QgPSAodm9pZCAwKSwgbmV4dCA9ICh2b2lkIDApO1xuICAgICAgaWYgKHRleHRFbmQgPj0gMCkge1xuICAgICAgICByZXN0ID0gaHRtbC5zbGljZSh0ZXh0RW5kKTtcbiAgICAgICAgd2hpbGUgKFxuICAgICAgICAgICFlbmRUYWcudGVzdChyZXN0KSAmJlxuICAgICAgICAgICFzdGFydFRhZ09wZW4udGVzdChyZXN0KSAmJlxuICAgICAgICAgICFjb21tZW50LnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAhY29uZGl0aW9uYWxDb21tZW50LnRlc3QocmVzdClcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gPCBpbiBwbGFpbiB0ZXh0LCBiZSBmb3JnaXZpbmcgYW5kIHRyZWF0IGl0IGFzIHRleHRcbiAgICAgICAgICBuZXh0ID0gcmVzdC5pbmRleE9mKCc8JywgMSk7XG4gICAgICAgICAgaWYgKG5leHQgPCAwKSB7IGJyZWFrIH1cbiAgICAgICAgICB0ZXh0RW5kICs9IG5leHQ7XG4gICAgICAgICAgcmVzdCA9IGh0bWwuc2xpY2UodGV4dEVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGV4dCA9IGh0bWwuc3Vic3RyaW5nKDAsIHRleHRFbmQpO1xuICAgICAgICBhZHZhbmNlKHRleHRFbmQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGV4dEVuZCA8IDApIHtcbiAgICAgICAgdGV4dCA9IGh0bWw7XG4gICAgICAgIGh0bWwgPSAnJztcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuY2hhcnMgJiYgdGV4dCkge1xuICAgICAgICBvcHRpb25zLmNoYXJzKHRleHQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZW5kVGFnTGVuZ3RoID0gMDtcbiAgICAgIHZhciBzdGFja2VkVGFnID0gbGFzdFRhZy50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIHJlU3RhY2tlZFRhZyA9IHJlQ2FjaGVbc3RhY2tlZFRhZ10gfHwgKHJlQ2FjaGVbc3RhY2tlZFRhZ10gPSBuZXcgUmVnRXhwKCcoW1xcXFxzXFxcXFNdKj8pKDwvJyArIHN0YWNrZWRUYWcgKyAnW14+XSo+KScsICdpJykpO1xuICAgICAgdmFyIHJlc3QkMSA9IGh0bWwucmVwbGFjZShyZVN0YWNrZWRUYWcsIGZ1bmN0aW9uIChhbGwsIHRleHQsIGVuZFRhZykge1xuICAgICAgICBlbmRUYWdMZW5ndGggPSBlbmRUYWcubGVuZ3RoO1xuICAgICAgICBpZiAoIWlzUGxhaW5UZXh0RWxlbWVudChzdGFja2VkVGFnKSAmJiBzdGFja2VkVGFnICE9PSAnbm9zY3JpcHQnKSB7XG4gICAgICAgICAgdGV4dCA9IHRleHRcbiAgICAgICAgICAgIC5yZXBsYWNlKC88IS0tKFtcXHNcXFNdKj8pLS0+L2csICckMScpXG4gICAgICAgICAgICAucmVwbGFjZSgvPCFcXFtDREFUQVxcWyhbXFxzXFxTXSo/KV1dPi9nLCAnJDEnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lKHN0YWNrZWRUYWcsIHRleHQpKSB7XG4gICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuY2hhcnMpIHtcbiAgICAgICAgICBvcHRpb25zLmNoYXJzKHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJ1xuICAgICAgfSk7XG4gICAgICBpbmRleCArPSBodG1sLmxlbmd0aCAtIHJlc3QkMS5sZW5ndGg7XG4gICAgICBodG1sID0gcmVzdCQxO1xuICAgICAgcGFyc2VFbmRUYWcoc3RhY2tlZFRhZywgaW5kZXggLSBlbmRUYWdMZW5ndGgsIGluZGV4KTtcbiAgICB9XG5cbiAgICBpZiAoaHRtbCA9PT0gbGFzdCkge1xuICAgICAgb3B0aW9ucy5jaGFycyAmJiBvcHRpb25zLmNoYXJzKGh0bWwpO1xuICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmICFzdGFjay5sZW5ndGggJiYgb3B0aW9ucy53YXJuKSB7XG4gICAgICAgIG9wdGlvbnMud2FybigoXCJNYWwtZm9ybWF0dGVkIHRhZyBhdCBlbmQgb2YgdGVtcGxhdGU6IFxcXCJcIiArIGh0bWwgKyBcIlxcXCJcIikpO1xuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICAvLyBDbGVhbiB1cCBhbnkgcmVtYWluaW5nIHRhZ3NcbiAgcGFyc2VFbmRUYWcoKTtcblxuICBmdW5jdGlvbiBhZHZhbmNlIChuKSB7XG4gICAgaW5kZXggKz0gbjtcbiAgICBodG1sID0gaHRtbC5zdWJzdHJpbmcobik7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVN0YXJ0VGFnICgpIHtcbiAgICB2YXIgc3RhcnQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnT3Blbik7XG4gICAgaWYgKHN0YXJ0KSB7XG4gICAgICB2YXIgbWF0Y2ggPSB7XG4gICAgICAgIHRhZ05hbWU6IHN0YXJ0WzFdLFxuICAgICAgICBhdHRyczogW10sXG4gICAgICAgIHN0YXJ0OiBpbmRleFxuICAgICAgfTtcbiAgICAgIGFkdmFuY2Uoc3RhcnRbMF0ubGVuZ3RoKTtcbiAgICAgIHZhciBlbmQsIGF0dHI7XG4gICAgICB3aGlsZSAoIShlbmQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnQ2xvc2UpKSAmJiAoYXR0ciA9IGh0bWwubWF0Y2goYXR0cmlidXRlKSkpIHtcbiAgICAgICAgYWR2YW5jZShhdHRyWzBdLmxlbmd0aCk7XG4gICAgICAgIG1hdGNoLmF0dHJzLnB1c2goYXR0cik7XG4gICAgICB9XG4gICAgICBpZiAoZW5kKSB7XG4gICAgICAgIG1hdGNoLnVuYXJ5U2xhc2ggPSBlbmRbMV07XG4gICAgICAgIGFkdmFuY2UoZW5kWzBdLmxlbmd0aCk7XG4gICAgICAgIG1hdGNoLmVuZCA9IGluZGV4O1xuICAgICAgICByZXR1cm4gbWF0Y2hcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVTdGFydFRhZyAobWF0Y2gpIHtcbiAgICB2YXIgdGFnTmFtZSA9IG1hdGNoLnRhZ05hbWU7XG4gICAgdmFyIHVuYXJ5U2xhc2ggPSBtYXRjaC51bmFyeVNsYXNoO1xuXG4gICAgaWYgKGV4cGVjdEhUTUwpIHtcbiAgICAgIGlmIChsYXN0VGFnID09PSAncCcgJiYgaXNOb25QaHJhc2luZ1RhZyh0YWdOYW1lKSkge1xuICAgICAgICBwYXJzZUVuZFRhZyhsYXN0VGFnKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYW5CZUxlZnRPcGVuVGFnJCQxKHRhZ05hbWUpICYmIGxhc3RUYWcgPT09IHRhZ05hbWUpIHtcbiAgICAgICAgcGFyc2VFbmRUYWcodGFnTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHVuYXJ5ID0gaXNVbmFyeVRhZyQkMSh0YWdOYW1lKSB8fCAhIXVuYXJ5U2xhc2g7XG5cbiAgICB2YXIgbCA9IG1hdGNoLmF0dHJzLmxlbmd0aDtcbiAgICB2YXIgYXR0cnMgPSBuZXcgQXJyYXkobCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhcmdzID0gbWF0Y2guYXR0cnNbaV07XG4gICAgICAvLyBoYWNraXNoIHdvcmsgYXJvdW5kIEZGIGJ1ZyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0zNjk3NzhcbiAgICAgIGlmIChJU19SRUdFWF9DQVBUVVJJTkdfQlJPS0VOICYmIGFyZ3NbMF0uaW5kZXhPZignXCJcIicpID09PSAtMSkge1xuICAgICAgICBpZiAoYXJnc1szXSA9PT0gJycpIHsgZGVsZXRlIGFyZ3NbM107IH1cbiAgICAgICAgaWYgKGFyZ3NbNF0gPT09ICcnKSB7IGRlbGV0ZSBhcmdzWzRdOyB9XG4gICAgICAgIGlmIChhcmdzWzVdID09PSAnJykgeyBkZWxldGUgYXJnc1s1XTsgfVxuICAgICAgfVxuICAgICAgdmFyIHZhbHVlID0gYXJnc1szXSB8fCBhcmdzWzRdIHx8IGFyZ3NbNV0gfHwgJyc7XG4gICAgICBhdHRyc1tpXSA9IHtcbiAgICAgICAgbmFtZTogYXJnc1sxXSxcbiAgICAgICAgdmFsdWU6IGRlY29kZUF0dHIoXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lc1xuICAgICAgICApXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICghdW5hcnkpIHtcbiAgICAgIHN0YWNrLnB1c2goeyB0YWc6IHRhZ05hbWUsIGxvd2VyQ2FzZWRUYWc6IHRhZ05hbWUudG9Mb3dlckNhc2UoKSwgYXR0cnM6IGF0dHJzIH0pO1xuICAgICAgbGFzdFRhZyA9IHRhZ05hbWU7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgYXR0cnMsIHVuYXJ5LCBtYXRjaC5zdGFydCwgbWF0Y2guZW5kKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUVuZFRhZyAodGFnTmFtZSwgc3RhcnQsIGVuZCkge1xuICAgIHZhciBwb3MsIGxvd2VyQ2FzZWRUYWdOYW1lO1xuICAgIGlmIChzdGFydCA9PSBudWxsKSB7IHN0YXJ0ID0gaW5kZXg7IH1cbiAgICBpZiAoZW5kID09IG51bGwpIHsgZW5kID0gaW5kZXg7IH1cblxuICAgIGlmICh0YWdOYW1lKSB7XG4gICAgICBsb3dlckNhc2VkVGFnTmFtZSA9IHRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICAvLyBGaW5kIHRoZSBjbG9zZXN0IG9wZW5lZCB0YWcgb2YgdGhlIHNhbWUgdHlwZVxuICAgIGlmICh0YWdOYW1lKSB7XG4gICAgICBmb3IgKHBvcyA9IHN0YWNrLmxlbmd0aCAtIDE7IHBvcyA+PSAwOyBwb3MtLSkge1xuICAgICAgICBpZiAoc3RhY2tbcG9zXS5sb3dlckNhc2VkVGFnID09PSBsb3dlckNhc2VkVGFnTmFtZSkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgbm8gdGFnIG5hbWUgaXMgcHJvdmlkZWQsIGNsZWFuIHNob3BcbiAgICAgIHBvcyA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAvLyBDbG9zZSBhbGwgdGhlIG9wZW4gZWxlbWVudHMsIHVwIHRoZSBzdGFja1xuICAgICAgZm9yICh2YXIgaSA9IHN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gcG9zOyBpLS0pIHtcbiAgICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgKGkgPiBwb3MgfHwgIXRhZ05hbWUpICYmXG4gICAgICAgICAgb3B0aW9ucy53YXJuXG4gICAgICAgICkge1xuICAgICAgICAgIG9wdGlvbnMud2FybihcbiAgICAgICAgICAgIChcInRhZyA8XCIgKyAoc3RhY2tbaV0udGFnKSArIFwiPiBoYXMgbm8gbWF0Y2hpbmcgZW5kIHRhZy5cIilcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmVuZCkge1xuICAgICAgICAgIG9wdGlvbnMuZW5kKHN0YWNrW2ldLnRhZywgc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIHRoZSBvcGVuIGVsZW1lbnRzIGZyb20gdGhlIHN0YWNrXG4gICAgICBzdGFjay5sZW5ndGggPSBwb3M7XG4gICAgICBsYXN0VGFnID0gcG9zICYmIHN0YWNrW3BvcyAtIDFdLnRhZztcbiAgICB9IGVsc2UgaWYgKGxvd2VyQ2FzZWRUYWdOYW1lID09PSAnYnInKSB7XG4gICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIFtdLCB0cnVlLCBzdGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxvd2VyQ2FzZWRUYWdOYW1lID09PSAncCcpIHtcbiAgICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgW10sIGZhbHNlLCBzdGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmVuZCkge1xuICAgICAgICBvcHRpb25zLmVuZCh0YWdOYW1lLCBzdGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBvblJFID0gL15AfF52LW9uOi87XG52YXIgZGlyUkUgPSAvXnYtfF5AfF46LztcbnZhciBmb3JBbGlhc1JFID0gLyguKj8pXFxzKyg/OmlufG9mKVxccysoLiopLztcbnZhciBmb3JJdGVyYXRvclJFID0gL1xcKChcXHtbXn1dKlxcfXxbXixdKiksKFteLF0qKSg/OiwoW14sXSopKT9cXCkvO1xuXG52YXIgYXJnUkUgPSAvOiguKikkLztcbnZhciBiaW5kUkUgPSAvXjp8XnYtYmluZDovO1xudmFyIG1vZGlmaWVyUkUgPSAvXFwuW14uXSsvZztcblxudmFyIGRlY29kZUhUTUxDYWNoZWQgPSBjYWNoZWQoaGUuZGVjb2RlKTtcblxuLy8gY29uZmlndXJhYmxlIHN0YXRlXG52YXIgd2FybiQyO1xudmFyIGRlbGltaXRlcnM7XG52YXIgdHJhbnNmb3JtcztcbnZhciBwcmVUcmFuc2Zvcm1zO1xudmFyIHBvc3RUcmFuc2Zvcm1zO1xudmFyIHBsYXRmb3JtSXNQcmVUYWc7XG52YXIgcGxhdGZvcm1NdXN0VXNlUHJvcDtcbnZhciBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZTtcblxuLyoqXG4gKiBDb252ZXJ0IEhUTUwgc3RyaW5nIHRvIEFTVC5cbiAqL1xuZnVuY3Rpb24gcGFyc2UgKFxuICB0ZW1wbGF0ZSxcbiAgb3B0aW9uc1xuKSB7XG4gIHdhcm4kMiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcblxuICBwbGF0Zm9ybUlzUHJlVGFnID0gb3B0aW9ucy5pc1ByZVRhZyB8fCBubztcbiAgcGxhdGZvcm1NdXN0VXNlUHJvcCA9IG9wdGlvbnMubXVzdFVzZVByb3AgfHwgbm87XG4gIHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlID0gb3B0aW9ucy5nZXRUYWdOYW1lc3BhY2UgfHwgbm87XG5cbiAgdHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAndHJhbnNmb3JtTm9kZScpO1xuICBwcmVUcmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdwcmVUcmFuc2Zvcm1Ob2RlJyk7XG4gIHBvc3RUcmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdwb3N0VHJhbnNmb3JtTm9kZScpO1xuXG4gIGRlbGltaXRlcnMgPSBvcHRpb25zLmRlbGltaXRlcnM7XG5cbiAgdmFyIHN0YWNrID0gW107XG4gIHZhciBwcmVzZXJ2ZVdoaXRlc3BhY2UgPSBvcHRpb25zLnByZXNlcnZlV2hpdGVzcGFjZSAhPT0gZmFsc2U7XG4gIHZhciByb290O1xuICB2YXIgY3VycmVudFBhcmVudDtcbiAgdmFyIGluVlByZSA9IGZhbHNlO1xuICB2YXIgaW5QcmUgPSBmYWxzZTtcbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIHdhcm5PbmNlIChtc2cpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICAgIHdhcm4kMihtc2cpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVuZFByZSAoZWxlbWVudCkge1xuICAgIC8vIGNoZWNrIHByZSBzdGF0ZVxuICAgIGlmIChlbGVtZW50LnByZSkge1xuICAgICAgaW5WUHJlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChwbGF0Zm9ybUlzUHJlVGFnKGVsZW1lbnQudGFnKSkge1xuICAgICAgaW5QcmUgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBwYXJzZUhUTUwodGVtcGxhdGUsIHtcbiAgICB3YXJuOiB3YXJuJDIsXG4gICAgZXhwZWN0SFRNTDogb3B0aW9ucy5leHBlY3RIVE1MLFxuICAgIGlzVW5hcnlUYWc6IG9wdGlvbnMuaXNVbmFyeVRhZyxcbiAgICBjYW5CZUxlZnRPcGVuVGFnOiBvcHRpb25zLmNhbkJlTGVmdE9wZW5UYWcsXG4gICAgc2hvdWxkRGVjb2RlTmV3bGluZXM6IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXMsXG4gICAgc2hvdWxkS2VlcENvbW1lbnQ6IG9wdGlvbnMuY29tbWVudHMsXG4gICAgc3RhcnQ6IGZ1bmN0aW9uIHN0YXJ0ICh0YWcsIGF0dHJzLCB1bmFyeSkge1xuICAgICAgLy8gY2hlY2sgbmFtZXNwYWNlLlxuICAgICAgLy8gaW5oZXJpdCBwYXJlbnQgbnMgaWYgdGhlcmUgaXMgb25lXG4gICAgICB2YXIgbnMgPSAoY3VycmVudFBhcmVudCAmJiBjdXJyZW50UGFyZW50Lm5zKSB8fCBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSh0YWcpO1xuXG4gICAgICAvLyBoYW5kbGUgSUUgc3ZnIGJ1Z1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXNJRSAmJiBucyA9PT0gJ3N2ZycpIHtcbiAgICAgICAgYXR0cnMgPSBndWFyZElFU1ZHQnVnKGF0dHJzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsZW1lbnQgPSB7XG4gICAgICAgIHR5cGU6IDEsXG4gICAgICAgIHRhZzogdGFnLFxuICAgICAgICBhdHRyc0xpc3Q6IGF0dHJzLFxuICAgICAgICBhdHRyc01hcDogbWFrZUF0dHJzTWFwKGF0dHJzKSxcbiAgICAgICAgcGFyZW50OiBjdXJyZW50UGFyZW50LFxuICAgICAgICBjaGlsZHJlbjogW11cbiAgICAgIH07XG4gICAgICBpZiAobnMpIHtcbiAgICAgICAgZWxlbWVudC5ucyA9IG5zO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGb3JiaWRkZW5UYWcoZWxlbWVudCkgJiYgIWlzU2VydmVyUmVuZGVyaW5nKCkpIHtcbiAgICAgICAgZWxlbWVudC5mb3JiaWRkZW4gPSB0cnVlO1xuICAgICAgICBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuJDIoXG4gICAgICAgICAgJ1RlbXBsYXRlcyBzaG91bGQgb25seSBiZSByZXNwb25zaWJsZSBmb3IgbWFwcGluZyB0aGUgc3RhdGUgdG8gdGhlICcgK1xuICAgICAgICAgICdVSS4gQXZvaWQgcGxhY2luZyB0YWdzIHdpdGggc2lkZS1lZmZlY3RzIGluIHlvdXIgdGVtcGxhdGVzLCBzdWNoIGFzICcgK1xuICAgICAgICAgIFwiPFwiICsgdGFnICsgXCI+XCIgKyAnLCBhcyB0aGV5IHdpbGwgbm90IGJlIHBhcnNlZC4nXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIGFwcGx5IHByZS10cmFuc2Zvcm1zXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZVRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcHJlVHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpblZQcmUpIHtcbiAgICAgICAgcHJvY2Vzc1ByZShlbGVtZW50KTtcbiAgICAgICAgaWYgKGVsZW1lbnQucHJlKSB7XG4gICAgICAgICAgaW5WUHJlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XG4gICAgICAgIGluUHJlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpblZQcmUpIHtcbiAgICAgICAgcHJvY2Vzc1Jhd0F0dHJzKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzc0ZvcihlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc0lmKGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzT25jZShlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc0tleShlbGVtZW50KTtcblxuICAgICAgICAvLyBkZXRlcm1pbmUgd2hldGhlciB0aGlzIGlzIGEgcGxhaW4gZWxlbWVudCBhZnRlclxuICAgICAgICAvLyByZW1vdmluZyBzdHJ1Y3R1cmFsIGF0dHJpYnV0ZXNcbiAgICAgICAgZWxlbWVudC5wbGFpbiA9ICFlbGVtZW50LmtleSAmJiAhYXR0cnMubGVuZ3RoO1xuXG4gICAgICAgIHByb2Nlc3NSZWYoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NTbG90KGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzQ29tcG9uZW50KGVsZW1lbnQpO1xuICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCB0cmFuc2Zvcm1zLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgICB0cmFuc2Zvcm1zW2kkMV0oZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcHJvY2Vzc0F0dHJzKGVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjaGVja1Jvb3RDb25zdHJhaW50cyAoZWwpIHtcbiAgICAgICAge1xuICAgICAgICAgIGlmIChlbC50YWcgPT09ICdzbG90JyB8fCBlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICBcIkNhbm5vdCB1c2UgPFwiICsgKGVsLnRhZykgKyBcIj4gYXMgY29tcG9uZW50IHJvb3QgZWxlbWVudCBiZWNhdXNlIGl0IG1heSBcIiArXG4gICAgICAgICAgICAgICdjb250YWluIG11bHRpcGxlIG5vZGVzLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbC5hdHRyc01hcC5oYXNPd25Qcm9wZXJ0eSgndi1mb3InKSkge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgICdDYW5ub3QgdXNlIHYtZm9yIG9uIHN0YXRlZnVsIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSAnICtcbiAgICAgICAgICAgICAgJ2l0IHJlbmRlcnMgbXVsdGlwbGUgZWxlbWVudHMuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gdHJlZSBtYW5hZ2VtZW50XG4gICAgICBpZiAoIXJvb3QpIHtcbiAgICAgICAgcm9vdCA9IGVsZW1lbnQ7XG4gICAgICAgIGNoZWNrUm9vdENvbnN0cmFpbnRzKHJvb3QpO1xuICAgICAgfSBlbHNlIGlmICghc3RhY2subGVuZ3RoKSB7XG4gICAgICAgIC8vIGFsbG93IHJvb3QgZWxlbWVudHMgd2l0aCB2LWlmLCB2LWVsc2UtaWYgYW5kIHYtZWxzZVxuICAgICAgICBpZiAocm9vdC5pZiAmJiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSkge1xuICAgICAgICAgIGNoZWNrUm9vdENvbnN0cmFpbnRzKGVsZW1lbnQpO1xuICAgICAgICAgIGFkZElmQ29uZGl0aW9uKHJvb3QsIHtcbiAgICAgICAgICAgIGV4cDogZWxlbWVudC5lbHNlaWYsXG4gICAgICAgICAgICBibG9jazogZWxlbWVudFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgXCJDb21wb25lbnQgdGVtcGxhdGUgc2hvdWxkIGNvbnRhaW4gZXhhY3RseSBvbmUgcm9vdCBlbGVtZW50LiBcIiArXG4gICAgICAgICAgICBcIklmIHlvdSBhcmUgdXNpbmcgdi1pZiBvbiBtdWx0aXBsZSBlbGVtZW50cywgXCIgK1xuICAgICAgICAgICAgXCJ1c2Ugdi1lbHNlLWlmIHRvIGNoYWluIHRoZW0gaW5zdGVhZC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50UGFyZW50ICYmICFlbGVtZW50LmZvcmJpZGRlbikge1xuICAgICAgICBpZiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSB7XG4gICAgICAgICAgcHJvY2Vzc0lmQ29uZGl0aW9ucyhlbGVtZW50LCBjdXJyZW50UGFyZW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50LnNsb3RTY29wZSkgeyAvLyBzY29wZWQgc2xvdFxuICAgICAgICAgIGN1cnJlbnRQYXJlbnQucGxhaW4gPSBmYWxzZTtcbiAgICAgICAgICB2YXIgbmFtZSA9IGVsZW1lbnQuc2xvdFRhcmdldCB8fCAnXCJkZWZhdWx0XCInOyhjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzIHx8IChjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzID0ge30pKVtuYW1lXSA9IGVsZW1lbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgIGVsZW1lbnQucGFyZW50ID0gY3VycmVudFBhcmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCF1bmFyeSkge1xuICAgICAgICBjdXJyZW50UGFyZW50ID0gZWxlbWVudDtcbiAgICAgICAgc3RhY2sucHVzaChlbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZFByZShlbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIC8vIGFwcGx5IHBvc3QtdHJhbnNmb3Jtc1xuICAgICAgZm9yICh2YXIgaSQyID0gMDsgaSQyIDwgcG9zdFRyYW5zZm9ybXMubGVuZ3RoOyBpJDIrKykge1xuICAgICAgICBwb3N0VHJhbnNmb3Jtc1tpJDJdKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBlbmQ6IGZ1bmN0aW9uIGVuZCAoKSB7XG4gICAgICAvLyByZW1vdmUgdHJhaWxpbmcgd2hpdGVzcGFjZVxuICAgICAgdmFyIGVsZW1lbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIHZhciBsYXN0Tm9kZSA9IGVsZW1lbnQuY2hpbGRyZW5bZWxlbWVudC5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChsYXN0Tm9kZSAmJiBsYXN0Tm9kZS50eXBlID09PSAzICYmIGxhc3ROb2RlLnRleHQgPT09ICcgJyAmJiAhaW5QcmUpIHtcbiAgICAgICAgZWxlbWVudC5jaGlsZHJlbi5wb3AoKTtcbiAgICAgIH1cbiAgICAgIC8vIHBvcCBzdGFja1xuICAgICAgc3RhY2subGVuZ3RoIC09IDE7XG4gICAgICBjdXJyZW50UGFyZW50ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICBlbmRQcmUoZWxlbWVudCk7XG4gICAgfSxcblxuICAgIGNoYXJzOiBmdW5jdGlvbiBjaGFycyAodGV4dCkge1xuICAgICAgaWYgKCFjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAodGV4dCA9PT0gdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAnQ29tcG9uZW50IHRlbXBsYXRlIHJlcXVpcmVzIGEgcm9vdCBlbGVtZW50LCByYXRoZXIgdGhhbiBqdXN0IHRleHQuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCh0ZXh0ID0gdGV4dC50cmltKCkpKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgKFwidGV4dCBcXFwiXCIgKyB0ZXh0ICsgXCJcXFwiIG91dHNpZGUgcm9vdCBlbGVtZW50IHdpbGwgYmUgaWdub3JlZC5cIilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgLy8gSUUgdGV4dGFyZWEgcGxhY2Vob2xkZXIgYnVnXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpc0lFICYmXG4gICAgICAgIGN1cnJlbnRQYXJlbnQudGFnID09PSAndGV4dGFyZWEnICYmXG4gICAgICAgIGN1cnJlbnRQYXJlbnQuYXR0cnNNYXAucGxhY2Vob2xkZXIgPT09IHRleHRcbiAgICAgICkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZHJlbiA9IGN1cnJlbnRQYXJlbnQuY2hpbGRyZW47XG4gICAgICB0ZXh0ID0gaW5QcmUgfHwgdGV4dC50cmltKClcbiAgICAgICAgPyBpc1RleHRUYWcoY3VycmVudFBhcmVudCkgPyB0ZXh0IDogZGVjb2RlSFRNTENhY2hlZCh0ZXh0KVxuICAgICAgICAvLyBvbmx5IHByZXNlcnZlIHdoaXRlc3BhY2UgaWYgaXRzIG5vdCByaWdodCBhZnRlciBhIHN0YXJ0aW5nIHRhZ1xuICAgICAgICA6IHByZXNlcnZlV2hpdGVzcGFjZSAmJiBjaGlsZHJlbi5sZW5ndGggPyAnICcgOiAnJztcbiAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgIHZhciBleHByZXNzaW9uO1xuICAgICAgICBpZiAoIWluVlByZSAmJiB0ZXh0ICE9PSAnICcgJiYgKGV4cHJlc3Npb24gPSBwYXJzZVRleHQodGV4dCwgZGVsaW1pdGVycykpKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAyLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogZXhwcmVzc2lvbixcbiAgICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0ZXh0ICE9PSAnICcgfHwgIWNoaWxkcmVuLmxlbmd0aCB8fCBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXS50ZXh0ICE9PSAnICcpIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDMsXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbW1lbnQ6IGZ1bmN0aW9uIGNvbW1lbnQgKHRleHQpIHtcbiAgICAgIGN1cnJlbnRQYXJlbnQuY2hpbGRyZW4ucHVzaCh7XG4gICAgICAgIHR5cGU6IDMsXG4gICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgIGlzQ29tbWVudDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJvb3Rcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1ByZSAoZWwpIHtcbiAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LXByZScpICE9IG51bGwpIHtcbiAgICBlbC5wcmUgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NSYXdBdHRycyAoZWwpIHtcbiAgdmFyIGwgPSBlbC5hdHRyc0xpc3QubGVuZ3RoO1xuICBpZiAobCkge1xuICAgIHZhciBhdHRycyA9IGVsLmF0dHJzID0gbmV3IEFycmF5KGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICBhdHRyc1tpXSA9IHtcbiAgICAgICAgbmFtZTogZWwuYXR0cnNMaXN0W2ldLm5hbWUsXG4gICAgICAgIHZhbHVlOiBKU09OLnN0cmluZ2lmeShlbC5hdHRyc0xpc3RbaV0udmFsdWUpXG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIGlmICghZWwucHJlKSB7XG4gICAgLy8gbm9uIHJvb3Qgbm9kZSBpbiBwcmUgYmxvY2tzIHdpdGggbm8gYXR0cmlidXRlc1xuICAgIGVsLnBsYWluID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzS2V5IChlbCkge1xuICB2YXIgZXhwID0gZ2V0QmluZGluZ0F0dHIoZWwsICdrZXknKTtcbiAgaWYgKGV4cCkge1xuICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIHdhcm4kMihcIjx0ZW1wbGF0ZT4gY2Fubm90IGJlIGtleWVkLiBQbGFjZSB0aGUga2V5IG9uIHJlYWwgZWxlbWVudHMgaW5zdGVhZC5cIik7XG4gICAgfVxuICAgIGVsLmtleSA9IGV4cDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUmVmIChlbCkge1xuICB2YXIgcmVmID0gZ2V0QmluZGluZ0F0dHIoZWwsICdyZWYnKTtcbiAgaWYgKHJlZikge1xuICAgIGVsLnJlZiA9IHJlZjtcbiAgICBlbC5yZWZJbkZvciA9IGNoZWNrSW5Gb3IoZWwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NGb3IgKGVsKSB7XG4gIHZhciBleHA7XG4gIGlmICgoZXhwID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZm9yJykpKSB7XG4gICAgdmFyIGluTWF0Y2ggPSBleHAubWF0Y2goZm9yQWxpYXNSRSk7XG4gICAgaWYgKCFpbk1hdGNoKSB7XG4gICAgICBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuJDIoXG4gICAgICAgIChcIkludmFsaWQgdi1mb3IgZXhwcmVzc2lvbjogXCIgKyBleHApXG4gICAgICApO1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGVsLmZvciA9IGluTWF0Y2hbMl0udHJpbSgpO1xuICAgIHZhciBhbGlhcyA9IGluTWF0Y2hbMV0udHJpbSgpO1xuICAgIHZhciBpdGVyYXRvck1hdGNoID0gYWxpYXMubWF0Y2goZm9ySXRlcmF0b3JSRSk7XG4gICAgaWYgKGl0ZXJhdG9yTWF0Y2gpIHtcbiAgICAgIGVsLmFsaWFzID0gaXRlcmF0b3JNYXRjaFsxXS50cmltKCk7XG4gICAgICBlbC5pdGVyYXRvcjEgPSBpdGVyYXRvck1hdGNoWzJdLnRyaW0oKTtcbiAgICAgIGlmIChpdGVyYXRvck1hdGNoWzNdKSB7XG4gICAgICAgIGVsLml0ZXJhdG9yMiA9IGl0ZXJhdG9yTWF0Y2hbM10udHJpbSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5hbGlhcyA9IGFsaWFzO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzSWYgKGVsKSB7XG4gIHZhciBleHAgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1pZicpO1xuICBpZiAoZXhwKSB7XG4gICAgZWwuaWYgPSBleHA7XG4gICAgYWRkSWZDb25kaXRpb24oZWwsIHtcbiAgICAgIGV4cDogZXhwLFxuICAgICAgYmxvY2s6IGVsXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UnKSAhPSBudWxsKSB7XG4gICAgICBlbC5lbHNlID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGVsc2VpZiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UtaWYnKTtcbiAgICBpZiAoZWxzZWlmKSB7XG4gICAgICBlbC5lbHNlaWYgPSBlbHNlaWY7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NJZkNvbmRpdGlvbnMgKGVsLCBwYXJlbnQpIHtcbiAgdmFyIHByZXYgPSBmaW5kUHJldkVsZW1lbnQocGFyZW50LmNoaWxkcmVuKTtcbiAgaWYgKHByZXYgJiYgcHJldi5pZikge1xuICAgIGFkZElmQ29uZGl0aW9uKHByZXYsIHtcbiAgICAgIGV4cDogZWwuZWxzZWlmLFxuICAgICAgYmxvY2s6IGVsXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgd2FybiQyKFxuICAgICAgXCJ2LVwiICsgKGVsLmVsc2VpZiA/ICgnZWxzZS1pZj1cIicgKyBlbC5lbHNlaWYgKyAnXCInKSA6ICdlbHNlJykgKyBcIiBcIiArXG4gICAgICBcInVzZWQgb24gZWxlbWVudCA8XCIgKyAoZWwudGFnKSArIFwiPiB3aXRob3V0IGNvcnJlc3BvbmRpbmcgdi1pZi5cIlxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZFByZXZFbGVtZW50IChjaGlsZHJlbikge1xuICB2YXIgaSA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChjaGlsZHJlbltpXS50eXBlID09PSAxKSB7XG4gICAgICByZXR1cm4gY2hpbGRyZW5baV1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoaWxkcmVuW2ldLnRleHQgIT09ICcgJykge1xuICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgXCJ0ZXh0IFxcXCJcIiArIChjaGlsZHJlbltpXS50ZXh0LnRyaW0oKSkgKyBcIlxcXCIgYmV0d2VlbiB2LWlmIGFuZCB2LWVsc2UoLWlmKSBcIiArXG4gICAgICAgICAgXCJ3aWxsIGJlIGlnbm9yZWQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuLnBvcCgpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRJZkNvbmRpdGlvbiAoZWwsIGNvbmRpdGlvbikge1xuICBpZiAoIWVsLmlmQ29uZGl0aW9ucykge1xuICAgIGVsLmlmQ29uZGl0aW9ucyA9IFtdO1xuICB9XG4gIGVsLmlmQ29uZGl0aW9ucy5wdXNoKGNvbmRpdGlvbik7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NPbmNlIChlbCkge1xuICB2YXIgb25jZSQkMSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LW9uY2UnKTtcbiAgaWYgKG9uY2UkJDEgIT0gbnVsbCkge1xuICAgIGVsLm9uY2UgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NTbG90IChlbCkge1xuICBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICBlbC5zbG90TmFtZSA9IGdldEJpbmRpbmdBdHRyKGVsLCAnbmFtZScpO1xuICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBlbC5rZXkpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgXCJga2V5YCBkb2VzIG5vdCB3b3JrIG9uIDxzbG90PiBiZWNhdXNlIHNsb3RzIGFyZSBhYnN0cmFjdCBvdXRsZXRzIFwiICtcbiAgICAgICAgXCJhbmQgY2FuIHBvc3NpYmx5IGV4cGFuZCBpbnRvIG11bHRpcGxlIGVsZW1lbnRzLiBcIiArXG4gICAgICAgIFwiVXNlIHRoZSBrZXkgb24gYSB3cmFwcGluZyBlbGVtZW50IGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBzbG90VGFyZ2V0ID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzbG90Jyk7XG4gICAgaWYgKHNsb3RUYXJnZXQpIHtcbiAgICAgIGVsLnNsb3RUYXJnZXQgPSBzbG90VGFyZ2V0ID09PSAnXCJcIicgPyAnXCJkZWZhdWx0XCInIDogc2xvdFRhcmdldDtcbiAgICB9XG4gICAgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgZWwuc2xvdFNjb3BlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Njb3BlJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NDb21wb25lbnQgKGVsKSB7XG4gIHZhciBiaW5kaW5nO1xuICBpZiAoKGJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2lzJykpKSB7XG4gICAgZWwuY29tcG9uZW50ID0gYmluZGluZztcbiAgfVxuICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ2lubGluZS10ZW1wbGF0ZScpICE9IG51bGwpIHtcbiAgICBlbC5pbmxpbmVUZW1wbGF0ZSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0F0dHJzIChlbCkge1xuICB2YXIgbGlzdCA9IGVsLmF0dHJzTGlzdDtcbiAgdmFyIGksIGwsIG5hbWUsIHJhd05hbWUsIHZhbHVlLCBtb2RpZmllcnMsIGlzUHJvcDtcbiAgZm9yIChpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbmFtZSA9IHJhd05hbWUgPSBsaXN0W2ldLm5hbWU7XG4gICAgdmFsdWUgPSBsaXN0W2ldLnZhbHVlO1xuICAgIGlmIChkaXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAvLyBtYXJrIGVsZW1lbnQgYXMgZHluYW1pY1xuICAgICAgZWwuaGFzQmluZGluZ3MgPSB0cnVlO1xuICAgICAgLy8gbW9kaWZpZXJzXG4gICAgICBtb2RpZmllcnMgPSBwYXJzZU1vZGlmaWVycyhuYW1lKTtcbiAgICAgIGlmIChtb2RpZmllcnMpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShtb2RpZmllclJFLCAnJyk7XG4gICAgICB9XG4gICAgICBpZiAoYmluZFJFLnRlc3QobmFtZSkpIHsgLy8gdi1iaW5kXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoYmluZFJFLCAnJyk7XG4gICAgICAgIHZhbHVlID0gcGFyc2VGaWx0ZXJzKHZhbHVlKTtcbiAgICAgICAgaXNQcm9wID0gZmFsc2U7XG4gICAgICAgIGlmIChtb2RpZmllcnMpIHtcbiAgICAgICAgICBpZiAobW9kaWZpZXJzLnByb3ApIHtcbiAgICAgICAgICAgIGlzUHJvcCA9IHRydWU7XG4gICAgICAgICAgICBuYW1lID0gY2FtZWxpemUobmFtZSk7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2lubmVySHRtbCcpIHsgbmFtZSA9ICdpbm5lckhUTUwnOyB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtb2RpZmllcnMuY2FtZWwpIHtcbiAgICAgICAgICAgIG5hbWUgPSBjYW1lbGl6ZShuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1vZGlmaWVycy5zeW5jKSB7XG4gICAgICAgICAgICBhZGRIYW5kbGVyKFxuICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgKFwidXBkYXRlOlwiICsgKGNhbWVsaXplKG5hbWUpKSksXG4gICAgICAgICAgICAgIGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCBcIiRldmVudFwiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFlbC5jb21wb25lbnQgJiYgKFxuICAgICAgICAgIGlzUHJvcCB8fCBwbGF0Zm9ybU11c3RVc2VQcm9wKGVsLnRhZywgZWwuYXR0cnNNYXAudHlwZSwgbmFtZSlcbiAgICAgICAgKSkge1xuICAgICAgICAgIGFkZFByb3AoZWwsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRBdHRyKGVsLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAob25SRS50ZXN0KG5hbWUpKSB7IC8vIHYtb25cbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShvblJFLCAnJyk7XG4gICAgICAgIGFkZEhhbmRsZXIoZWwsIG5hbWUsIHZhbHVlLCBtb2RpZmllcnMsIGZhbHNlLCB3YXJuJDIpO1xuICAgICAgfSBlbHNlIHsgLy8gbm9ybWFsIGRpcmVjdGl2ZXNcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShkaXJSRSwgJycpO1xuICAgICAgICAvLyBwYXJzZSBhcmdcbiAgICAgICAgdmFyIGFyZ01hdGNoID0gbmFtZS5tYXRjaChhcmdSRSk7XG4gICAgICAgIHZhciBhcmcgPSBhcmdNYXRjaCAmJiBhcmdNYXRjaFsxXTtcbiAgICAgICAgaWYgKGFyZykge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDAsIC0oYXJnLmxlbmd0aCArIDEpKTtcbiAgICAgICAgfVxuICAgICAgICBhZGREaXJlY3RpdmUoZWwsIG5hbWUsIHJhd05hbWUsIHZhbHVlLCBhcmcsIG1vZGlmaWVycyk7XG4gICAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBuYW1lID09PSAnbW9kZWwnKSB7XG4gICAgICAgICAgY2hlY2tGb3JBbGlhc01vZGVsKGVsLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbGl0ZXJhbCBhdHRyaWJ1dGVcbiAgICAgIHtcbiAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBwYXJzZVRleHQodmFsdWUsIGRlbGltaXRlcnMpO1xuICAgICAgICBpZiAoZXhwcmVzc2lvbikge1xuICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgIG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIjogXCIgK1xuICAgICAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgaWQ9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDppZD1cInZhbFwiPi4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYWRkQXR0cihlbCwgbmFtZSwgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tJbkZvciAoZWwpIHtcbiAgdmFyIHBhcmVudCA9IGVsO1xuICB3aGlsZSAocGFyZW50KSB7XG4gICAgaWYgKHBhcmVudC5mb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gcGFyc2VNb2RpZmllcnMgKG5hbWUpIHtcbiAgdmFyIG1hdGNoID0gbmFtZS5tYXRjaChtb2RpZmllclJFKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgdmFyIHJldCA9IHt9O1xuICAgIG1hdGNoLmZvckVhY2goZnVuY3Rpb24gKG0pIHsgcmV0W20uc2xpY2UoMSldID0gdHJ1ZTsgfSk7XG4gICAgcmV0dXJuIHJldFxuICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VBdHRyc01hcCAoYXR0cnMpIHtcbiAgdmFyIG1hcCA9IHt9O1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChcbiAgICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBtYXBbYXR0cnNbaV0ubmFtZV0gJiYgIWlzSUUgJiYgIWlzRWRnZVxuICAgICkge1xuICAgICAgd2FybiQyKCdkdXBsaWNhdGUgYXR0cmlidXRlOiAnICsgYXR0cnNbaV0ubmFtZSk7XG4gICAgfVxuICAgIG1hcFthdHRyc1tpXS5uYW1lXSA9IGF0dHJzW2ldLnZhbHVlO1xuICB9XG4gIHJldHVybiBtYXBcbn1cblxuLy8gZm9yIHNjcmlwdCAoZS5nLiB0eXBlPVwieC90ZW1wbGF0ZVwiKSBvciBzdHlsZSwgZG8gbm90IGRlY29kZSBjb250ZW50XG5mdW5jdGlvbiBpc1RleHRUYWcgKGVsKSB7XG4gIHJldHVybiBlbC50YWcgPT09ICdzY3JpcHQnIHx8IGVsLnRhZyA9PT0gJ3N0eWxlJ1xufVxuXG5mdW5jdGlvbiBpc0ZvcmJpZGRlblRhZyAoZWwpIHtcbiAgcmV0dXJuIChcbiAgICBlbC50YWcgPT09ICdzdHlsZScgfHxcbiAgICAoZWwudGFnID09PSAnc2NyaXB0JyAmJiAoXG4gICAgICAhZWwuYXR0cnNNYXAudHlwZSB8fFxuICAgICAgZWwuYXR0cnNNYXAudHlwZSA9PT0gJ3RleHQvamF2YXNjcmlwdCdcbiAgICApKVxuICApXG59XG5cbnZhciBpZU5TQnVnID0gL154bWxuczpOU1xcZCsvO1xudmFyIGllTlNQcmVmaXggPSAvXk5TXFxkKzovO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gZ3VhcmRJRVNWR0J1ZyAoYXR0cnMpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGF0dHIgPSBhdHRyc1tpXTtcbiAgICBpZiAoIWllTlNCdWcudGVzdChhdHRyLm5hbWUpKSB7XG4gICAgICBhdHRyLm5hbWUgPSBhdHRyLm5hbWUucmVwbGFjZShpZU5TUHJlZml4LCAnJyk7XG4gICAgICByZXMucHVzaChhdHRyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBjaGVja0ZvckFsaWFzTW9kZWwgKGVsLCB2YWx1ZSkge1xuICB2YXIgX2VsID0gZWw7XG4gIHdoaWxlIChfZWwpIHtcbiAgICBpZiAoX2VsLmZvciAmJiBfZWwuYWxpYXMgPT09IHZhbHVlKSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiPjogXCIgK1xuICAgICAgICBcIllvdSBhcmUgYmluZGluZyB2LW1vZGVsIGRpcmVjdGx5IHRvIGEgdi1mb3IgaXRlcmF0aW9uIGFsaWFzLiBcIiArXG4gICAgICAgIFwiVGhpcyB3aWxsIG5vdCBiZSBhYmxlIHRvIG1vZGlmeSB0aGUgdi1mb3Igc291cmNlIGFycmF5IGJlY2F1c2UgXCIgK1xuICAgICAgICBcIndyaXRpbmcgdG8gdGhlIGFsaWFzIGlzIGxpa2UgbW9kaWZ5aW5nIGEgZnVuY3Rpb24gbG9jYWwgdmFyaWFibGUuIFwiICtcbiAgICAgICAgXCJDb25zaWRlciB1c2luZyBhbiBhcnJheSBvZiBvYmplY3RzIGFuZCB1c2Ugdi1tb2RlbCBvbiBhbiBvYmplY3QgcHJvcGVydHkgaW5zdGVhZC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgX2VsID0gX2VsLnBhcmVudDtcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGlzU3RhdGljS2V5O1xudmFyIGlzUGxhdGZvcm1SZXNlcnZlZFRhZztcblxudmFyIGdlblN0YXRpY0tleXNDYWNoZWQgPSBjYWNoZWQoZ2VuU3RhdGljS2V5cyQxKTtcblxuLyoqXG4gKiBHb2FsIG9mIHRoZSBvcHRpbWl6ZXI6IHdhbGsgdGhlIGdlbmVyYXRlZCB0ZW1wbGF0ZSBBU1QgdHJlZVxuICogYW5kIGRldGVjdCBzdWItdHJlZXMgdGhhdCBhcmUgcHVyZWx5IHN0YXRpYywgaS5lLiBwYXJ0cyBvZlxuICogdGhlIERPTSB0aGF0IG5ldmVyIG5lZWRzIHRvIGNoYW5nZS5cbiAqXG4gKiBPbmNlIHdlIGRldGVjdCB0aGVzZSBzdWItdHJlZXMsIHdlIGNhbjpcbiAqXG4gKiAxLiBIb2lzdCB0aGVtIGludG8gY29uc3RhbnRzLCBzbyB0aGF0IHdlIG5vIGxvbmdlciBuZWVkIHRvXG4gKiAgICBjcmVhdGUgZnJlc2ggbm9kZXMgZm9yIHRoZW0gb24gZWFjaCByZS1yZW5kZXI7XG4gKiAyLiBDb21wbGV0ZWx5IHNraXAgdGhlbSBpbiB0aGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAqL1xuZnVuY3Rpb24gb3B0aW1pemUgKHJvb3QsIG9wdGlvbnMpIHtcbiAgaWYgKCFyb290KSB7IHJldHVybiB9XG4gIGlzU3RhdGljS2V5ID0gZ2VuU3RhdGljS2V5c0NhY2hlZChvcHRpb25zLnN0YXRpY0tleXMgfHwgJycpO1xuICBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gIC8vIGZpcnN0IHBhc3M6IG1hcmsgYWxsIG5vbi1zdGF0aWMgbm9kZXMuXG4gIG1hcmtTdGF0aWMkMShyb290KTtcbiAgLy8gc2Vjb25kIHBhc3M6IG1hcmsgc3RhdGljIHJvb3RzLlxuICBtYXJrU3RhdGljUm9vdHMocm9vdCwgZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBnZW5TdGF0aWNLZXlzJDEgKGtleXMpIHtcbiAgcmV0dXJuIG1ha2VNYXAoXG4gICAgJ3R5cGUsdGFnLGF0dHJzTGlzdCxhdHRyc01hcCxwbGFpbixwYXJlbnQsY2hpbGRyZW4sYXR0cnMnICtcbiAgICAoa2V5cyA/ICcsJyArIGtleXMgOiAnJylcbiAgKVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljJDEgKG5vZGUpIHtcbiAgbm9kZS5zdGF0aWMgPSBpc1N0YXRpYyhub2RlKTtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIC8vIGRvIG5vdCBtYWtlIGNvbXBvbmVudCBzbG90IGNvbnRlbnQgc3RhdGljLiB0aGlzIGF2b2lkc1xuICAgIC8vIDEuIGNvbXBvbmVudHMgbm90IGFibGUgdG8gbXV0YXRlIHNsb3Qgbm9kZXNcbiAgICAvLyAyLiBzdGF0aWMgc2xvdCBjb250ZW50IGZhaWxzIGZvciBob3QtcmVsb2FkaW5nXG4gICAgaWYgKFxuICAgICAgIWlzUGxhdGZvcm1SZXNlcnZlZFRhZyhub2RlLnRhZykgJiZcbiAgICAgIG5vZGUudGFnICE9PSAnc2xvdCcgJiZcbiAgICAgIG5vZGUuYXR0cnNNYXBbJ2lubGluZS10ZW1wbGF0ZSddID09IG51bGxcbiAgICApIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgbWFya1N0YXRpYyQxKGNoaWxkKTtcbiAgICAgIGlmICghY2hpbGQuc3RhdGljKSB7XG4gICAgICAgIG5vZGUuc3RhdGljID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLmlmQ29uZGl0aW9ucykge1xuICAgICAgZm9yICh2YXIgaSQxID0gMSwgbCQxID0gbm9kZS5pZkNvbmRpdGlvbnMubGVuZ3RoOyBpJDEgPCBsJDE7IGkkMSsrKSB7XG4gICAgICAgIHZhciBibG9jayA9IG5vZGUuaWZDb25kaXRpb25zW2kkMV0uYmxvY2s7XG4gICAgICAgIG1hcmtTdGF0aWMkMShibG9jayk7XG4gICAgICAgIGlmICghYmxvY2suc3RhdGljKSB7XG4gICAgICAgICAgbm9kZS5zdGF0aWMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljUm9vdHMgKG5vZGUsIGlzSW5Gb3IpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIGlmIChub2RlLnN0YXRpYyB8fCBub2RlLm9uY2UpIHtcbiAgICAgIG5vZGUuc3RhdGljSW5Gb3IgPSBpc0luRm9yO1xuICAgIH1cbiAgICAvLyBGb3IgYSBub2RlIHRvIHF1YWxpZnkgYXMgYSBzdGF0aWMgcm9vdCwgaXQgc2hvdWxkIGhhdmUgY2hpbGRyZW4gdGhhdFxuICAgIC8vIGFyZSBub3QganVzdCBzdGF0aWMgdGV4dC4gT3RoZXJ3aXNlIHRoZSBjb3N0IG9mIGhvaXN0aW5nIG91dCB3aWxsXG4gICAgLy8gb3V0d2VpZ2ggdGhlIGJlbmVmaXRzIGFuZCBpdCdzIGJldHRlciBvZmYgdG8ganVzdCBhbHdheXMgcmVuZGVyIGl0IGZyZXNoLlxuICAgIGlmIChub2RlLnN0YXRpYyAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCAmJiAhKFxuICAgICAgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICAgIG5vZGUuY2hpbGRyZW5bMF0udHlwZSA9PT0gM1xuICAgICkpIHtcbiAgICAgIG5vZGUuc3RhdGljUm9vdCA9IHRydWU7XG4gICAgICByZXR1cm5cbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5zdGF0aWNSb290ID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIG1hcmtTdGF0aWNSb290cyhub2RlLmNoaWxkcmVuW2ldLCBpc0luRm9yIHx8ICEhbm9kZS5mb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5pZkNvbmRpdGlvbnMpIHtcbiAgICAgIGZvciAodmFyIGkkMSA9IDEsIGwkMSA9IG5vZGUuaWZDb25kaXRpb25zLmxlbmd0aDsgaSQxIDwgbCQxOyBpJDErKykge1xuICAgICAgICBtYXJrU3RhdGljUm9vdHMobm9kZS5pZkNvbmRpdGlvbnNbaSQxXS5ibG9jaywgaXNJbkZvcik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzU3RhdGljIChub2RlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDIpIHsgLy8gZXhwcmVzc2lvblxuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGlmIChub2RlLnR5cGUgPT09IDMpIHsgLy8gdGV4dFxuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuICEhKG5vZGUucHJlIHx8IChcbiAgICAhbm9kZS5oYXNCaW5kaW5ncyAmJiAvLyBubyBkeW5hbWljIGJpbmRpbmdzXG4gICAgIW5vZGUuaWYgJiYgIW5vZGUuZm9yICYmIC8vIG5vdCB2LWlmIG9yIHYtZm9yIG9yIHYtZWxzZVxuICAgICFpc0J1aWx0SW5UYWcobm9kZS50YWcpICYmIC8vIG5vdCBhIGJ1aWx0LWluXG4gICAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnKG5vZGUudGFnKSAmJiAvLyBub3QgYSBjb21wb25lbnRcbiAgICAhaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3Iobm9kZSkgJiZcbiAgICBPYmplY3Qua2V5cyhub2RlKS5ldmVyeShpc1N0YXRpY0tleSlcbiAgKSlcbn1cblxuZnVuY3Rpb24gaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3IgKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUucGFyZW50KSB7XG4gICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgIGlmIChub2RlLnRhZyAhPT0gJ3RlbXBsYXRlJykge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmIChub2RlLmZvcikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qICAqL1xuXG52YXIgZm5FeHBSRSA9IC9eXFxzKihbXFx3JF9dK3xcXChbXildKj9cXCkpXFxzKj0+fF5mdW5jdGlvblxccypcXCgvO1xudmFyIHNpbXBsZVBhdGhSRSA9IC9eXFxzKltBLVphLXpfJF1bXFx3JF0qKD86XFwuW0EtWmEtel8kXVtcXHckXSp8XFxbJy4qPyddfFxcW1wiLio/XCJdfFxcW1xcZCtdfFxcW1tBLVphLXpfJF1bXFx3JF0qXSkqXFxzKiQvO1xuXG4vLyBrZXlDb2RlIGFsaWFzZXNcbnZhciBrZXlDb2RlcyA9IHtcbiAgZXNjOiAyNyxcbiAgdGFiOiA5LFxuICBlbnRlcjogMTMsXG4gIHNwYWNlOiAzMixcbiAgdXA6IDM4LFxuICBsZWZ0OiAzNyxcbiAgcmlnaHQ6IDM5LFxuICBkb3duOiA0MCxcbiAgJ2RlbGV0ZSc6IFs4LCA0Nl1cbn07XG5cbi8vICM0ODY4OiBtb2RpZmllcnMgdGhhdCBwcmV2ZW50IHRoZSBleGVjdXRpb24gb2YgdGhlIGxpc3RlbmVyXG4vLyBuZWVkIHRvIGV4cGxpY2l0bHkgcmV0dXJuIG51bGwgc28gdGhhdCB3ZSBjYW4gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcmVtb3ZlXG4vLyB0aGUgbGlzdGVuZXIgZm9yIC5vbmNlXG52YXIgZ2VuR3VhcmQgPSBmdW5jdGlvbiAoY29uZGl0aW9uKSB7IHJldHVybiAoXCJpZihcIiArIGNvbmRpdGlvbiArIFwiKXJldHVybiBudWxsO1wiKTsgfTtcblxudmFyIG1vZGlmaWVyQ29kZSA9IHtcbiAgc3RvcDogJyRldmVudC5zdG9wUHJvcGFnYXRpb24oKTsnLFxuICBwcmV2ZW50OiAnJGV2ZW50LnByZXZlbnREZWZhdWx0KCk7JyxcbiAgc2VsZjogZ2VuR3VhcmQoXCIkZXZlbnQudGFyZ2V0ICE9PSAkZXZlbnQuY3VycmVudFRhcmdldFwiKSxcbiAgY3RybDogZ2VuR3VhcmQoXCIhJGV2ZW50LmN0cmxLZXlcIiksXG4gIHNoaWZ0OiBnZW5HdWFyZChcIiEkZXZlbnQuc2hpZnRLZXlcIiksXG4gIGFsdDogZ2VuR3VhcmQoXCIhJGV2ZW50LmFsdEtleVwiKSxcbiAgbWV0YTogZ2VuR3VhcmQoXCIhJGV2ZW50Lm1ldGFLZXlcIiksXG4gIGxlZnQ6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDBcIiksXG4gIG1pZGRsZTogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMVwiKSxcbiAgcmlnaHQ6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDJcIilcbn07XG5cbmZ1bmN0aW9uIGdlbkhhbmRsZXJzIChcbiAgZXZlbnRzLFxuICBpc05hdGl2ZSxcbiAgd2FyblxuKSB7XG4gIHZhciByZXMgPSBpc05hdGl2ZSA/ICduYXRpdmVPbjp7JyA6ICdvbjp7JztcbiAgZm9yICh2YXIgbmFtZSBpbiBldmVudHMpIHtcbiAgICB2YXIgaGFuZGxlciA9IGV2ZW50c1tuYW1lXTtcbiAgICAvLyAjNTMzMDogd2FybiBjbGljay5yaWdodCwgc2luY2UgcmlnaHQgY2xpY2tzIGRvIG5vdCBhY3R1YWxseSBmaXJlIGNsaWNrIGV2ZW50cy5cbiAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIG5hbWUgPT09ICdjbGljaycgJiZcbiAgICAgIGhhbmRsZXIgJiYgaGFuZGxlci5tb2RpZmllcnMgJiYgaGFuZGxlci5tb2RpZmllcnMucmlnaHRcbiAgICApIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiVXNlIFxcXCJjb250ZXh0bWVudVxcXCIgaW5zdGVhZCBvZiBcXFwiY2xpY2sucmlnaHRcXFwiIHNpbmNlIHJpZ2h0IGNsaWNrcyBcIiArXG4gICAgICAgIFwiZG8gbm90IGFjdHVhbGx5IGZpcmUgXFxcImNsaWNrXFxcIiBldmVudHMuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIHJlcyArPSBcIlxcXCJcIiArIG5hbWUgKyBcIlxcXCI6XCIgKyAoZ2VuSGFuZGxlcihuYW1lLCBoYW5kbGVyKSkgKyBcIixcIjtcbiAgfVxuICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKSArICd9J1xufVxuXG5mdW5jdGlvbiBnZW5IYW5kbGVyIChcbiAgbmFtZSxcbiAgaGFuZGxlclxuKSB7XG4gIGlmICghaGFuZGxlcikge1xuICAgIHJldHVybiAnZnVuY3Rpb24oKXt9J1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICByZXR1cm4gKFwiW1wiICsgKGhhbmRsZXIubWFwKGZ1bmN0aW9uIChoYW5kbGVyKSB7IHJldHVybiBnZW5IYW5kbGVyKG5hbWUsIGhhbmRsZXIpOyB9KS5qb2luKCcsJykpICsgXCJdXCIpXG4gIH1cblxuICB2YXIgaXNNZXRob2RQYXRoID0gc2ltcGxlUGF0aFJFLnRlc3QoaGFuZGxlci52YWx1ZSk7XG4gIHZhciBpc0Z1bmN0aW9uRXhwcmVzc2lvbiA9IGZuRXhwUkUudGVzdChoYW5kbGVyLnZhbHVlKTtcblxuICBpZiAoIWhhbmRsZXIubW9kaWZpZXJzKSB7XG4gICAgcmV0dXJuIGlzTWV0aG9kUGF0aCB8fCBpc0Z1bmN0aW9uRXhwcmVzc2lvblxuICAgICAgPyBoYW5kbGVyLnZhbHVlXG4gICAgICA6IChcImZ1bmN0aW9uKCRldmVudCl7XCIgKyAoaGFuZGxlci52YWx1ZSkgKyBcIn1cIikgLy8gaW5saW5lIHN0YXRlbWVudFxuICB9IGVsc2Uge1xuICAgIHZhciBjb2RlID0gJyc7XG4gICAgdmFyIGdlbk1vZGlmaWVyQ29kZSA9ICcnO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIGhhbmRsZXIubW9kaWZpZXJzKSB7XG4gICAgICBpZiAobW9kaWZpZXJDb2RlW2tleV0pIHtcbiAgICAgICAgZ2VuTW9kaWZpZXJDb2RlICs9IG1vZGlmaWVyQ29kZVtrZXldO1xuICAgICAgICAvLyBsZWZ0L3JpZ2h0XG4gICAgICAgIGlmIChrZXlDb2Rlc1trZXldKSB7XG4gICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICAgIGNvZGUgKz0gZ2VuS2V5RmlsdGVyKGtleXMpO1xuICAgIH1cbiAgICAvLyBNYWtlIHN1cmUgbW9kaWZpZXJzIGxpa2UgcHJldmVudCBhbmQgc3RvcCBnZXQgZXhlY3V0ZWQgYWZ0ZXIga2V5IGZpbHRlcmluZ1xuICAgIGlmIChnZW5Nb2RpZmllckNvZGUpIHtcbiAgICAgIGNvZGUgKz0gZ2VuTW9kaWZpZXJDb2RlO1xuICAgIH1cbiAgICB2YXIgaGFuZGxlckNvZGUgPSBpc01ldGhvZFBhdGhcbiAgICAgID8gaGFuZGxlci52YWx1ZSArICcoJGV2ZW50KSdcbiAgICAgIDogaXNGdW5jdGlvbkV4cHJlc3Npb25cbiAgICAgICAgPyAoXCIoXCIgKyAoaGFuZGxlci52YWx1ZSkgKyBcIikoJGV2ZW50KVwiKVxuICAgICAgICA6IGhhbmRsZXIudmFsdWU7XG4gICAgcmV0dXJuIChcImZ1bmN0aW9uKCRldmVudCl7XCIgKyBjb2RlICsgaGFuZGxlckNvZGUgKyBcIn1cIilcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5LZXlGaWx0ZXIgKGtleXMpIHtcbiAgcmV0dXJuIChcImlmKCEoJ2J1dHRvbicgaW4gJGV2ZW50KSYmXCIgKyAoa2V5cy5tYXAoZ2VuRmlsdGVyQ29kZSkuam9pbignJiYnKSkgKyBcIilyZXR1cm4gbnVsbDtcIilcbn1cblxuZnVuY3Rpb24gZ2VuRmlsdGVyQ29kZSAoa2V5KSB7XG4gIHZhciBrZXlWYWwgPSBwYXJzZUludChrZXksIDEwKTtcbiAgaWYgKGtleVZhbCkge1xuICAgIHJldHVybiAoXCIkZXZlbnQua2V5Q29kZSE9PVwiICsga2V5VmFsKVxuICB9XG4gIHZhciBhbGlhcyA9IGtleUNvZGVzW2tleV07XG4gIHJldHVybiAoXCJfaygkZXZlbnQua2V5Q29kZSxcIiArIChKU09OLnN0cmluZ2lmeShrZXkpKSArIChhbGlhcyA/ICcsJyArIEpTT04uc3RyaW5naWZ5KGFsaWFzKSA6ICcnKSArIFwiKVwiKVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gb24gKGVsLCBkaXIpIHtcbiAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGRpci5tb2RpZmllcnMpIHtcbiAgICB3YXJuKFwidi1vbiB3aXRob3V0IGFyZ3VtZW50IGRvZXMgbm90IHN1cHBvcnQgbW9kaWZpZXJzLlwiKTtcbiAgfVxuICBlbC53cmFwTGlzdGVuZXJzID0gZnVuY3Rpb24gKGNvZGUpIHsgcmV0dXJuIChcIl9nKFwiICsgY29kZSArIFwiLFwiICsgKGRpci52YWx1ZSkgKyBcIilcIik7IH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiaW5kJDEgKGVsLCBkaXIpIHtcbiAgZWwud3JhcERhdGEgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgIHJldHVybiAoXCJfYihcIiArIGNvZGUgKyBcIiwnXCIgKyAoZWwudGFnKSArIFwiJyxcIiArIChkaXIudmFsdWUpICsgXCIsXCIgKyAoZGlyLm1vZGlmaWVycyAmJiBkaXIubW9kaWZpZXJzLnByb3AgPyAndHJ1ZScgOiAnZmFsc2UnKSArIChkaXIubW9kaWZpZXJzICYmIGRpci5tb2RpZmllcnMuc3luYyA/ICcsdHJ1ZScgOiAnJykgKyBcIilcIilcbiAgfTtcbn1cblxuLyogICovXG5cbnZhciBiYXNlRGlyZWN0aXZlcyA9IHtcbiAgb246IG9uLFxuICBiaW5kOiBiaW5kJDEsXG4gIGNsb2FrOiBub29wXG59O1xuXG4vKiAgKi9cblxudmFyIENvZGVnZW5TdGF0ZSA9IGZ1bmN0aW9uIENvZGVnZW5TdGF0ZSAob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB0aGlzLndhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHRoaXMudHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAndHJhbnNmb3JtQ29kZScpO1xuICB0aGlzLmRhdGFHZW5GbnMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ2dlbkRhdGEnKTtcbiAgdGhpcy5kaXJlY3RpdmVzID0gZXh0ZW5kKGV4dGVuZCh7fSwgYmFzZURpcmVjdGl2ZXMpLCBvcHRpb25zLmRpcmVjdGl2ZXMpO1xuICB2YXIgaXNSZXNlcnZlZFRhZyA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcbiAgdGhpcy5tYXliZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gIWlzUmVzZXJ2ZWRUYWcoZWwudGFnKTsgfTtcbiAgdGhpcy5vbmNlSWQgPSAwO1xuICB0aGlzLnN0YXRpY1JlbmRlckZucyA9IFtdO1xufTtcblxuXG5cbmZ1bmN0aW9uIGdlbmVyYXRlIChcbiAgYXN0LFxuICBvcHRpb25zXG4pIHtcbiAgdmFyIHN0YXRlID0gbmV3IENvZGVnZW5TdGF0ZShvcHRpb25zKTtcbiAgdmFyIGNvZGUgPSBhc3QgPyBnZW5FbGVtZW50KGFzdCwgc3RhdGUpIDogJ19jKFwiZGl2XCIpJztcbiAgcmV0dXJuIHtcbiAgICByZW5kZXI6IChcIndpdGgodGhpcyl7cmV0dXJuIFwiICsgY29kZSArIFwifVwiKSxcbiAgICBzdGF0aWNSZW5kZXJGbnM6IHN0YXRlLnN0YXRpY1JlbmRlckZuc1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkVsZW1lbnQgKGVsLCBzdGF0ZSkge1xuICBpZiAoZWwuc3RhdGljUm9vdCAmJiAhZWwuc3RhdGljUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlblN0YXRpYyhlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwub25jZSAmJiAhZWwub25jZVByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5PbmNlKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5mb3IgJiYgIWVsLmZvclByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5Gb3IoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5JZihlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnICYmICFlbC5zbG90VGFyZ2V0KSB7XG4gICAgcmV0dXJuIGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3ZvaWQgMCdcbiAgfSBlbHNlIGlmIChlbC50YWcgPT09ICdzbG90Jykge1xuICAgIHJldHVybiBnZW5TbG90KGVsLCBzdGF0ZSlcbiAgfSBlbHNlIHtcbiAgICAvLyBjb21wb25lbnQgb3IgZWxlbWVudFxuICAgIHZhciBjb2RlO1xuICAgIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICAgIGNvZGUgPSBnZW5Db21wb25lbnQoZWwuY29tcG9uZW50LCBlbCwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGF0YSA9IGVsLnBsYWluID8gdW5kZWZpbmVkIDogZ2VuRGF0YSQyKGVsLCBzdGF0ZSk7XG5cbiAgICAgIHZhciBjaGlsZHJlbiA9IGVsLmlubGluZVRlbXBsYXRlID8gbnVsbCA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSwgdHJ1ZSk7XG4gICAgICBjb2RlID0gXCJfYygnXCIgKyAoZWwudGFnKSArIFwiJ1wiICsgKGRhdGEgPyAoXCIsXCIgKyBkYXRhKSA6ICcnKSArIChjaGlsZHJlbiA/IChcIixcIiArIGNoaWxkcmVuKSA6ICcnKSArIFwiKVwiO1xuICAgIH1cbiAgICAvLyBtb2R1bGUgdHJhbnNmb3Jtc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGUudHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29kZSA9IHN0YXRlLnRyYW5zZm9ybXNbaV0oZWwsIGNvZGUpO1xuICAgIH1cbiAgICByZXR1cm4gY29kZVxuICB9XG59XG5cbi8vIGhvaXN0IHN0YXRpYyBzdWItdHJlZXMgb3V0XG5mdW5jdGlvbiBnZW5TdGF0aWMgKGVsLCBzdGF0ZSkge1xuICBlbC5zdGF0aWNQcm9jZXNzZWQgPSB0cnVlO1xuICBzdGF0ZS5zdGF0aWNSZW5kZXJGbnMucHVzaCgoXCJ3aXRoKHRoaXMpe3JldHVybiBcIiArIChnZW5FbGVtZW50KGVsLCBzdGF0ZSkpICsgXCJ9XCIpKTtcbiAgcmV0dXJuIChcIl9tKFwiICsgKHN0YXRlLnN0YXRpY1JlbmRlckZucy5sZW5ndGggLSAxKSArIChlbC5zdGF0aWNJbkZvciA/ICcsdHJ1ZScgOiAnJykgKyBcIilcIilcbn1cblxuLy8gdi1vbmNlXG5mdW5jdGlvbiBnZW5PbmNlIChlbCwgc3RhdGUpIHtcbiAgZWwub25jZVByb2Nlc3NlZCA9IHRydWU7XG4gIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuSWYoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLnN0YXRpY0luRm9yKSB7XG4gICAgdmFyIGtleSA9ICcnO1xuICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnQ7XG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgaWYgKHBhcmVudC5mb3IpIHtcbiAgICAgICAga2V5ID0gcGFyZW50LmtleTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuICAgIGlmICgha2V5KSB7XG4gICAgICBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBzdGF0ZS53YXJuKFxuICAgICAgICBcInYtb25jZSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSB2LWZvciB0aGF0IGlzIGtleWVkLiBcIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBnZW5FbGVtZW50KGVsLCBzdGF0ZSlcbiAgICB9XG4gICAgcmV0dXJuIChcIl9vKFwiICsgKGdlbkVsZW1lbnQoZWwsIHN0YXRlKSkgKyBcIixcIiArIChzdGF0ZS5vbmNlSWQrKykgKyAoa2V5ID8gKFwiLFwiICsga2V5KSA6IFwiXCIpICsgXCIpXCIpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdlblN0YXRpYyhlbCwgc3RhdGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuSWYgKFxuICBlbCxcbiAgc3RhdGUsXG4gIGFsdEdlbixcbiAgYWx0RW1wdHlcbikge1xuICBlbC5pZlByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICByZXR1cm4gZ2VuSWZDb25kaXRpb25zKGVsLmlmQ29uZGl0aW9ucy5zbGljZSgpLCBzdGF0ZSwgYWx0R2VuLCBhbHRFbXB0eSlcbn1cblxuZnVuY3Rpb24gZ2VuSWZDb25kaXRpb25zIChcbiAgY29uZGl0aW9ucyxcbiAgc3RhdGUsXG4gIGFsdEdlbixcbiAgYWx0RW1wdHlcbikge1xuICBpZiAoIWNvbmRpdGlvbnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGFsdEVtcHR5IHx8ICdfZSgpJ1xuICB9XG5cbiAgdmFyIGNvbmRpdGlvbiA9IGNvbmRpdGlvbnMuc2hpZnQoKTtcbiAgaWYgKGNvbmRpdGlvbi5leHApIHtcbiAgICByZXR1cm4gKFwiKFwiICsgKGNvbmRpdGlvbi5leHApICsgXCIpP1wiICsgKGdlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKSkgKyBcIjpcIiArIChnZW5JZkNvbmRpdGlvbnMoY29uZGl0aW9ucywgc3RhdGUsIGFsdEdlbiwgYWx0RW1wdHkpKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKFwiXCIgKyAoZ2VuVGVybmFyeUV4cChjb25kaXRpb24uYmxvY2spKSlcbiAgfVxuXG4gIC8vIHYtaWYgd2l0aCB2LW9uY2Ugc2hvdWxkIGdlbmVyYXRlIGNvZGUgbGlrZSAoYSk/X20oMCk6X20oMSlcbiAgZnVuY3Rpb24gZ2VuVGVybmFyeUV4cCAoZWwpIHtcbiAgICByZXR1cm4gYWx0R2VuXG4gICAgICA/IGFsdEdlbihlbCwgc3RhdGUpXG4gICAgICA6IGVsLm9uY2VcbiAgICAgICAgPyBnZW5PbmNlKGVsLCBzdGF0ZSlcbiAgICAgICAgOiBnZW5FbGVtZW50KGVsLCBzdGF0ZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5Gb3IgKFxuICBlbCxcbiAgc3RhdGUsXG4gIGFsdEdlbixcbiAgYWx0SGVscGVyXG4pIHtcbiAgdmFyIGV4cCA9IGVsLmZvcjtcbiAgdmFyIGFsaWFzID0gZWwuYWxpYXM7XG4gIHZhciBpdGVyYXRvcjEgPSBlbC5pdGVyYXRvcjEgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IxKSkgOiAnJztcbiAgdmFyIGl0ZXJhdG9yMiA9IGVsLml0ZXJhdG9yMiA/IChcIixcIiArIChlbC5pdGVyYXRvcjIpKSA6ICcnO1xuXG4gIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIHN0YXRlLm1heWJlQ29tcG9uZW50KGVsKSAmJlxuICAgIGVsLnRhZyAhPT0gJ3Nsb3QnICYmXG4gICAgZWwudGFnICE9PSAndGVtcGxhdGUnICYmXG4gICAgIWVsLmtleVxuICApIHtcbiAgICBzdGF0ZS53YXJuKFxuICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtZm9yPVxcXCJcIiArIGFsaWFzICsgXCIgaW4gXCIgKyBleHAgKyBcIlxcXCI+OiBjb21wb25lbnQgbGlzdHMgcmVuZGVyZWQgd2l0aCBcIiArXG4gICAgICBcInYtZm9yIHNob3VsZCBoYXZlIGV4cGxpY2l0IGtleXMuIFwiICtcbiAgICAgIFwiU2VlIGh0dHBzOi8vdnVlanMub3JnL2d1aWRlL2xpc3QuaHRtbCNrZXkgZm9yIG1vcmUgaW5mby5cIixcbiAgICAgIHRydWUgLyogdGlwICovXG4gICAgKTtcbiAgfVxuXG4gIGVsLmZvclByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICByZXR1cm4gKGFsdEhlbHBlciB8fCAnX2wnKSArIFwiKChcIiArIGV4cCArIFwiKSxcIiArXG4gICAgXCJmdW5jdGlvbihcIiArIGFsaWFzICsgaXRlcmF0b3IxICsgaXRlcmF0b3IyICsgXCIpe1wiICtcbiAgICAgIFwicmV0dXJuIFwiICsgKChhbHRHZW4gfHwgZ2VuRWxlbWVudCkoZWwsIHN0YXRlKSkgK1xuICAgICd9KSdcbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSQyIChlbCwgc3RhdGUpIHtcbiAgdmFyIGRhdGEgPSAneyc7XG5cbiAgLy8gZGlyZWN0aXZlcyBmaXJzdC5cbiAgLy8gZGlyZWN0aXZlcyBtYXkgbXV0YXRlIHRoZSBlbCdzIG90aGVyIHByb3BlcnRpZXMgYmVmb3JlIHRoZXkgYXJlIGdlbmVyYXRlZC5cbiAgdmFyIGRpcnMgPSBnZW5EaXJlY3RpdmVzKGVsLCBzdGF0ZSk7XG4gIGlmIChkaXJzKSB7IGRhdGEgKz0gZGlycyArICcsJzsgfVxuXG4gIC8vIGtleVxuICBpZiAoZWwua2V5KSB7XG4gICAgZGF0YSArPSBcImtleTpcIiArIChlbC5rZXkpICsgXCIsXCI7XG4gIH1cbiAgLy8gcmVmXG4gIGlmIChlbC5yZWYpIHtcbiAgICBkYXRhICs9IFwicmVmOlwiICsgKGVsLnJlZikgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwucmVmSW5Gb3IpIHtcbiAgICBkYXRhICs9IFwicmVmSW5Gb3I6dHJ1ZSxcIjtcbiAgfVxuICAvLyBwcmVcbiAgaWYgKGVsLnByZSkge1xuICAgIGRhdGEgKz0gXCJwcmU6dHJ1ZSxcIjtcbiAgfVxuICAvLyByZWNvcmQgb3JpZ2luYWwgdGFnIG5hbWUgZm9yIGNvbXBvbmVudHMgdXNpbmcgXCJpc1wiIGF0dHJpYnV0ZVxuICBpZiAoZWwuY29tcG9uZW50KSB7XG4gICAgZGF0YSArPSBcInRhZzpcXFwiXCIgKyAoZWwudGFnKSArIFwiXFxcIixcIjtcbiAgfVxuICAvLyBtb2R1bGUgZGF0YSBnZW5lcmF0aW9uIGZ1bmN0aW9uc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlLmRhdGFHZW5GbnMubGVuZ3RoOyBpKyspIHtcbiAgICBkYXRhICs9IHN0YXRlLmRhdGFHZW5GbnNbaV0oZWwpO1xuICB9XG4gIC8vIGF0dHJpYnV0ZXNcbiAgaWYgKGVsLmF0dHJzKSB7XG4gICAgZGF0YSArPSBcImF0dHJzOntcIiArIChnZW5Qcm9wcyhlbC5hdHRycykpICsgXCJ9LFwiO1xuICB9XG4gIC8vIERPTSBwcm9wc1xuICBpZiAoZWwucHJvcHMpIHtcbiAgICBkYXRhICs9IFwiZG9tUHJvcHM6e1wiICsgKGdlblByb3BzKGVsLnByb3BzKSkgKyBcIn0sXCI7XG4gIH1cbiAgLy8gZXZlbnQgaGFuZGxlcnNcbiAgaWYgKGVsLmV2ZW50cykge1xuICAgIGRhdGEgKz0gKGdlbkhhbmRsZXJzKGVsLmV2ZW50cywgZmFsc2UsIHN0YXRlLndhcm4pKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5uYXRpdmVFdmVudHMpIHtcbiAgICBkYXRhICs9IChnZW5IYW5kbGVycyhlbC5uYXRpdmVFdmVudHMsIHRydWUsIHN0YXRlLndhcm4pKSArIFwiLFwiO1xuICB9XG4gIC8vIHNsb3QgdGFyZ2V0XG4gIGlmIChlbC5zbG90VGFyZ2V0KSB7XG4gICAgZGF0YSArPSBcInNsb3Q6XCIgKyAoZWwuc2xvdFRhcmdldCkgKyBcIixcIjtcbiAgfVxuICAvLyBzY29wZWQgc2xvdHNcbiAgaWYgKGVsLnNjb3BlZFNsb3RzKSB7XG4gICAgZGF0YSArPSAoZ2VuU2NvcGVkU2xvdHMoZWwuc2NvcGVkU2xvdHMsIHN0YXRlKSkgKyBcIixcIjtcbiAgfVxuICAvLyBjb21wb25lbnQgdi1tb2RlbFxuICBpZiAoZWwubW9kZWwpIHtcbiAgICBkYXRhICs9IFwibW9kZWw6e3ZhbHVlOlwiICsgKGVsLm1vZGVsLnZhbHVlKSArIFwiLGNhbGxiYWNrOlwiICsgKGVsLm1vZGVsLmNhbGxiYWNrKSArIFwiLGV4cHJlc3Npb246XCIgKyAoZWwubW9kZWwuZXhwcmVzc2lvbikgKyBcIn0sXCI7XG4gIH1cbiAgLy8gaW5saW5lLXRlbXBsYXRlXG4gIGlmIChlbC5pbmxpbmVUZW1wbGF0ZSkge1xuICAgIHZhciBpbmxpbmVUZW1wbGF0ZSA9IGdlbklubGluZVRlbXBsYXRlKGVsLCBzdGF0ZSk7XG4gICAgaWYgKGlubGluZVRlbXBsYXRlKSB7XG4gICAgICBkYXRhICs9IGlubGluZVRlbXBsYXRlICsgXCIsXCI7XG4gICAgfVxuICB9XG4gIGRhdGEgPSBkYXRhLnJlcGxhY2UoLywkLywgJycpICsgJ30nO1xuICAvLyB2LWJpbmQgZGF0YSB3cmFwXG4gIGlmIChlbC53cmFwRGF0YSkge1xuICAgIGRhdGEgPSBlbC53cmFwRGF0YShkYXRhKTtcbiAgfVxuICAvLyB2LW9uIGRhdGEgd3JhcFxuICBpZiAoZWwud3JhcExpc3RlbmVycykge1xuICAgIGRhdGEgPSBlbC53cmFwTGlzdGVuZXJzKGRhdGEpO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIGdlbkRpcmVjdGl2ZXMgKGVsLCBzdGF0ZSkge1xuICB2YXIgZGlycyA9IGVsLmRpcmVjdGl2ZXM7XG4gIGlmICghZGlycykgeyByZXR1cm4gfVxuICB2YXIgcmVzID0gJ2RpcmVjdGl2ZXM6Wyc7XG4gIHZhciBoYXNSdW50aW1lID0gZmFsc2U7XG4gIHZhciBpLCBsLCBkaXIsIG5lZWRSdW50aW1lO1xuICBmb3IgKGkgPSAwLCBsID0gZGlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBkaXIgPSBkaXJzW2ldO1xuICAgIG5lZWRSdW50aW1lID0gdHJ1ZTtcbiAgICB2YXIgZ2VuID0gc3RhdGUuZGlyZWN0aXZlc1tkaXIubmFtZV07XG4gICAgaWYgKGdlbikge1xuICAgICAgLy8gY29tcGlsZS10aW1lIGRpcmVjdGl2ZSB0aGF0IG1hbmlwdWxhdGVzIEFTVC5cbiAgICAgIC8vIHJldHVybnMgdHJ1ZSBpZiBpdCBhbHNvIG5lZWRzIGEgcnVudGltZSBjb3VudGVycGFydC5cbiAgICAgIG5lZWRSdW50aW1lID0gISFnZW4oZWwsIGRpciwgc3RhdGUud2Fybik7XG4gICAgfVxuICAgIGlmIChuZWVkUnVudGltZSkge1xuICAgICAgaGFzUnVudGltZSA9IHRydWU7XG4gICAgICByZXMgKz0gXCJ7bmFtZTpcXFwiXCIgKyAoZGlyLm5hbWUpICsgXCJcXFwiLHJhd05hbWU6XFxcIlwiICsgKGRpci5yYXdOYW1lKSArIFwiXFxcIlwiICsgKGRpci52YWx1ZSA/IChcIix2YWx1ZTooXCIgKyAoZGlyLnZhbHVlKSArIFwiKSxleHByZXNzaW9uOlwiICsgKEpTT04uc3RyaW5naWZ5KGRpci52YWx1ZSkpKSA6ICcnKSArIChkaXIuYXJnID8gKFwiLGFyZzpcXFwiXCIgKyAoZGlyLmFyZykgKyBcIlxcXCJcIikgOiAnJykgKyAoZGlyLm1vZGlmaWVycyA/IChcIixtb2RpZmllcnM6XCIgKyAoSlNPTi5zdHJpbmdpZnkoZGlyLm1vZGlmaWVycykpKSA6ICcnKSArIFwifSxcIjtcbiAgICB9XG4gIH1cbiAgaWYgKGhhc1J1bnRpbWUpIHtcbiAgICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKSArICddJ1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbklubGluZVRlbXBsYXRlIChlbCwgc3RhdGUpIHtcbiAgdmFyIGFzdCA9IGVsLmNoaWxkcmVuWzBdO1xuICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgKFxuICAgIGVsLmNoaWxkcmVuLmxlbmd0aCA+IDEgfHwgYXN0LnR5cGUgIT09IDFcbiAgKSkge1xuICAgIHN0YXRlLndhcm4oJ0lubGluZS10ZW1wbGF0ZSBjb21wb25lbnRzIG11c3QgaGF2ZSBleGFjdGx5IG9uZSBjaGlsZCBlbGVtZW50LicpO1xuICB9XG4gIGlmIChhc3QudHlwZSA9PT0gMSkge1xuICAgIHZhciBpbmxpbmVSZW5kZXJGbnMgPSBnZW5lcmF0ZShhc3QsIHN0YXRlLm9wdGlvbnMpO1xuICAgIHJldHVybiAoXCJpbmxpbmVUZW1wbGF0ZTp7cmVuZGVyOmZ1bmN0aW9uKCl7XCIgKyAoaW5saW5lUmVuZGVyRm5zLnJlbmRlcikgKyBcIn0sc3RhdGljUmVuZGVyRm5zOltcIiArIChpbmxpbmVSZW5kZXJGbnMuc3RhdGljUmVuZGVyRm5zLm1hcChmdW5jdGlvbiAoY29kZSkgeyByZXR1cm4gKFwiZnVuY3Rpb24oKXtcIiArIGNvZGUgKyBcIn1cIik7IH0pLmpvaW4oJywnKSkgKyBcIl19XCIpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuU2NvcGVkU2xvdHMgKFxuICBzbG90cyxcbiAgc3RhdGVcbikge1xuICByZXR1cm4gKFwic2NvcGVkU2xvdHM6X3UoW1wiICsgKE9iamVjdC5rZXlzKHNsb3RzKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIGdlblNjb3BlZFNsb3Qoa2V5LCBzbG90c1trZXldLCBzdGF0ZSlcbiAgICB9KS5qb2luKCcsJykpICsgXCJdKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5TY29wZWRTbG90IChcbiAga2V5LFxuICBlbCxcbiAgc3RhdGVcbikge1xuICBpZiAoZWwuZm9yICYmICFlbC5mb3JQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuRm9yU2NvcGVkU2xvdChrZXksIGVsLCBzdGF0ZSlcbiAgfVxuICByZXR1cm4gXCJ7a2V5OlwiICsga2V5ICsgXCIsZm46ZnVuY3Rpb24oXCIgKyAoU3RyaW5nKGVsLmF0dHJzTWFwLnNjb3BlKSkgKyBcIil7XCIgK1xuICAgIFwicmV0dXJuIFwiICsgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJ1xuICAgICAgPyBnZW5DaGlsZHJlbihlbCwgc3RhdGUpIHx8ICd2b2lkIDAnXG4gICAgICA6IGdlbkVsZW1lbnQoZWwsIHN0YXRlKSkgKyBcIn19XCJcbn1cblxuZnVuY3Rpb24gZ2VuRm9yU2NvcGVkU2xvdCAoXG4gIGtleSxcbiAgZWwsXG4gIHN0YXRlXG4pIHtcbiAgdmFyIGV4cCA9IGVsLmZvcjtcbiAgdmFyIGFsaWFzID0gZWwuYWxpYXM7XG4gIHZhciBpdGVyYXRvcjEgPSBlbC5pdGVyYXRvcjEgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IxKSkgOiAnJztcbiAgdmFyIGl0ZXJhdG9yMiA9IGVsLml0ZXJhdG9yMiA/IChcIixcIiArIChlbC5pdGVyYXRvcjIpKSA6ICcnO1xuICBlbC5mb3JQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgcmV0dXJuIFwiX2woKFwiICsgZXhwICsgXCIpLFwiICtcbiAgICBcImZ1bmN0aW9uKFwiICsgYWxpYXMgKyBpdGVyYXRvcjEgKyBpdGVyYXRvcjIgKyBcIil7XCIgK1xuICAgICAgXCJyZXR1cm4gXCIgKyAoZ2VuU2NvcGVkU2xvdChrZXksIGVsLCBzdGF0ZSkpICtcbiAgICAnfSknXG59XG5cbmZ1bmN0aW9uIGdlbkNoaWxkcmVuIChcbiAgZWwsXG4gIHN0YXRlLFxuICBjaGVja1NraXAsXG4gIGFsdEdlbkVsZW1lbnQsXG4gIGFsdEdlbk5vZGVcbikge1xuICB2YXIgY2hpbGRyZW4gPSBlbC5jaGlsZHJlbjtcbiAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgIHZhciBlbCQxID0gY2hpbGRyZW5bMF07XG4gICAgLy8gb3B0aW1pemUgc2luZ2xlIHYtZm9yXG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgZWwkMS5mb3IgJiZcbiAgICAgIGVsJDEudGFnICE9PSAndGVtcGxhdGUnICYmXG4gICAgICBlbCQxLnRhZyAhPT0gJ3Nsb3QnXG4gICAgKSB7XG4gICAgICByZXR1cm4gKGFsdEdlbkVsZW1lbnQgfHwgZ2VuRWxlbWVudCkoZWwkMSwgc3RhdGUpXG4gICAgfVxuICAgIHZhciBub3JtYWxpemF0aW9uVHlwZSA9IGNoZWNrU2tpcFxuICAgICAgPyBnZXROb3JtYWxpemF0aW9uVHlwZShjaGlsZHJlbiwgc3RhdGUubWF5YmVDb21wb25lbnQpXG4gICAgICA6IDA7XG4gICAgdmFyIGdlbiA9IGFsdEdlbk5vZGUgfHwgZ2VuTm9kZTtcbiAgICByZXR1cm4gKFwiW1wiICsgKGNoaWxkcmVuLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gZ2VuKGMsIHN0YXRlKTsgfSkuam9pbignLCcpKSArIFwiXVwiICsgKG5vcm1hbGl6YXRpb25UeXBlID8gKFwiLFwiICsgbm9ybWFsaXphdGlvblR5cGUpIDogJycpKVxuICB9XG59XG5cbi8vIGRldGVybWluZSB0aGUgbm9ybWFsaXphdGlvbiBuZWVkZWQgZm9yIHRoZSBjaGlsZHJlbiBhcnJheS5cbi8vIDA6IG5vIG5vcm1hbGl6YXRpb24gbmVlZGVkXG4vLyAxOiBzaW1wbGUgbm9ybWFsaXphdGlvbiBuZWVkZWQgKHBvc3NpYmxlIDEtbGV2ZWwgZGVlcCBuZXN0ZWQgYXJyYXkpXG4vLyAyOiBmdWxsIG5vcm1hbGl6YXRpb24gbmVlZGVkXG5mdW5jdGlvbiBnZXROb3JtYWxpemF0aW9uVHlwZSAoXG4gIGNoaWxkcmVuLFxuICBtYXliZUNvbXBvbmVudFxuKSB7XG4gIHZhciByZXMgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGVsLnR5cGUgIT09IDEpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmIChuZWVkc05vcm1hbGl6YXRpb24oZWwpIHx8XG4gICAgICAgIChlbC5pZkNvbmRpdGlvbnMgJiYgZWwuaWZDb25kaXRpb25zLnNvbWUoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG5lZWRzTm9ybWFsaXphdGlvbihjLmJsb2NrKTsgfSkpKSB7XG4gICAgICByZXMgPSAyO1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgaWYgKG1heWJlQ29tcG9uZW50KGVsKSB8fFxuICAgICAgICAoZWwuaWZDb25kaXRpb25zICYmIGVsLmlmQ29uZGl0aW9ucy5zb21lKGZ1bmN0aW9uIChjKSB7IHJldHVybiBtYXliZUNvbXBvbmVudChjLmJsb2NrKTsgfSkpKSB7XG4gICAgICByZXMgPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIG5lZWRzTm9ybWFsaXphdGlvbiAoZWwpIHtcbiAgcmV0dXJuIGVsLmZvciAhPT0gdW5kZWZpbmVkIHx8IGVsLnRhZyA9PT0gJ3RlbXBsYXRlJyB8fCBlbC50YWcgPT09ICdzbG90J1xufVxuXG5mdW5jdGlvbiBnZW5Ob2RlIChub2RlLCBzdGF0ZSkge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgcmV0dXJuIGdlbkVsZW1lbnQobm9kZSwgc3RhdGUpXG4gIH0gaWYgKG5vZGUudHlwZSA9PT0gMyAmJiBub2RlLmlzQ29tbWVudCkge1xuICAgIHJldHVybiBnZW5Db21tZW50KG5vZGUpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdlblRleHQobm9kZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5UZXh0ICh0ZXh0KSB7XG4gIHJldHVybiAoXCJfdihcIiArICh0ZXh0LnR5cGUgPT09IDJcbiAgICA/IHRleHQuZXhwcmVzc2lvbiAvLyBubyBuZWVkIGZvciAoKSBiZWNhdXNlIGFscmVhZHkgd3JhcHBlZCBpbiBfcygpXG4gICAgOiB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMoSlNPTi5zdHJpbmdpZnkodGV4dC50ZXh0KSkpICsgXCIpXCIpXG59XG5cbmZ1bmN0aW9uIGdlbkNvbW1lbnQgKGNvbW1lbnQpIHtcbiAgcmV0dXJuIChcIl9lKCdcIiArIChjb21tZW50LnRleHQpICsgXCInKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5TbG90IChlbCwgc3RhdGUpIHtcbiAgdmFyIHNsb3ROYW1lID0gZWwuc2xvdE5hbWUgfHwgJ1wiZGVmYXVsdFwiJztcbiAgdmFyIGNoaWxkcmVuID0gZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKTtcbiAgdmFyIHJlcyA9IFwiX3QoXCIgKyBzbG90TmFtZSArIChjaGlsZHJlbiA/IChcIixcIiArIGNoaWxkcmVuKSA6ICcnKTtcbiAgdmFyIGF0dHJzID0gZWwuYXR0cnMgJiYgKFwie1wiICsgKGVsLmF0dHJzLm1hcChmdW5jdGlvbiAoYSkgeyByZXR1cm4gKChjYW1lbGl6ZShhLm5hbWUpKSArIFwiOlwiICsgKGEudmFsdWUpKTsgfSkuam9pbignLCcpKSArIFwifVwiKTtcbiAgdmFyIGJpbmQkJDEgPSBlbC5hdHRyc01hcFsndi1iaW5kJ107XG4gIGlmICgoYXR0cnMgfHwgYmluZCQkMSkgJiYgIWNoaWxkcmVuKSB7XG4gICAgcmVzICs9IFwiLG51bGxcIjtcbiAgfVxuICBpZiAoYXR0cnMpIHtcbiAgICByZXMgKz0gXCIsXCIgKyBhdHRycztcbiAgfVxuICBpZiAoYmluZCQkMSkge1xuICAgIHJlcyArPSAoYXR0cnMgPyAnJyA6ICcsbnVsbCcpICsgXCIsXCIgKyBiaW5kJCQxO1xuICB9XG4gIHJldHVybiByZXMgKyAnKSdcbn1cblxuLy8gY29tcG9uZW50TmFtZSBpcyBlbC5jb21wb25lbnQsIHRha2UgaXQgYXMgYXJndW1lbnQgdG8gc2h1biBmbG93J3MgcGVzc2ltaXN0aWMgcmVmaW5lbWVudFxuZnVuY3Rpb24gZ2VuQ29tcG9uZW50IChcbiAgY29tcG9uZW50TmFtZSxcbiAgZWwsXG4gIHN0YXRlXG4pIHtcbiAgdmFyIGNoaWxkcmVuID0gZWwuaW5saW5lVGVtcGxhdGUgPyBudWxsIDogZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlLCB0cnVlKTtcbiAgcmV0dXJuIChcIl9jKFwiICsgY29tcG9uZW50TmFtZSArIFwiLFwiICsgKGdlbkRhdGEkMihlbCwgc3RhdGUpKSArIChjaGlsZHJlbiA/IChcIixcIiArIGNoaWxkcmVuKSA6ICcnKSArIFwiKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5Qcm9wcyAocHJvcHMpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByb3AgPSBwcm9wc1tpXTtcbiAgICByZXMgKz0gXCJcXFwiXCIgKyAocHJvcC5uYW1lKSArIFwiXFxcIjpcIiArICh0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMocHJvcC52YWx1ZSkpICsgXCIsXCI7XG4gIH1cbiAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSlcbn1cblxuLy8gIzM4OTUsICM0MjY4XG5mdW5jdGlvbiB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMgKHRleHQpIHtcbiAgcmV0dXJuIHRleHRcbiAgICAucmVwbGFjZSgvXFx1MjAyOC9nLCAnXFxcXHUyMDI4JylcbiAgICAucmVwbGFjZSgvXFx1MjAyOS9nLCAnXFxcXHUyMDI5Jylcbn1cblxuLyogICovXG5cbi8vIHRoZXNlIGtleXdvcmRzIHNob3VsZCBub3QgYXBwZWFyIGluc2lkZSBleHByZXNzaW9ucywgYnV0IG9wZXJhdG9ycyBsaWtlXG4vLyB0eXBlb2YsIGluc3RhbmNlb2YgYW5kIGluIGFyZSBhbGxvd2VkXG52YXIgcHJvaGliaXRlZEtleXdvcmRSRSA9IG5ldyBSZWdFeHAoJ1xcXFxiJyArIChcbiAgJ2RvLGlmLGZvcixsZXQsbmV3LHRyeSx2YXIsY2FzZSxlbHNlLHdpdGgsYXdhaXQsYnJlYWssY2F0Y2gsY2xhc3MsY29uc3QsJyArXG4gICdzdXBlcix0aHJvdyx3aGlsZSx5aWVsZCxkZWxldGUsZXhwb3J0LGltcG9ydCxyZXR1cm4sc3dpdGNoLGRlZmF1bHQsJyArXG4gICdleHRlbmRzLGZpbmFsbHksY29udGludWUsZGVidWdnZXIsZnVuY3Rpb24sYXJndW1lbnRzJ1xuKS5zcGxpdCgnLCcpLmpvaW4oJ1xcXFxifFxcXFxiJykgKyAnXFxcXGInKTtcblxuLy8gdGhlc2UgdW5hcnkgb3BlcmF0b3JzIHNob3VsZCBub3QgYmUgdXNlZCBhcyBwcm9wZXJ0eS9tZXRob2QgbmFtZXNcbnZhciB1bmFyeU9wZXJhdG9yc1JFID0gbmV3IFJlZ0V4cCgnXFxcXGInICsgKFxuICAnZGVsZXRlLHR5cGVvZix2b2lkJ1xuKS5zcGxpdCgnLCcpLmpvaW4oJ1xcXFxzKlxcXFwoW15cXFxcKV0qXFxcXCl8XFxcXGInKSArICdcXFxccypcXFxcKFteXFxcXCldKlxcXFwpJyk7XG5cbi8vIGNoZWNrIHZhbGlkIGlkZW50aWZpZXIgZm9yIHYtZm9yXG52YXIgaWRlbnRSRSA9IC9bQS1aYS16XyRdW1xcdyRdKi87XG5cbi8vIHN0cmlwIHN0cmluZ3MgaW4gZXhwcmVzc2lvbnNcbnZhciBzdHJpcFN0cmluZ1JFID0gLycoPzpbXidcXFxcXXxcXFxcLikqJ3xcIig/OlteXCJcXFxcXXxcXFxcLikqXCJ8YCg/OlteYFxcXFxdfFxcXFwuKSpcXCRcXHt8XFx9KD86W15gXFxcXF18XFxcXC4pKmB8YCg/OlteYFxcXFxdfFxcXFwuKSpgL2c7XG5cbi8vIGRldGVjdCBwcm9ibGVtYXRpYyBleHByZXNzaW9ucyBpbiBhIHRlbXBsYXRlXG5mdW5jdGlvbiBkZXRlY3RFcnJvcnMgKGFzdCkge1xuICB2YXIgZXJyb3JzID0gW107XG4gIGlmIChhc3QpIHtcbiAgICBjaGVja05vZGUoYXN0LCBlcnJvcnMpO1xuICB9XG4gIHJldHVybiBlcnJvcnNcbn1cblxuZnVuY3Rpb24gY2hlY2tOb2RlIChub2RlLCBlcnJvcnMpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIGZvciAodmFyIG5hbWUgaW4gbm9kZS5hdHRyc01hcCkge1xuICAgICAgaWYgKGRpclJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gbm9kZS5hdHRyc01hcFtuYW1lXTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKG5hbWUgPT09ICd2LWZvcicpIHtcbiAgICAgICAgICAgIGNoZWNrRm9yKG5vZGUsIChcInYtZm9yPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCBlcnJvcnMpO1xuICAgICAgICAgIH0gZWxzZSBpZiAob25SRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgICBjaGVja0V2ZW50KHZhbHVlLCAobmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCBlcnJvcnMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGVja0V4cHJlc3Npb24odmFsdWUsIChuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIGVycm9ycyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2hlY2tOb2RlKG5vZGUuY2hpbGRyZW5baV0sIGVycm9ycyk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gMikge1xuICAgIGNoZWNrRXhwcmVzc2lvbihub2RlLmV4cHJlc3Npb24sIG5vZGUudGV4dCwgZXJyb3JzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0V2ZW50IChleHAsIHRleHQsIGVycm9ycykge1xuICB2YXIgc3RpcHBlZCA9IGV4cC5yZXBsYWNlKHN0cmlwU3RyaW5nUkUsICcnKTtcbiAgdmFyIGtleXdvcmRNYXRjaCA9IHN0aXBwZWQubWF0Y2godW5hcnlPcGVyYXRvcnNSRSk7XG4gIGlmIChrZXl3b3JkTWF0Y2ggJiYgc3RpcHBlZC5jaGFyQXQoa2V5d29yZE1hdGNoLmluZGV4IC0gMSkgIT09ICckJykge1xuICAgIGVycm9ycy5wdXNoKFxuICAgICAgXCJhdm9pZCB1c2luZyBKYXZhU2NyaXB0IHVuYXJ5IG9wZXJhdG9yIGFzIHByb3BlcnR5IG5hbWU6IFwiICtcbiAgICAgIFwiXFxcIlwiICsgKGtleXdvcmRNYXRjaFswXSkgKyBcIlxcXCIgaW4gZXhwcmVzc2lvbiBcIiArICh0ZXh0LnRyaW0oKSlcbiAgICApO1xuICB9XG4gIGNoZWNrRXhwcmVzc2lvbihleHAsIHRleHQsIGVycm9ycyk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrRm9yIChub2RlLCB0ZXh0LCBlcnJvcnMpIHtcbiAgY2hlY2tFeHByZXNzaW9uKG5vZGUuZm9yIHx8ICcnLCB0ZXh0LCBlcnJvcnMpO1xuICBjaGVja0lkZW50aWZpZXIobm9kZS5hbGlhcywgJ3YtZm9yIGFsaWFzJywgdGV4dCwgZXJyb3JzKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuaXRlcmF0b3IxLCAndi1mb3IgaXRlcmF0b3InLCB0ZXh0LCBlcnJvcnMpO1xuICBjaGVja0lkZW50aWZpZXIobm9kZS5pdGVyYXRvcjIsICd2LWZvciBpdGVyYXRvcicsIHRleHQsIGVycm9ycyk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrSWRlbnRpZmllciAoaWRlbnQsIHR5cGUsIHRleHQsIGVycm9ycykge1xuICBpZiAodHlwZW9mIGlkZW50ID09PSAnc3RyaW5nJyAmJiAhaWRlbnRSRS50ZXN0KGlkZW50KSkge1xuICAgIGVycm9ycy5wdXNoKChcImludmFsaWQgXCIgKyB0eXBlICsgXCIgXFxcIlwiICsgaWRlbnQgKyBcIlxcXCIgaW4gZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tFeHByZXNzaW9uIChleHAsIHRleHQsIGVycm9ycykge1xuICB0cnkge1xuICAgIG5ldyBGdW5jdGlvbigoXCJyZXR1cm4gXCIgKyBleHApKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHZhciBrZXl3b3JkTWF0Y2ggPSBleHAucmVwbGFjZShzdHJpcFN0cmluZ1JFLCAnJykubWF0Y2gocHJvaGliaXRlZEtleXdvcmRSRSk7XG4gICAgaWYgKGtleXdvcmRNYXRjaCkge1xuICAgICAgZXJyb3JzLnB1c2goXG4gICAgICAgIFwiYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCBrZXl3b3JkIGFzIHByb3BlcnR5IG5hbWU6IFwiICtcbiAgICAgICAgXCJcXFwiXCIgKyAoa2V5d29yZE1hdGNoWzBdKSArIFwiXFxcIiBpbiBleHByZXNzaW9uIFwiICsgKHRleHQudHJpbSgpKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXJyb3JzLnB1c2goKFwiaW52YWxpZCBleHByZXNzaW9uOiBcIiArICh0ZXh0LnRyaW0oKSkpKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uIChjb2RlLCBlcnJvcnMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKGNvZGUpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVycm9ycy5wdXNoKHsgZXJyOiBlcnIsIGNvZGU6IGNvZGUgfSk7XG4gICAgcmV0dXJuIG5vb3BcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21waWxlVG9GdW5jdGlvbkZuIChjb21waWxlKSB7XG4gIHZhciBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXBpbGVUb0Z1bmN0aW9ucyAoXG4gICAgdGVtcGxhdGUsXG4gICAgb3B0aW9ucyxcbiAgICB2bVxuICApIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIHtcbiAgICAgIC8vIGRldGVjdCBwb3NzaWJsZSBDU1AgcmVzdHJpY3Rpb25cbiAgICAgIHRyeSB7XG4gICAgICAgIG5ldyBGdW5jdGlvbigncmV0dXJuIDEnKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUudG9TdHJpbmcoKS5tYXRjaCgvdW5zYWZlLWV2YWx8Q1NQLykpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgJ0l0IHNlZW1zIHlvdSBhcmUgdXNpbmcgdGhlIHN0YW5kYWxvbmUgYnVpbGQgb2YgVnVlLmpzIGluIGFuICcgK1xuICAgICAgICAgICAgJ2Vudmlyb25tZW50IHdpdGggQ29udGVudCBTZWN1cml0eSBQb2xpY3kgdGhhdCBwcm9oaWJpdHMgdW5zYWZlLWV2YWwuICcgK1xuICAgICAgICAgICAgJ1RoZSB0ZW1wbGF0ZSBjb21waWxlciBjYW5ub3Qgd29yayBpbiB0aGlzIGVudmlyb25tZW50LiBDb25zaWRlciAnICtcbiAgICAgICAgICAgICdyZWxheGluZyB0aGUgcG9saWN5IHRvIGFsbG93IHVuc2FmZS1ldmFsIG9yIHByZS1jb21waWxpbmcgeW91ciAnICtcbiAgICAgICAgICAgICd0ZW1wbGF0ZXMgaW50byByZW5kZXIgZnVuY3Rpb25zLidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgY2FjaGVcbiAgICB2YXIga2V5ID0gb3B0aW9ucy5kZWxpbWl0ZXJzXG4gICAgICA/IFN0cmluZyhvcHRpb25zLmRlbGltaXRlcnMpICsgdGVtcGxhdGVcbiAgICAgIDogdGVtcGxhdGU7XG4gICAgaWYgKGNhY2hlW2tleV0pIHtcbiAgICAgIHJldHVybiBjYWNoZVtrZXldXG4gICAgfVxuXG4gICAgLy8gY29tcGlsZVxuICAgIHZhciBjb21waWxlZCA9IGNvbXBpbGUodGVtcGxhdGUsIG9wdGlvbnMpO1xuXG4gICAgLy8gY2hlY2sgY29tcGlsYXRpb24gZXJyb3JzL3RpcHNcbiAgICB7XG4gICAgICBpZiAoY29tcGlsZWQuZXJyb3JzICYmIGNvbXBpbGVkLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIkVycm9yIGNvbXBpbGluZyB0ZW1wbGF0ZTpcXG5cXG5cIiArIHRlbXBsYXRlICsgXCJcXG5cXG5cIiArXG4gICAgICAgICAgY29tcGlsZWQuZXJyb3JzLm1hcChmdW5jdGlvbiAoZSkgeyByZXR1cm4gKFwiLSBcIiArIGUpOyB9KS5qb2luKCdcXG4nKSArICdcXG4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoY29tcGlsZWQudGlwcyAmJiBjb21waWxlZC50aXBzLmxlbmd0aCkge1xuICAgICAgICBjb21waWxlZC50aXBzLmZvckVhY2goZnVuY3Rpb24gKG1zZykgeyByZXR1cm4gdGlwKG1zZywgdm0pOyB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0dXJuIGNvZGUgaW50byBmdW5jdGlvbnNcbiAgICB2YXIgcmVzID0ge307XG4gICAgdmFyIGZuR2VuRXJyb3JzID0gW107XG4gICAgcmVzLnJlbmRlciA9IGNyZWF0ZUZ1bmN0aW9uKGNvbXBpbGVkLnJlbmRlciwgZm5HZW5FcnJvcnMpO1xuICAgIHJlcy5zdGF0aWNSZW5kZXJGbnMgPSBjb21waWxlZC5zdGF0aWNSZW5kZXJGbnMubWFwKGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb24oY29kZSwgZm5HZW5FcnJvcnMpXG4gICAgfSk7XG5cbiAgICAvLyBjaGVjayBmdW5jdGlvbiBnZW5lcmF0aW9uIGVycm9ycy5cbiAgICAvLyB0aGlzIHNob3VsZCBvbmx5IGhhcHBlbiBpZiB0aGVyZSBpcyBhIGJ1ZyBpbiB0aGUgY29tcGlsZXIgaXRzZWxmLlxuICAgIC8vIG1vc3RseSBmb3IgY29kZWdlbiBkZXZlbG9wbWVudCB1c2VcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICB7XG4gICAgICBpZiAoKCFjb21waWxlZC5lcnJvcnMgfHwgIWNvbXBpbGVkLmVycm9ycy5sZW5ndGgpICYmIGZuR2VuRXJyb3JzLmxlbmd0aCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiRmFpbGVkIHRvIGdlbmVyYXRlIHJlbmRlciBmdW5jdGlvbjpcXG5cXG5cIiArXG4gICAgICAgICAgZm5HZW5FcnJvcnMubWFwKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSByZWYuZXJyO1xuICAgICAgICAgICAgdmFyIGNvZGUgPSByZWYuY29kZTtcblxuICAgICAgICAgICAgcmV0dXJuICgoZXJyLnRvU3RyaW5nKCkpICsgXCIgaW5cXG5cXG5cIiArIGNvZGUgKyBcIlxcblwiKTtcbiAgICAgICAgfSkuam9pbignXFxuJyksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gKGNhY2hlW2tleV0gPSByZXMpXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyQ3JlYXRvciAoYmFzZUNvbXBpbGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyIChiYXNlT3B0aW9ucykge1xuICAgIGZ1bmN0aW9uIGNvbXBpbGUgKFxuICAgICAgdGVtcGxhdGUsXG4gICAgICBvcHRpb25zXG4gICAgKSB7XG4gICAgICB2YXIgZmluYWxPcHRpb25zID0gT2JqZWN0LmNyZWF0ZShiYXNlT3B0aW9ucyk7XG4gICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICB2YXIgdGlwcyA9IFtdO1xuICAgICAgZmluYWxPcHRpb25zLndhcm4gPSBmdW5jdGlvbiAobXNnLCB0aXApIHtcbiAgICAgICAgKHRpcCA/IHRpcHMgOiBlcnJvcnMpLnB1c2gobXNnKTtcbiAgICAgIH07XG5cbiAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIC8vIG1lcmdlIGN1c3RvbSBtb2R1bGVzXG4gICAgICAgIGlmIChvcHRpb25zLm1vZHVsZXMpIHtcbiAgICAgICAgICBmaW5hbE9wdGlvbnMubW9kdWxlcyA9XG4gICAgICAgICAgICAoYmFzZU9wdGlvbnMubW9kdWxlcyB8fCBbXSkuY29uY2F0KG9wdGlvbnMubW9kdWxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWVyZ2UgY3VzdG9tIGRpcmVjdGl2ZXNcbiAgICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0aXZlcykge1xuICAgICAgICAgIGZpbmFsT3B0aW9ucy5kaXJlY3RpdmVzID0gZXh0ZW5kKFxuICAgICAgICAgICAgT2JqZWN0LmNyZWF0ZShiYXNlT3B0aW9ucy5kaXJlY3RpdmVzKSxcbiAgICAgICAgICAgIG9wdGlvbnMuZGlyZWN0aXZlc1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29weSBvdGhlciBvcHRpb25zXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKGtleSAhPT0gJ21vZHVsZXMnICYmIGtleSAhPT0gJ2RpcmVjdGl2ZXMnKSB7XG4gICAgICAgICAgICBmaW5hbE9wdGlvbnNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGNvbXBpbGVkID0gYmFzZUNvbXBpbGUodGVtcGxhdGUsIGZpbmFsT3B0aW9ucyk7XG4gICAgICB7XG4gICAgICAgIGVycm9ycy5wdXNoLmFwcGx5KGVycm9ycywgZGV0ZWN0RXJyb3JzKGNvbXBpbGVkLmFzdCkpO1xuICAgICAgfVxuICAgICAgY29tcGlsZWQuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgY29tcGlsZWQudGlwcyA9IHRpcHM7XG4gICAgICByZXR1cm4gY29tcGlsZWRcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY29tcGlsZTogY29tcGlsZSxcbiAgICAgIGNvbXBpbGVUb0Z1bmN0aW9uczogY3JlYXRlQ29tcGlsZVRvRnVuY3Rpb25Gbihjb21waWxlKVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gYGNyZWF0ZUNvbXBpbGVyQ3JlYXRvcmAgYWxsb3dzIGNyZWF0aW5nIGNvbXBpbGVycyB0aGF0IHVzZSBhbHRlcm5hdGl2ZVxuLy8gcGFyc2VyL29wdGltaXplci9jb2RlZ2VuLCBlLmcgdGhlIFNTUiBvcHRpbWl6aW5nIGNvbXBpbGVyLlxuLy8gSGVyZSB3ZSBqdXN0IGV4cG9ydCBhIGRlZmF1bHQgY29tcGlsZXIgdXNpbmcgdGhlIGRlZmF1bHQgcGFydHMuXG52YXIgY3JlYXRlQ29tcGlsZXIgPSBjcmVhdGVDb21waWxlckNyZWF0b3IoZnVuY3Rpb24gYmFzZUNvbXBpbGUgKFxuICB0ZW1wbGF0ZSxcbiAgb3B0aW9uc1xuKSB7XG4gIHZhciBhc3QgPSBwYXJzZSh0ZW1wbGF0ZS50cmltKCksIG9wdGlvbnMpO1xuICBvcHRpbWl6ZShhc3QsIG9wdGlvbnMpO1xuICB2YXIgY29kZSA9IGdlbmVyYXRlKGFzdCwgb3B0aW9ucyk7XG4gIHJldHVybiB7XG4gICAgYXN0OiBhc3QsXG4gICAgcmVuZGVyOiBjb2RlLnJlbmRlcixcbiAgICBzdGF0aWNSZW5kZXJGbnM6IGNvZGUuc3RhdGljUmVuZGVyRm5zXG4gIH1cbn0pO1xuXG4vKiAgKi9cblxudmFyIHJlZiQxID0gY3JlYXRlQ29tcGlsZXIoYmFzZU9wdGlvbnMpO1xudmFyIGNvbXBpbGVUb0Z1bmN0aW9ucyA9IHJlZiQxLmNvbXBpbGVUb0Z1bmN0aW9ucztcblxuLyogICovXG5cbnZhciBpZFRvVGVtcGxhdGUgPSBjYWNoZWQoZnVuY3Rpb24gKGlkKSB7XG4gIHZhciBlbCA9IHF1ZXJ5KGlkKTtcbiAgcmV0dXJuIGVsICYmIGVsLmlubmVySFRNTFxufSk7XG5cbnZhciBtb3VudCA9IFZ1ZSQzLnByb3RvdHlwZS4kbW91bnQ7XG5WdWUkMy5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgZWwgPSBlbCAmJiBxdWVyeShlbCk7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChlbCA9PT0gZG9jdW1lbnQuYm9keSB8fCBlbCA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiRG8gbm90IG1vdW50IFZ1ZSB0byA8aHRtbD4gb3IgPGJvZHk+IC0gbW91bnQgdG8gbm9ybWFsIGVsZW1lbnRzIGluc3RlYWQuXCJcbiAgICApO1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICB2YXIgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XG4gIC8vIHJlc29sdmUgdGVtcGxhdGUvZWwgYW5kIGNvbnZlcnQgdG8gcmVuZGVyIGZ1bmN0aW9uXG4gIGlmICghb3B0aW9ucy5yZW5kZXIpIHtcbiAgICB2YXIgdGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHRlbXBsYXRlLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgICAgdGVtcGxhdGUgPSBpZFRvVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiAhdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgIChcIlRlbXBsYXRlIGVsZW1lbnQgbm90IGZvdW5kIG9yIGlzIGVtcHR5OiBcIiArIChvcHRpb25zLnRlbXBsYXRlKSksXG4gICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRlbXBsYXRlLm5vZGVUeXBlKSB7XG4gICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUuaW5uZXJIVE1MO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAge1xuICAgICAgICAgIHdhcm4oJ2ludmFsaWQgdGVtcGxhdGUgb3B0aW9uOicgKyB0ZW1wbGF0ZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsKSB7XG4gICAgICB0ZW1wbGF0ZSA9IGdldE91dGVySFRNTChlbCk7XG4gICAgfVxuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgICAgbWFyaygnY29tcGlsZScpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVmID0gY29tcGlsZVRvRnVuY3Rpb25zKHRlbXBsYXRlLCB7XG4gICAgICAgIHNob3VsZERlY29kZU5ld2xpbmVzOiBzaG91bGREZWNvZGVOZXdsaW5lcyxcbiAgICAgICAgZGVsaW1pdGVyczogb3B0aW9ucy5kZWxpbWl0ZXJzLFxuICAgICAgICBjb21tZW50czogb3B0aW9ucy5jb21tZW50c1xuICAgICAgfSwgdGhpcyk7XG4gICAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcbiAgICAgIHZhciBzdGF0aWNSZW5kZXJGbnMgPSByZWYuc3RhdGljUmVuZGVyRm5zO1xuICAgICAgb3B0aW9ucy5yZW5kZXIgPSByZW5kZXI7XG4gICAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZucztcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgICAgbWFyaygnY29tcGlsZSBlbmQnKTtcbiAgICAgICAgbWVhc3VyZSgoKHRoaXMuX25hbWUpICsgXCIgY29tcGlsZVwiKSwgJ2NvbXBpbGUnLCAnY29tcGlsZSBlbmQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1vdW50LmNhbGwodGhpcywgZWwsIGh5ZHJhdGluZylcbn07XG5cbi8qKlxuICogR2V0IG91dGVySFRNTCBvZiBlbGVtZW50cywgdGFraW5nIGNhcmVcbiAqIG9mIFNWRyBlbGVtZW50cyBpbiBJRSBhcyB3ZWxsLlxuICovXG5mdW5jdGlvbiBnZXRPdXRlckhUTUwgKGVsKSB7XG4gIGlmIChlbC5vdXRlckhUTUwpIHtcbiAgICByZXR1cm4gZWwub3V0ZXJIVE1MXG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbC5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgIHJldHVybiBjb250YWluZXIuaW5uZXJIVE1MXG4gIH1cbn1cblxuVnVlJDMuY29tcGlsZSA9IGNvbXBpbGVUb0Z1bmN0aW9ucztcblxucmV0dXJuIFZ1ZSQzO1xuXG59KSkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3Z1ZUAyLjQuMS5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n");

/***/ }),
/* 1 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar g;\n\n// This works in non-strict mode\ng = function () {\n\treturn this;\n}();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzPzM2OTgiXSwibmFtZXMiOlsiZyIsIkZ1bmN0aW9uIiwiZXZhbCIsImUiLCJ3aW5kb3ciLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOztBQUFBLElBQUlBLENBQUo7O0FBRUE7QUFDQUEsSUFBSyxZQUFXO0FBQ2YsUUFBTyxJQUFQO0FBQ0EsQ0FGRyxFQUFKOztBQUlBLElBQUk7QUFDSDtBQUNBQSxLQUFJQSxLQUFLQyxTQUFTLGFBQVQsR0FBTCxJQUFrQyxDQUFDLEdBQUVDLElBQUgsRUFBUyxNQUFULENBQXRDO0FBQ0EsQ0FIRCxDQUdFLE9BQU1DLENBQU4sRUFBUztBQUNWO0FBQ0EsS0FBRyxRQUFPQyxNQUFQLHlDQUFPQSxNQUFQLE9BQWtCLFFBQXJCLEVBQ0NKLElBQUlJLE1BQUo7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7O0FBRUFDLE9BQU9DLE9BQVAsR0FBaUJOLENBQWpCIiwiZmlsZSI6IjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1\n");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(0);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/OTU1MiJdLCJuYW1lcyI6WyJyZXF1aXJlIl0sIm1hcHBpbmdzIjoiQUFBQSxtQkFBQUEsQ0FBUSxDQUFSIiwiZmlsZSI6IjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKCcuL3Z1ZUAyLjQuMScpXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvaW5kZXguanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2\n");

/***/ })
/******/ ]);